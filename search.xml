<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA后台开发项目学习</title>
    <url>/2020/08/03/Java/JAVA%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="/images/JAVA%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/image-20200809192659015.png" alt="image-20200809192659015"></p>
<a id="more"></a>

<p>dao&#x3D;data access object</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="user表"><a href="#user表" class="headerlink" title="user表"></a>user表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;user&#96; (</span><br><span class="line">  &#96;id&#96; int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;username&#96; varchar(50) DEFAULT NULL,</span><br><span class="line">  &#96;password&#96; varchar(50) DEFAULT NULL,</span><br><span class="line">  &#96;salt&#96; varchar(50) DEFAULT NULL,</span><br><span class="line">  &#96;email&#96; varchar(100) DEFAULT NULL,</span><br><span class="line">  &#96;type&#96; int DEFAULT NULL COMMENT &#39;0-普通用户; 1-超级管理员; 2-版主;&#39;,</span><br><span class="line">  &#96;status&#96; int DEFAULT NULL COMMENT &#39;0-未激活; 1-已激活;&#39;,</span><br><span class="line">  &#96;activation_code&#96; varchar(100) DEFAULT NULL,</span><br><span class="line">  &#96;header_url&#96; varchar(200) DEFAULT NULL,</span><br><span class="line">  &#96;create_time&#96; timestamp NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;index_username&#96; (&#96;username&#96;(20)),</span><br><span class="line">  KEY &#96;index_email&#96; (&#96;email&#96;(20))</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;158 DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>

<h2 id="login-ticket表"><a href="#login-ticket表" class="headerlink" title="login_ticket表"></a>login_ticket表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;login_ticket&#96; (</span><br><span class="line">  &#96;id&#96; int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;user_id&#96; int NOT NULL,</span><br><span class="line">  &#96;ticket&#96; varchar(45) NOT NULL,</span><br><span class="line">  &#96;status&#96; int DEFAULT &#39;0&#39; COMMENT &#39;0-有效; 1-无效;&#39;,</span><br><span class="line">  &#96;expired&#96; timestamp NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;index_ticket&#96; (&#96;ticket&#96;(20))</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;24 DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>

<h2 id="discuss-post表"><a href="#discuss-post表" class="headerlink" title="discuss_post表"></a>discuss_post表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;discuss_post&#96; (</span><br><span class="line">  &#96;id&#96; int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;user_id&#96; varchar(45) DEFAULT NULL,</span><br><span class="line">  &#96;title&#96; varchar(100) DEFAULT NULL,</span><br><span class="line">  &#96;content&#96; text,</span><br><span class="line">  &#96;type&#96; int DEFAULT NULL COMMENT &#39;0-普通; 1-置顶;&#39;,</span><br><span class="line">  &#96;status&#96; int DEFAULT NULL COMMENT &#39;0-正常; 1-精华; 2-拉黑;&#39;,</span><br><span class="line">  &#96;create_time&#96; timestamp NULL DEFAULT NULL,</span><br><span class="line">  &#96;comment_count&#96; int DEFAULT NULL,</span><br><span class="line">  &#96;score&#96; double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;index_user_id&#96; (&#96;user_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;289 DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>

<h2 id="comment表"><a href="#comment表" class="headerlink" title="comment表"></a>comment表</h2><p>评论的评论称为回复。</p>
<p>查询某个帖子的评论时，给定type值和帖子id即可。</p>
<p>查询某个评论的回复时，给定type值和评论id即可。同时若targetId不为0，则还需要查询回复的目标用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;comment&#96; (</span><br><span class="line">  &#96;id&#96; int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;user_id&#96; int DEFAULT NULL,</span><br><span class="line">  &#96;entity_type&#96; int DEFAULT NULL, &#x2F;&#x2F; 评论目标的类型（帖子或评论）</span><br><span class="line">  &#96;entity_id&#96; int DEFAULT NULL, &#x2F;&#x2F; 评论目标的ID</span><br><span class="line">  &#96;target_id&#96; int DEFAULT NULL, &#x2F;&#x2F; 回复的目标用户ID</span><br><span class="line">  &#96;content&#96; text,</span><br><span class="line">  &#96;status&#96; int DEFAULT NULL,</span><br><span class="line">  &#96;create_time&#96; timestamp NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;index_user_id&#96; (&#96;user_id&#96;) &#x2F;*!80000 INVISIBLE *&#x2F;,</span><br><span class="line">  KEY &#96;index_entity_id&#96; (&#96;entity_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;249 DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>

<h2 id="message表"><a href="#message表" class="headerlink" title="message表"></a>message表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;message&#96; (</span><br><span class="line">  &#96;id&#96; int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;from_id&#96; int DEFAULT NULL, &#x2F;&#x2F; 系统通知为1</span><br><span class="line">  &#96;to_id&#96; int DEFAULT NULL,</span><br><span class="line">  &#96;conversation_id&#96; varchar(45) NOT NULL, &#x2F;&#x2F; from_id和to_id的组合，小的id在前。</span><br><span class="line">  &#96;content&#96; text,</span><br><span class="line">  &#96;status&#96; int DEFAULT NULL COMMENT &#39;0-未读;1-已读;2-删除;&#39;,</span><br><span class="line">  &#96;create_time&#96; timestamp NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;index_from_id&#96; (&#96;from_id&#96;),</span><br><span class="line">  KEY &#96;index_to_id&#96; (&#96;to_id&#96;),</span><br><span class="line">  KEY &#96;index_conversation_id&#96; (&#96;conversation_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;368 DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>

<h2 id="Redis表"><a href="#Redis表" class="headerlink" title="Redis表"></a>Redis表</h2><h3 id="某个实体获得的赞"><a href="#某个实体获得的赞" class="headerlink" title="某个实体获得的赞"></a>某个实体获得的赞</h3><ul>
<li><p><strong>key：</strong>“like:entity” + entityType + entityId</p>
</li>
<li><p><strong>value：</strong>set存放点赞的userId</p>
</li>
</ul>
<h3 id="某个用户获得的赞（个人主页显示）"><a href="#某个用户获得的赞（个人主页显示）" class="headerlink" title="某个用户获得的赞（个人主页显示）"></a>某个用户获得的赞（个人主页显示）</h3><ul>
<li><strong>key：</strong>“like:user” + userId</li>
<li><strong>value：</strong>string存放获得赞的数量</li>
</ul>
<h3 id="某个用户关注的用户"><a href="#某个用户关注的用户" class="headerlink" title="某个用户关注的用户"></a>某个用户关注的用户</h3><ul>
<li><strong>key：</strong>“followee:” + userId + “:user”</li>
<li><strong>value:</strong> zset存放关注的用户ID</li>
</ul>
<p>某个用户拥有的粉丝</p>
<ul>
<li><strong>key：</strong>“follower:user” + userId </li>
<li><strong>value：</strong>zset存放拥有的粉丝ID</li>
</ul>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>@Bean：修饰方法，该方法返回的对象会被装配到Bean容器中。</p>
<h2 id="Bean的管理"><a href="#Bean的管理" class="headerlink" title="Bean的管理"></a>Bean的管理</h2><ul>
<li>@PostConstruct：修饰方法，在Bean的构造函数之后调用。</li>
<li>@PreDestroy：修饰方法，在Bean销毁之前调用。</li>
</ul>
<h1 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h1><p>第14节 SpringMVC入门</p>
<h2 id="Get传递参数的方式"><a href="#Get传递参数的方式" class="headerlink" title="Get传递参数的方式"></a>Get传递参数的方式</h2><ul>
<li>在Url中通过?后接参数信息，如&#x2F;student?id&#x3D;1。这种方式可以通过<code>@RequestParam(name = &quot;id&quot;, required = false, defaultValue = &quot;1&quot;)</code>在服务器中对应的方法参数中获取。</li>
<li>在url中传递参数，如&#x2F;student&#x2F;1，同时<code>@RequestMapping(path = &quot;/student/{id}&quot;)</code>。这种方式可以通过<code>@PathVariable(&quot;id&quot;)</code>在服务器中对应的方法参数中获取。</li>
</ul>
<h2 id="Post传递参数的方式"><a href="#Post传递参数的方式" class="headerlink" title="Post传递参数的方式"></a>Post传递参数的方式</h2><p>前端表单中的参数名与后台对应方法的参数名一致即可。</p>
<h2 id="转发与重定向"><a href="#转发与重定向" class="headerlink" title="转发与重定向"></a>转发与重定向</h2><p>重定向：返回给浏览器<strong>302状态码</strong>和一个url，浏览器再次访问该url。如注册成功后自动跳转到登陆页面。</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>SpringBoot默认启用的日志工具为LOGBack（org.slf4j.Logger）</p>
<p>日志级别：trace，debug，info，warn，error</p>
<h1 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h1><ol>
<li>导入Spring Boot Mail Starter。</li>
<li>邮箱配置（域名，端口，发件人账号密码）。</li>
<li>构建MimeMessage（发件人，收件人，主题，内容）。</li>
<li>注入JavaMailSender实例，并调用其send()方法发送邮件。</li>
</ol>
<h1 id="工具包"><a href="#工具包" class="headerlink" title="工具包"></a>工具包</h1><ul>
<li>Apache Commons Lang：字符串工具包。</li>
<li>Kaptcha：生成验证码图片。</li>
<li>Fastjson：生成或处理json数据。</li>
</ul>
<h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>数据存在客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/cookie/set"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">// 生成一个键为key，值为value的cookie，并添加到response中返回给浏览器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setCookie</span><span class="params">(HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">	Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line">	<span class="comment">// 设置cookie生效的路径范围</span></span><br><span class="line">	cookie.setPath(<span class="string">"/community/alpha"</span>);</span><br><span class="line">	<span class="comment">// 设置cookie的生存时间（秒）</span></span><br><span class="line">	cookie.setMaxAge(<span class="number">60</span> * <span class="number">10</span>);</span><br><span class="line">	<span class="comment">// 发送cookie</span></span><br><span class="line">	response.addCooikie(cookie);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"set cookie"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/cookie/get"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">// 获取键为key的cookie的value，并传递给参数value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCookie</span><span class="params">(@CookieValue(<span class="string">"key"</span>)</span> String value) </span>&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"get cookie"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>数据存在服务器内存，只传递一个SessionID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/session/set"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">// 自动注入一个HttpSession实例，然后设置信息，（JSessionID）传给浏览器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setSession</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">"id"</span>, <span class="number">1</span>);</span><br><span class="line">    session.setAttribute(<span class="string">"name"</span>, djs);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"set session"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/session/get"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSession</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    System.out.println(session.getAttribute(<span class="string">"id"</span>));</span><br><span class="line">    System.out.println(session.getAttribute(<span class="string">"name"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"set session"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分布式Session：</p>
<ul>
<li>粘性Session：同一个IP分配到同一个服务器。</li>
<li>同步Session：每个服务器的Session通过同步保持一致。</li>
<li>共享Session：单独一台服务器存放Session数据，其他服务器向该服务器请求Session。</li>
<li>基于数据库：使用MySQL或者Redis集群存储Session，其他服务器向该集群请求Session。</li>
</ul>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>对于一些需要登录才能访问或者需要一定权限的路径如个人信息，需要使用拦截器检查登录状态。</p>
<p>在用户浏览网页时，需要检查用户登陆状态，通过拦截器实现。</p>
<ol>
<li><p>实现HandlerInterceptor接口中的三个方法：</p>
<ul>
<li><p>preHandler()：在Controller之前执行。获取Cookie中的凭证id，然后在数据库中查询凭证有效状态并根据凭证获取到User对象并保存到ThreadLocal变量hostHolder中。</p>
</li>
<li><p>postHandler()：在Controller之后，模板引擎之前执行。从hostHolder获取到User并传给模板引擎。</p>
</li>
<li><p>afterCompletion()：在模板引擎之后执行。清除hostHolder。</p>
</li>
</ul>
</li>
<li><p>在实现WebMvcConfigurer接口的类中addInterceptors()配置拦截器：拦截哪些路径，不拦截哪些路径。</p>
</li>
</ol>
<h1 id="检查登录状态"><a href="#检查登录状态" class="headerlink" title="检查登录状态"></a>检查登录状态</h1><p>通过自定义注解修饰需要拦截的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoginRequired &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在拦截器中检查拦截到的方法是否包含自定义注解，然后进行登录状态检查。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoginRequired loginRequired &#x3D; method.getAnnotation(LoginRequired.class);</span><br></pre></td></tr></table></figure>

<h1 id="敏感词过滤"><a href="#敏感词过滤" class="headerlink" title="敏感词过滤"></a>敏感词过滤</h1><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>查找效率高，消耗内存大</p>
<h2 id="敏感词过滤器"><a href="#敏感词过滤器" class="headerlink" title="敏感词过滤器"></a>敏感词过滤器</h2><ul>
<li>定义前缀树</li>
<li>根据敏感词，初始化前缀树</li>
<li>编写过滤敏感词的方法</li>
</ul>
<h1 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h1><ul>
<li>声明式事务<ul>
<li>通过XML配置，声明某方法的事务特征。</li>
<li>通过注解，声明某方法的事务特征。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(isolation = Isolation.READ_COMMMITED, propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编程式事务：通过TransactionTemplate管理事务，并通过它执行数据库操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate template;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    template.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITED);</span><br><span class="line">    template.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">    <span class="keyword">return</span> template.execute(<span class="keyword">new</span> TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 实现事务</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>隔离级别，传递机制。</p>
<h1 id="显示评论"><a href="#显示评论" class="headerlink" title="显示评论"></a>显示评论</h1><p>分页显示，评论，回复。</p>
<h1 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h1><p><strong>事务操作</strong>：增加评论并更新帖子的评论数量。</p>
<h1 id="私信列表"><a href="#私信列表" class="headerlink" title="私信列表"></a>私信列表</h1><p>显示未读消息数量，显示最新一条私信。</p>
<h1 id="发送私信"><a href="#发送私信" class="headerlink" title="发送私信"></a>发送私信</h1><p>异步发送</p>
<h1 id="统一处理异常"><a href="#统一处理异常" class="headerlink" title="统一处理异常"></a>统一处理异常</h1><p><strong>@ControllerAdvice</strong></p>
<ul>
<li><p>用于修饰类，表示该类是Controller的全局配置类。</p>
</li>
<li><p>在此类中，可以对Controller进行全局配置：异常处理方案、绑定数据方案、绑定参数方案。</p>
<ul>
<li><p><strong>@ExceptionHandler</strong>：用于修饰方法，该方法会在Controller出现异常后调用，用于处理捕获到的异常。</p>
</li>
<li><p><strong>@ModelAttribute</strong>：用于修饰方法，该方法会在Controller方法执行前被调用，用于为Model对象绑定参数。</p>
</li>
<li><p><strong>@DataBinder</strong>：用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器。</p>
</li>
</ul>
</li>
</ul>
<h1 id="统一记录日志"><a href="#统一记录日志" class="headerlink" title="统一记录日志"></a>统一记录日志</h1><p>AOP（Aspect Oriented Programing，面向方面（切面）编程），是对OOP的补充，可以进一步提高编程的效率。</p>
<p><img src="/images/JAVA%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/image-20200804231100773.png" alt="image-20200804231100773"></p>
<p>应用场景：多个模块共享权限检查，记录日志，事务管理等操作。</p>
<h2 id="AOP的实现"><a href="#AOP的实现" class="headerlink" title="AOP的实现"></a>AOP的实现</h2><p>AspectJ：一种新语言，扩展了Java，定义了AOP语法，在编译期织入代码。它有一个专门的编译器，用来生成遵守Java字节码规范的class文件。</p>
<p>Spring AOP：使用纯Java实现，在运行时通过代理方式织入代码，<strong>只支持方法类型</strong>的连接点，支持AspectJ的集成。</p>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p><strong>JDK动态代理：</strong>Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。（代理模式）</p>
<p><strong>CGLib动态代理：</strong>采用底层的字节码技术，在运行时创建子类代理实例。当目标对象不存在接口时，Spring AOP会采用这种方式，在子类实例中织入代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修饰一个类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="comment">// 修饰一个方法，括号内为切入点模式</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution (* com.djs.community.service.*.*(...))"</span>)</span><br><span class="line"><span class="comment">// 修饰一个方法，在切入点之前执行。</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="comment">// 修饰一个方法，在切入点之后执行。</span></span><br><span class="line"><span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="comment">// 修饰一个方法，在切入点返回之后执行。</span></span><br><span class="line"><span class="meta">@AfterReturning</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="comment">// 修饰一个方法，在抛出异常时执行。</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="comment">// 修饰一个方法，在目标方法前后执行。</span></span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis是一款基于键值对的NoSQL数据库，它的key是string，value支持多种数据结构：字符串（Strings），哈希（Hashes），列表（Lists），集合（Sets），有序集合（Sorted Sets）等。</p>
<p>Redis将所有数据都存放在内存中，读写速度快。同时，Redis还可以将内存中的数据以<strong>快照</strong>或者<strong>日志</strong>的形式保存在硬盘上，保证数据的安全。</p>
<p>应用场景：缓存、排行榜、计数器、社交网络、消息队列等。</p>
<p><code>keys *</code>：查看所有的key。</p>
<p><code>keys test*</code>：查看test开头的key。</p>
<p><code>type key</code>：查看某个key的类型。</p>
<p><code>exists key</code>：查看key是否存在。</p>
<p><code>expire key seconds</code>：设置key在seconds秒后自动删除。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>存：<code>set key value [EX seconds] [PX milliseconds] [NX|XX] </code></p>
<p>取：<code>get key</code></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>存：<code>hset key field value</code></p>
<p>取：<code>hget key field</code></p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>支持队列，栈模拟</p>
<p>从左存：<code>lpush key value [value ...]</code></p>
<p>从左按索引查看：<code>lindex key index</code></p>
<p>从左按索引范围查看：<code>lrange key start stop</code></p>
<p>从左弹出一个值：<code>lpop key</code></p>
<p>长度：<code>llen key</code></p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>存：<code>sadd key member [member ...]</code></p>
<p>统计元素个数：<code>scard key</code></p>
<p>随机弹出一个值：<code>spop key [count]</code></p>
<p>查看集合中元素：<code>smembers key</code></p>
<h2 id="Sorted-Sets"><a href="#Sorted-Sets" class="headerlink" title="Sorted Sets"></a>Sorted Sets</h2><p>按<code>score</code>排序</p>
<p>存：<code>zadd key [NX|XX] [CH] [INCR] score member [score member ...]</code></p>
<p>统计元素个数：<code>zcard key</code></p>
<p>查询某个元素的score：<code>zscore key member</code></p>
<p>查询某个元素的排序：<code>zrank key member</code></p>
<p>取排序范围的值：<code>zrange key start stop [WITHSCORES]</code></p>
<h1 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h1><p>异步点赞，点赞信息存在Redis。</p>
<ul>
<li><p><strong>key：</strong>“like:entity” + entityType + entityId</p>
</li>
<li><p><strong>value：</strong>set存放点赞的userId</p>
</li>
</ul>
<h1 id="收到的赞"><a href="#收到的赞" class="headerlink" title="收到的赞"></a>收到的赞</h1><p>事务管理：记录帖子的点赞数量同时记录该贴子的作者收到的赞。</p>
<ul>
<li><p><strong>key：</strong>“like:user” + userId</p>
</li>
<li><p><strong>value：</strong>string存放获得赞的数量</p>
</li>
</ul>
<h1 id="关注、取消关注"><a href="#关注、取消关注" class="headerlink" title="关注、取消关注"></a>关注、取消关注</h1><p>关注信息存在Redis。</p>
<p>异步（取消）关注，<strong>事务操作</strong>：更新user的关注信息，更新目标的粉丝信息。</p>
<h1 id="关注列表、粉丝列表"><a href="#关注列表、粉丝列表" class="headerlink" title="关注列表、粉丝列表"></a>关注列表、粉丝列表</h1><p>Redis查询。</p>
<h1 id="使用Redis优化登录模块"><a href="#使用Redis优化登录模块" class="headerlink" title="使用Redis优化登录模块"></a>使用Redis优化登录模块</h1><ul>
<li>使用Redis存储验证码（kaptcha）：需要频繁刷新和访问，只需要保存一段时间，避免分布式部署时的Session共享问题。</li>
<li>使用Redis存储登录凭证：每次处理请求时都需要查询用户的登录凭证，访问频率非常高。</li>
<li>使用Redis缓存用户信息：每次请求时都需要根据凭证查询用户。</li>
</ul>
<h1 id="Kafka构建TB级异步消息系统"><a href="#Kafka构建TB级异步消息系统" class="headerlink" title="Kafka构建TB级异步消息系统"></a>Kafka构建TB级异步消息系统</h1><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>BlockingQueue接口：解决线程通信问题。</p>
<p>生产者消费者模式：生产者——产生数据的线程，消费者——使用数据的线程。</p>
<p>实现类：ArrayBlockigQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue、DelayQueue等。</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Kafka是一个分布式的流媒体平台，应用：消息系统、日志收集、用户行为追踪、流式处理等。</p>
<p>特点：高吞吐量、消息持久性（顺序存在硬盘，硬盘的顺序读写速度高于内存的随机读写）、高可靠性（分布式）、高扩展性。</p>
<p>术语：</p>
<ul>
<li>Broker：Kafka的每台服务器叫Broker</li>
<li>Zookeeper：管理服务器集群</li>
<li>Topic：采用发布订阅模式，每条消息都要发送到指定的Topic上</li>
<li>Partition：Topic多个分区，提高并发执行能力</li>
<li>Offset：消息在Partition中的索引</li>
<li>Leader Replica：主副本可以处理请求</li>
<li>Follow Replica：随从副本是主副本的备份。</li>
</ul>
<p>启动Zookeeper：</p>
<ol>
<li>切换到Kafka安装目录<code>D:\kafka_2.12-2.5.0</code></li>
<li>输入命令<code>bin\windows\zookeeper-server-start.bat config\zookeeper.properties</code>启动Zookeeper。</li>
</ol>
<p>启动Kafka：</p>
<ol>
<li>切换到Kafka安装目录<code>D:\kafka_2.12-2.5.0</code></li>
<li>输入命令<code>bin\windows\kafka-server-start.bat config\server.properties</code>启动kafka。</li>
</ol>
<p>创建Topic：</p>
<ol>
<li>切换到目录<code>D:\kafka_2.12-2.5.0\bin\windows</code>。</li>
<li>输入命令<code>kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test1</code>创建一个名为test的topic。</li>
</ol>
<h2 id="Spring整合Kafka"><a href="#Spring整合Kafka" class="headerlink" title="Spring整合Kafka"></a>Spring整合Kafka</h2><p>引入依赖spring-kafka并配置kafka。</p>
<p>生产者：<code>kafkaTemplate.send(topic, data);</code></p>
<p>消费者：注解<code>@KafkaListener(topic = {&quot;test&quot;})</code>用于修饰监听名为test的topic里面的消息。</p>
<h1 id="发布系统通知"><a href="#发布系统通知" class="headerlink" title="发布系统通知"></a>发布系统通知</h1><p>评论、点赞、关注后，通过Kafka异步地在对应的topic发布通知。</p>
<h1 id="Elasticsearch（ES）"><a href="#Elasticsearch（ES）" class="headerlink" title="Elasticsearch（ES）"></a>Elasticsearch（ES）</h1><p>ES是一个分布式的、Restful风格的搜索引擎，支持对<strong>各种类型</strong>的数据检索，可以提供<strong>实时</strong>的搜索服务，便于水平扩展，每秒可处理PB级别的海量数据。</p>
<p>术语：</p>
<ul>
<li>索引、类型、文档、字段（对应MySQL中的数据库，表，行，列）</li>
<li>集群、结点、分片、副本</li>
</ul>
<p>安装配置：</p>
<ul>
<li><p>安装ES：支持分词搜索</p>
</li>
<li><p>安装分词插件<code>elasticsearch-analysis-ik-6.4.3</code></p>
</li>
<li><p>安装Postman（非必须）：便于向ES服务器发送HTTP请求</p>
</li>
</ul>
<h2 id="Spring整合ES"><a href="#Spring整合ES" class="headerlink" title="Spring整合ES"></a>Spring整合ES</h2><p>引入依赖spring-boot-starter-data-elasticsearch</p>
<h2 id="启动ES服务器"><a href="#启动ES服务器" class="headerlink" title="启动ES服务器"></a>启动ES服务器</h2><p>运行文件<code>D:\elasticsearch-6.4.3\bin\elasticsearch.bat</code>文件</p>
<h1 id="开发论坛搜索功能"><a href="#开发论坛搜索功能" class="headerlink" title="开发论坛搜索功能"></a>开发论坛搜索功能</h1><p>将帖子保存至ES服务器，从ES服务器搜索帖子。</p>
<p>发布帖子，增加评论时，发布事件，异步地将帖子提交到ES服务器（结合kafka）</p>
<h1 id="提高安全性——Spring-Security"><a href="#提高安全性——Spring-Security" class="headerlink" title="提高安全性——Spring Security"></a>提高安全性——Spring Security</h1><p>Spring Security是一个专注于为Java应用程序提供身份认证和授权的框架，强大之处在于轻松扩展以满足自定义需求。</p>
<p>特点：对身份认证和授权提供全面的、可扩展的支持；防止各种攻击如会话固定攻击、点击劫持、CSRF攻击等；支持与Servlet API、Spring MVC等Web技术集成。</p>
<p>DispatcherServlet是Spring MVC的核心组件，用于给Controller分发请求，分发过程中可以通过拦截器进行拦截。</p>
<h2 id="转发与重定向-1"><a href="#转发与重定向-1" class="headerlink" title="转发与重定向"></a>转发与重定向</h2><p>重定向：由浏览器自己再次访问另一个地址</p>
<p><img src="/images/JAVA%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/image-20200806182926304.png" alt="image-20200806182926304"></p>
<p>转发：服务器将请求转发给另一个地址，浏览器不知道</p>
<p><img src="/images/JAVA%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/image-20200806183038924.png" alt="image-20200806183038924"></p>
<h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p>其他网站盗取cookie里的凭证向服务器提交表单，cookie存在本地容易被获取。</p>
<p>Security解决方案：在表单里生成一个隐藏的TOKEN，其他网站无法获取，TOKEN不会存在本地，在网络上传递，相对安全。</p>
<p><img src="/images/JAVA%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/image-20200807211050480.png" alt="image-20200807211050480"></p>
<h1 id="置顶、加精、删除"><a href="#置顶、加精、删除" class="headerlink" title="置顶、加精、删除"></a>置顶、加精、删除</h1><p>置顶：需要版主权限，修改帖子的类型，需要触发发帖事件，在ES服务器中更新帖子</p>
<p>加精：需要版主权限，修改帖子的状态，需要触发发帖事件，在ES服务器中更新帖子</p>
<p>删除：需要管理员权限，修改帖子的状态，需要触发删帖事件，在ES服务器中删除帖子</p>
<p><code>thymeleaf-extras-springsecurity5</code>依赖包可以在前端结合Security判断用户权限</p>
<h1 id="Redis高级数据类型"><a href="#Redis高级数据类型" class="headerlink" title="Redis高级数据类型"></a>Redis高级数据类型</h1><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>采用一种基数算法，用于完成独立总数的统计。</p>
<p>占据空间小，无论统计多少个数据，只占12K的内存空间。</p>
<p>不精确的统计算法，标准误差为0.81%。</p>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>不是一种独立的数据结构，实际上就是字符串。</p>
<p>支持按位存取数据，可以将其看成是byte数组。</p>
<p>适合存储大量连续数据的布尔值（是否签到）。</p>
<h2 id="网站数据统计"><a href="#网站数据统计" class="headerlink" title="网站数据统计"></a>网站数据统计</h2><h2 id="UV（Unique-Visitor）"><a href="#UV（Unique-Visitor）" class="headerlink" title="UV（Unique Visitor）"></a>UV（Unique Visitor）</h2><p>使用HyperLogLog</p>
<p>独立访客，需通过用户IP（不论是否登录）去重来统计数据。</p>
<p>每次访问都要进行统计。</p>
<h2 id="DAU（Daily-Active-User）"><a href="#DAU（Daily-Active-User）" class="headerlink" title="DAU（Daily Active User）"></a>DAU（Daily Active User）</h2><p>使用Bitmap，以用户ID作为下标</p>
<p>日活跃用户，需通过用户ID去重来统计数据。</p>
<p>访问过一次，则认为其活跃。</p>
<h1 id="任务执行和调度"><a href="#任务执行和调度" class="headerlink" title="任务执行和调度"></a>任务执行和调度</h1><p>JDK线程池：ExecutorService、ScheduledExecutorService</p>
<p>Spring线程池：ThreadPoolTaskExecutor、ThreadPoolTaskScheduler</p>
<ul>
<li><code>@Async</code>注解让方法在多线程环境下，被异步调用。</li>
<li><code>@Scheduled(initialDelay = 10000, fixedRate = 1000)</code>注解让方法定时执行。</li>
</ul>
<p>分布式定时任务：Spring Quartz，数据存储在数据库中，分布式服务器可以共享</p>
<ul>
<li><p><code>Scheduler</code>核心调度接口。</p>
</li>
<li><p><code>Job</code>接口定义定时任务。</p>
</li>
<li><p><code>JobDetail</code>接口用于配置<code>Job</code>信息，参数会存在数据库的<code>qrtz_job_detai</code>表中。</p>
</li>
<li><p><code>Trigger</code>接口用于配置<code>Job</code>运行参数，参数会存在数据库的<code>qrtz_simple_trggers</code>和<code>qrtz_trggers</code>表中。</p>
</li>
</ul>
<h1 id="热贴排行"><a href="#热贴排行" class="headerlink" title="热贴排行"></a>热贴排行</h1><p>分数计算公式：<br>$$<br>log(精华分+评论分\times10+点赞数\times2+收藏数\times2)+(发布时间-网站建立时间)<br>$$<br>有分数变化操作时，将帖子id存入Redis，设置多线程定时任务计算分数，然后更新帖子分数同时更新ES服务器里面的数据。</p>
<h1 id="生成长图"><a href="#生成长图" class="headerlink" title="生成长图"></a>生成长图</h1><p>wkhtmltopdf：</p>
<ul>
<li><p>下载安装wkhtmltopdf，配置环境变量。</p>
</li>
<li><p>新建存储路径。</p>
</li>
<li><p>生成PDF：<code>wkhtmltopdf url 存储路径</code> </p>
<p>生成图片： <code>wkhtmltoimage [--quality 75] url 存储路径</code>，<code>--quality</code>压缩图像</p>
</li>
</ul>
<p><code>Runtime.getRuntime().exec(cmd)</code>执行cmd命令。</p>
<p>生成事件，通过Kafka监听器异步生成。</p>
<h1 id="优化网站性能"><a href="#优化网站性能" class="headerlink" title="优化网站性能"></a>优化网站性能</h1><p>本地缓存</p>
<ul>
<li>将数据缓存在应用服务器上，性能最好（空间小，无法跨服务器）</li>
<li>常用缓存工具：Ehcache、Guava、Caffeine</li>
</ul>
<p>分布式缓存</p>
<ul>
<li>将数据缓存在NoSQL上，<strong>跨服务器</strong></li>
<li>常用缓存工具：MemCache、Redis等</li>
</ul>
<p>多级缓存</p>
<ul>
<li>一级缓存（本地缓存）——二级缓存（分布式缓存）——DB</li>
<li>避免缓存雪崩（缓存失效，大量请求直达DB），提高系统可用性</li>
</ul>
<p>使用Caffeine缓存15条热贴</p>
<p>压力测试工具jmeter</p>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>Spring Boot Testing：Junit、Spring Test、AssertJ等</p>
<p>测试用例：保证测试方法的独立性</p>
<p>常用注解：</p>
<p>@BeforeClass：测试类运行时执行一次</p>
<p>@AfterClass：测试类结束时执行一次</p>
<p>@Before：每次调用类中测试方法时执行一次</p>
<p>@After：每次结束类中测试方法时执行一次</p>
<h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><p><img src="/images/JAVA%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/image-20200809185157317.png" alt="image-20200809185157317"></p>
<p><img src="/images/JAVA%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/image-20200809194854035.png" alt="image-20200809194854035"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>后台</tag>
      </tags>
  </entry>
  <entry>
    <title>面试知识点一：Java基础</title>
    <url>/2020/07/28/Java/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>记录Java学习过程中的一些笔记。</p>
<a id="more"></a>

<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="JRE与JDK"><a href="#JRE与JDK" class="headerlink" title="JRE与JDK"></a>JRE与JDK</h2><ul>
<li>JRE：Java运行时环境，可以运行已编译的Java程序，包括JVM、Java类库、Java命令等。</li>
<li>JDK：JDK包含JRE，能够创建和编译程序。</li>
</ul>
<h2 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h2><ul>
<li>封装：将对象的实现细节隐藏起来，通过公共的方法暴露对象的功能。</li>
<li>继承：继承使子类能够获取父类中的非private修饰的成员。</li>
<li>多态：程序中定义的引用变量的具体类型和通过该引用变量调用的方法在编程时是不确定的，而是在运行时才确定。继承，重写，向上转型。</li>
</ul>
<h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th></th>
<th>存储需求</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>整形</td>
<td>int</td>
<td>4字节</td>
<td></td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>2字节</td>
<td></td>
</tr>
<tr>
<td></td>
<td>long</td>
<td>8字节</td>
<td></td>
</tr>
<tr>
<td></td>
<td>byte</td>
<td>1字节</td>
<td></td>
</tr>
<tr>
<td>浮点类型</td>
<td>float</td>
<td>4字节</td>
<td>6-7位精度</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>8字节</td>
<td>15-16位精度</td>
</tr>
<tr>
<td>字符</td>
<td>char</td>
<td>2字节</td>
<td></td>
</tr>
<tr>
<td>布尔类型</td>
<td>boolean</td>
<td>4字节</td>
<td></td>
</tr>
</tbody></table>
<h2 id="String、StringBuilder与StringBuffer"><a href="#String、StringBuilder与StringBuffer" class="headerlink" title="String、StringBuilder与StringBuffer"></a>String、StringBuilder与StringBuffer</h2><ul>
<li>String：使用final修饰的char数组保存字符串，线程安全。</li>
<li>StringBuilder：没有使用final修饰，因此是可变的，线程不安全。</li>
<li>StringBuffer：与StringBuilder类似，但是使用了synchronized保证线程安全。</li>
</ul>
<h2 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h2><ol>
<li>抽象类里可以有非抽象方法，接口里不能有实现的方法（JDK 8开始可以有default 修饰的方法）。</li>
<li>抽象类可以使用protected、public、default修饰符，接口里只能且默认都是是public。</li>
<li>一个类只能继承一个抽象类，但是可以实现多个接口。</li>
<li>抽象类里可以有类变量，接口里只能有静态常量static或static修饰的变量，且必须被初始化。</li>
</ol>
<h2 id="x3D-x3D-与equals-区别"><a href="#x3D-x3D-与equals-区别" class="headerlink" title="&#x3D;&#x3D;与equals()区别"></a>&#x3D;&#x3D;与equals()区别</h2><ol>
<li>对于基本类型，&#x3D;&#x3D;是值比较；对于对象，&#x3D;&#x3D;是内存地址比较。</li>
<li>equals()默认实现就是&#x3D;&#x3D;，但是大多数类进行了重写，比如String、Interger等重写成了值比较。</li>
</ol>
<h2 id="为什么重写equals-时需要重写hashCode"><a href="#为什么重写equals-时需要重写hashCode" class="headerlink" title="为什么重写equals()时需要重写hashCode()"></a>为什么重写equals()时需要重写hashCode()</h2><p>这个问题有个前提是该类需要被存储到HashSet、HashMap等散列表中，否则不需要用到hashCode()。</p>
<ol>
<li><p>hashCode()默认返回值是根据对象的内存地址生成的一个整数，就算两个对象内容相同，也不会产生一样的hash值，因此需要重写。</p>
</li>
<li><p>虽然不同的对象产生的hash值一定不同，但是具有相同hash值相同的对象却不一定相同，因此需要重写equals()对对象的内容进行进一步判断。</p>
</li>
</ol>
<h2 id="使用多线程有什么优势"><a href="#使用多线程有什么优势" class="headerlink" title="使用多线程有什么优势"></a>使用多线程有什么优势</h2><ol>
<li>更有效地利用资源：当一个线程阻塞时，另一个线程可以执行其他事情。</li>
<li>更快地响应：单线程只能串行地处理一个请求，然后监听下一个请求。多线程虽然处理速度不一定会更快，但是可以快速地进行线程切换，短时间内响应多个请求。</li>
</ol>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><ol>
<li><p>static修饰的变量为类变量，可以通过类名调用，静态变量存放在方法区（不能修饰方法中的局部变量）。</p>
</li>
<li><p>static修饰的方法为类方法，可以通过类名调用，静态方法不能被重写。</p>
</li>
<li><p>static修饰的代码块为静态代码块，会在类加载时被执行。</p>
</li>
<li><p>static修饰的内部类为静态内部类，不能使用外部类的非静态成员变量和方法。</p>
</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ol>
<li>final修饰类变量时，初始化后不能发生变化，必须在声明时初始化或在构造函数中初始化。</li>
<li>final修饰方法中局部变量时，只能赋值一次，赋值后不能发生变化。</li>
<li>final修饰的方法无法被重写（private方法也会被隐式地指定为final方法）。</li>
<li>final修饰的类无法被继承。</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>Error：程序无法处理的错误，通常是JVM出现的问题。</li>
<li>Exception：程序本身能够处理的错误。</li>
</ul>
<p><img src="/images/Java%E5%9F%BA%E7%A1%80/image-20201012130111575.png" alt="image-20201012130111575"></p>
<h2 id="finally块不会执行的情况"><a href="#finally块不会执行的情况" class="headerlink" title="finally块不会执行的情况"></a>finally块不会执行的情况</h2><ul>
<li>finally语句块第一行发生了异常。</li>
<li>在前面的代码中执行<code>System.exit(int)</code>退出了程序。</li>
<li>程序所在的线程死亡。</li>
<li>关闭CPU。</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>在编译时，每个内部类会生成一个独立的class文件。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>static修饰内部类为静态内部类，可以通过<code>外部类名.静态内部类名</code>来创建。</p>
<p>只能访问外部类的<strong>静态</strong>方法和变量。</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类只能通过外部类的实例来创建。编译时，会将成员内部类单独编译成一个字节码文件，并添加一个外部类实例的final引用参数。</p>
<p>成员内部类类似于<strong>成员方法</strong>，不能有static修饰的成员或方法。可以访问外部类的<strong>所有</strong>变量和方法，外部类需要创建一个内部类实例才能访问内部类的属性和方法。</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类存在于方法中，只能在方法中访问该类，局部内部类中只能访问所在方法的final变量。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类必须实现一个接口或继承一个抽象类，且只能使用所在方法的final变量。</p>
<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="常用集合"><a href="#常用集合" class="headerlink" title="常用集合"></a>常用集合</h2><ul>
<li>Collection<ul>
<li>List：ArrayList、Vector、LinkedList</li>
<li>Set：HashSet、TreeSet、LinkedHashSet</li>
</ul>
</li>
<li>Map：HashMap、HashTable、LinkedHashMap、ConcurrentHashMap</li>
</ul>
<h2 id="ArrayList与LinkedList的区别"><a href="#ArrayList与LinkedList的区别" class="headerlink" title="ArrayList与LinkedList的区别"></a>ArrayList与LinkedList的区别</h2><ol>
<li>底层数据结构不同：ArrayList基于数组实现，LinkedList基于双向链表实现。</li>
<li>随机访问和删除效率不同：ArrayList能快速随机访问，LinkedList只能从头遍历；ArrayList删除元素后需要移动后面的元素，LinkedList能快速删除元素。</li>
<li>插入操作不同：ArrayList插入前，需要移动插入位置之后的元素；LinkedList插入时需要先遍历定位到元素。</li>
<li>内存空间占用不同：ArrayList是一次性分配一批空间，而LinkedList是在需要时分配空间，但是LinkedList一个元素需要消耗更多的空间。</li>
</ol>
<h2 id="ArrayList与Vector的区别"><a href="#ArrayList与Vector的区别" class="headerlink" title="ArrayList与Vector的区别"></a>ArrayList与Vector的区别</h2><ol>
<li>线程安全性：ArrayList线程不安全，Vector中主要方法使用synchronized关键字保证线程同步。</li>
<li>扩容因子不同，ArrayList在容量满时扩容为原来的1.5倍，Vector在容量满时扩容为原来的2倍。</li>
</ol>
<h2 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h2><ol>
<li>线程安全性：HashMap线程不安全，HashTable中主要方法使用synchronized关键字进行线程同步。</li>
<li>HashMap的key和value可以是null，HashTable的key和value不能为null。</li>
<li>初始容量和扩容：HashMap默认初始容量为16，每次扩容为原来的2倍。HashTable默认初始容量为11，每次扩容为原来的2倍+1。</li>
<li>底层数据结构：JDK 1.8以后的HashMap使用数组+链表&#x2F;红黑树结构，而Hashtable使用数组+链表结构。</li>
</ol>
<h2 id="ConcurrentHashMap与Hashtable的区别"><a href="#ConcurrentHashMap与Hashtable的区别" class="headerlink" title="ConcurrentHashMap与Hashtable的区别"></a>ConcurrentHashMap与Hashtable的区别</h2><p>ConcurrentHashMap是线程安全版HashMap，ConcurrentHashMap与HashTable的key和value不能为null。</p>
<ol>
<li>初始容量和扩容：HashMap默认初始容量为16，每次扩容为原来的2倍。HashTable默认初始容量为11，每次扩容为原来的2倍+1。</li>
<li>底层数据结构：JDK 1.8以后ConcurrentHashMap采用数组+链表&#x2F;红黑树结构，而Hashtable使用数组+链表结构。</li>
<li>实现线程安全的方式：<ul>
<li>ConcurrentHashMap：JDK1.8以前采用分段锁（Segment继承自ReentrantLock）；JDK 1.8及以后，锁的粒度更小，使用synchronized + CAS实现，数组被volatile关键字修饰，只对当前使用的链表头结点加锁。</li>
<li>Hashtable：使用synchronized整体加锁。</li>
</ul>
</li>
</ol>
<h2 id="Comparable与Comparator"><a href="#Comparable与Comparator" class="headerlink" title="Comparable与Comparator"></a>Comparable与Comparator</h2><p>实现java.lang.Comparable接口的类可以通过实现int compareTo(T o)进行两个类之间的比较。</p>
<p>实现java.util.Comparator接口的类为比较器类，需要实现int compare(T o1, T o2)，Arrays.sort()等方法可以通过传递一个比较器类实例来自定义比较规则。</p>
<h2 id="LinkedHashMap-与TreeMap"><a href="#LinkedHashMap-与TreeMap" class="headerlink" title="LinkedHashMap 与TreeMap"></a>LinkedHashMap 与TreeMap</h2><p>LinkedHashMap在HashMap的基础上使用一个双向循环链表记录顺序，根据元素的添加或访问顺序进行排序。</p>
<p> TreeMap基于红黑树实现，根据元素的 Key 进行排序，也可以自定义比较器。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h2><p>当前线程在执行完CPU时间片后切换到另一个线程前会先保存当前的运行状态，以便下次再切换回来。</p>
<h2 id="synchronized与ReentrantLock的区别"><a href="#synchronized与ReentrantLock的区别" class="headerlink" title="synchronized与ReentrantLock的区别"></a>synchronized与ReentrantLock的区别</h2><ol>
<li>底层实现不同<ul>
<li>synchronized依赖于jvm实现，synchronized关键字在编译后会在代码块前后生成monitorenter和monitorexit指令，并通过计数器记录重入次数。</li>
<li>ReentrantLock依赖于API实现，基于AQS实现，AQS的state字段用于记录重入次数，通过CAS操作更新state的值。</li>
</ul>
</li>
<li>ReentrantLock有一些特殊功能<ul>
<li>等待可中断：可以设置等待锁的超时时间。</li>
<li>公平锁：按顺序获取锁。</li>
<li>可绑定多个Condition：可以根据不同的Condition对线程进行分组，有选择性地进行线程通知；synchronized通常与wait()和notify()&#x2F;notifyAll()结合实现线程间的通知。</li>
</ul>
</li>
<li>synchronized在JDK 1.6及以后增加了许多优化，有偏向锁，轻量级锁和重量级锁三个级别。</li>
</ol>
<h2 id="synchronized与volatile的区别"><a href="#synchronized与volatile的区别" class="headerlink" title="synchronized与volatile的区别"></a>synchronized与volatile的区别</h2><ol>
<li>volatile只能修饰变量，而synchronized可以修饰方法和代码块。</li>
<li>多线程情况下volatile不会发生阻塞，而synchronized可能会发生阻塞。</li>
<li>volatile能保证可见性，但不能保证原子性；synchronized两者都能保证。</li>
<li>volatile解决变量在多个线程直接的可见性，而synchronized解决多个线程之间访问资源的同步性。</li>
</ol>
<h2 id="ThreadLocal内存泄漏问题"><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h2><p>ThreadLocalMap中使用的key为ThreadLocal的弱引用，当ThreadLocal没有被ThreadLocalMap以外的对象引用时，ThreadLocal就在下一次GC时被回收，而ThreadLocalMap的value是强引用，可能出现key被回收但value还存在的情况，但是value已经不可访问，造成内存泄漏。因此使用玩ThreadLocal后应该手动调用remove()方法。</p>
<h2 id="线程池执行execute-和submit-的区别"><a href="#线程池执行execute-和submit-的区别" class="headerlink" title="线程池执行execute()和submit()的区别"></a>线程池执行execute()和submit()的区别</h2><ol>
<li>execute()用于提交不需要返回值的任务，参数为Runnable对象。</li>
</ol>
<p><img src="/images/Java%E5%9F%BA%E7%A1%80/image-20200824195854215.png" alt="image-20200824195854215"></p>
<ol start="2">
<li>submit()用于提交需要返回值的任务，会返回一个Future对象，参数为Runnable对象，内部还是会调用execute()。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">	<span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;<span class="keyword">void</span>&gt; ftask = <span class="keyword">new</span> TaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="内存区域（JDK-1-8及以后）"><a href="#内存区域（JDK-1-8及以后）" class="headerlink" title="内存区域（JDK 1.8及以后）"></a>内存区域（JDK 1.8及以后）</h2><p><img src="/images/Java%E5%9F%BA%E7%A1%80/image-20200824201627280.png" alt="image-20200824201627280"></p>
<h2 id="为什么要将永久代（PermGen）替换为元空间（MetaSpace）"><a href="#为什么要将永久代（PermGen）替换为元空间（MetaSpace）" class="headerlink" title="为什么要将永久代（PermGen）替换为元空间（MetaSpace）"></a>为什么要将永久代（PermGen）替换为元空间（MetaSpace）</h2><p>永久代有一个JVM默认设置的固定大小，无法进行调整，而元空间使用的是直接内存，只受操作系统内存的限制。</p>
<h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p><img src="/images/Java%E5%9F%BA%E7%A1%80/image-20200824203844421.png" alt="image-20200824203844421"></p>
<ol>
<li>类加载检查：首先根据new指令的参数在常量池中查找该对象的符号引用，如果不存在则先执行类加载过程：加载、验证、准备、解析、初始化。</li>
<li>分配内存：根据对内存是否规整采用指针碰撞或空闲列表在堆中为新对象分配一块连续内存。</li>
<li>初始化默认值：将内存空间中的实例字段初始化为默认值。</li>
<li>设置对象头：在对象头中保存对象所属的类、哈希码、GC年龄等信息。</li>
<li>执行&lt;init&gt;()：在以上工作完成后，在虚拟机中已经生成了一个完整的新对象。但通常还需要调用构造函数进行初始化。</li>
</ol>
<h2 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h2><p>同时满足以下条件：</p>
<ol>
<li>该类的所有实例都已被回收。</li>
<li>加载该类的ClassLoader已被回收。</li>
<li>该类对应的java.lang.Class对象没有被引用。</li>
</ol>
<h2 id="什么时候会触发GC"><a href="#什么时候会触发GC" class="headerlink" title="什么时候会触发GC"></a>什么时候会触发GC</h2><ul>
<li>Eden区满的时候。</li>
<li>Young GC时，空间分配担保触发FullGC。</li>
<li>分配大对象，没有足够的连续空间。</li>
</ul>
<h1 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h1><p>需求分析，概要设计，详细设计，编码，测试，软件交付，验收，维护。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2020/08/09/Java/HashMap/</url>
    <content><![CDATA[<p>HashMap源码解读。</p>
<a id="more"></a>

<h1 id="put-方法存储过程（JDK8）"><a href="#put-方法存储过程（JDK8）" class="headerlink" title="put()方法存储过程（JDK8）"></a>put()方法存储过程（JDK8）</h1><ol>
<li><p>调用<code>put(key, value)</code>方法，若数组<code>Node&lt;K, V&gt;[] table</code>为空或table长度为0，则进行初始化<code>table = new Node&lt;K, V&gt;[16]</code>，即数组默认初始化容量为16。（惰性加载）</p>
</li>
<li><p>调用<code>hash()</code>方法计算key的<code>hash</code>值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> h;    </span><br><span class="line">    <span class="comment">// 使用hash值计算下标时，若n比较小，则hash的高16位无法参与运算</span></span><br><span class="line">    <span class="comment">// 为了减少哈希碰撞，需要使高16位也能参与下标计算</span></span><br><span class="line">    <span class="comment">// h ^ (h &gt;&gt;&gt; 16)相当于高16位不变，低16位变为低16位与高16位的异或结果</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结合<code>hash</code>值和容量<code>n</code>计算索引节点下标<code>index</code>，并获得索引结点<code>p</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index = (n - <span class="number">1</span>) &amp; hash</span><br><span class="line">p = table[index]</span><br></pre></td></tr></table></figure>
</li>
<li><p>若索引结点p为null，则创建新结点<code>p = newNode(hash, key, value, null)</code>存储插入数据。</p>
<p>否则从p开始遍历以p为头结点的链表（拉链法）：</p>
<ul>
<li>若链表中存在结点<code>e</code>使得<code>e.hash == hash &amp;&amp; (e.key == key || key.equals(e.key))</code>，则使用value更新e的value，即<code>e.value = value</code>。<strong>存储结束。</strong></li>
<li>否则在链表尾部创建一个新的结点存储插入数据。</li>
</ul>
</li>
<li><p>插入新数据后，map容量<code>size</code>自增1，若容量大于扩容阈值则调用<code>resize()</code>方法进行扩容。</p>
</li>
</ol>
<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>扩容阈值&#x3D;容量×加载因子(0.75)，因此扩容阈值默认初始值为16*0.75&#x3D;12。</p>
<p>扩容时，扩容阈值和容量为原来的两倍。</p>
<p>对于HashMap中的每个非根结点e，若<code>(e.hash &amp; oldCap) == 0</code>则扩容后的索引要么不变，若<code>(e.hash &amp; oldCap) == 1</code>要么为原索引+原容量。根节点重新计算索引<code>newIndex = (newCap - 1) &amp; hash</code>。oldCap和newCap为新旧桶的数量。</p>
<h1 id="红黑树与链表转换"><a href="#红黑树与链表转换" class="headerlink" title="红黑树与链表转换"></a>红黑树与链表转换</h1><ul>
<li>当某个链表长度（桶中结点数）大于8，且桶的数量大于64时，该<strong>链表转为红黑树</strong>。</li>
<li>当某个红黑树结点数小于等于6时，该<strong>红黑树转回链表</strong>。</li>
</ul>
<h2 id="为什么转换的阈值分别为8和6？"><a href="#为什么转换的阈值分别为8和6？" class="headerlink" title="为什么转换的阈值分别为8和6？"></a>为什么转换的阈值分别为8和6？</h2><p>红黑树的平均查找长度为log(n)，链表的平均查找长度为n。</p>
<p>当n为8时，<code>log(8) = 3 &lt; 8 / 2</code>，此时红黑树查找效率更高，空间换时间较划算。</p>
<p>当n为6时，<code>log(6) = 2.6 &lt; 6 / 2</code>，此时红黑树与链表查找效率相差不大，时间换空间较划算。</p>
<p>此外，源码中解释根据泊松分布，链表长度大于8的概率极小。</p>
<h2 id="为什么桶的数量要大于64"><a href="#为什么桶的数量要大于64" class="headerlink" title="为什么桶的数量要大于64"></a>为什么桶的数量要大于64</h2><p>源码中解释，如果存在链表结点数大于8且桶的数量小于等于64，说明桶中的结点过多，应调用<code>resize()</code>方法进行扩容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) &#123;</span><br><span class="line">    resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>避免扩容和树型化选择的冲突。</p>
<h1 id="指定初始化容量n必须为2的次幂"><a href="#指定初始化容量n必须为2的次幂" class="headerlink" title="指定初始化容量n必须为2的次幂"></a>指定初始化容量n必须为2的次幂</h1><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>为了减少hash碰撞，使数据均匀分配。</p>
<p>HashMap计算索引的方式为<code>index = (n - 1) &amp; hash</code>，当n为2的次幂时这种索引计算方式与取余的结果一致，即<code>(n - 1) &amp; hash == hash % n</code>。</p>
<p>n- 1的形式为若干个连续的0和若干个连续的1如<code>16 - 1 = 15 = 00000000 00000000 00000000 00001111</code>。</p>
<h2 id="若n不是2的次幂会怎么样？"><a href="#若n不是2的次幂会怎么样？" class="headerlink" title="若n不是2的次幂会怎么样？"></a>若n不是2的次幂会怎么样？</h2><p>会向上扩展为2的次幂，如n&#x3D;10变为16。</p>
<p>具体实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若不执行减一操作，输入cap刚好为2的次幂时，会将容量扩大为2*cap。</span></span><br><span class="line"><span class="keyword">int</span> n = n - <span class="number">1</span>;<span class="comment">// n = 10为例,此时n = 9</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;   <span class="comment">// 9 | 4 = 13</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;	<span class="comment">// 13 | 3 = 15</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;	<span class="comment">// 15 | 0 = 15</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>;	<span class="comment">// 15 | 0 = 15</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span>;	<span class="comment">// 15 | 0 = 15</span></span><br><span class="line"><span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>; <span class="comment">// n + 1 = 16</span></span><br></pre></td></tr></table></figure>

<h1 id="加载因子（loadFactor）"><a href="#加载因子（loadFactor）" class="headerlink" title="加载因子（loadFactor）"></a>加载因子（loadFactor）</h1><p>加载因子 &#x3D; 容量 &#x2F; 桶的数量，可以衡量HashMap的稀疏程度，官方设定为加载因子0.75时，HashMap足够拥挤了，需要进行扩容。</p>
<h1 id="初始容量设置"><a href="#初始容量设置" class="headerlink" title="初始容量设置"></a>初始容量设置</h1><p>若已知需要插入的数据个数为n，则应该设置<code>初始容量 = (n / 0.75) + 1</code>。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>后台</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习系列二：虚拟机执行子系统</title>
    <url>/2020/08/13/Java/JVM%E5%AD%A6%E4%B9%A02%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本文记录了《深入了解Java虚拟机：JVM高级特性与最佳实践》中第三部分“虚拟机执行子系统”的学习笔记。</p>
<a id="more"></a>

<h1 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h1><p>Class文件是一组以8个字节为单位的二进制流，任何一个Class文件都对应着唯一的一个类或接口的定义信息。</p>
<p>数据类型：</p>
<ul>
<li>无符号数：可以用来描述数字、索引引用、数量值或按UTF-8编码构成字符串值；u1，u2，u4，u8分别代表1、2、4、8个字节的无符号数。</li>
<li>表：由多个无符号数或者其他表作为数据项构成的复合数据类型。命名以“_info”结尾。</li>
</ul>
<p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200824215825527.png" alt="image-20200824215825527"></p>
<h2 id="魔数与版本号"><a href="#魔数与版本号" class="headerlink" title="魔数与版本号"></a>魔数与版本号</h2><ul>
<li><p>魔数（Magic Number）：Class文件的头四个字节，用于确定该文件是否为一个能被虚拟机接受的Class文件。</p>
</li>
<li><p>版本号：第5、6个字节是次版本号，第7、8个字节是主版本号（JDK12为57）。</p>
</li>
</ul>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>第9、10个字节表示常量池容量计数值，计数从1而不是0开始，后面紧跟一系列常量表。</p>
<p>常量池中主要存放两大类常量：</p>
<ul>
<li>字面量：如文本字符串、被声明为final的常量等。</li>
<li>符号引用：被模块导出或者开放的包、类和接口的全限定名、字段的名称和描述符、方法的名称和描述符、方法句柄和方法类型、动态调用点和动态常量。</li>
</ul>
<p>每一项常量都是一个表，共有17种常量表。</p>
<p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814120634525.png" alt="image-20200814120634525"></p>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>常量池结束之后，紧接着的2个字节代表访问标志。</p>
<p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814115542959.png" alt="image-20200814115542959"></p>
<h2 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h2><p>三者按顺序排在访问标志之后，类索引和父类索引都是u2类型的数据，接口索引集合是一组u2类型数据的集合，它们各指向常量池中一个类描述符常量。</p>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814123027347.png" alt="image-20200814123027347"></p>
<p>字段表用于描述接口或者类中声明的变量，不会列出从父类或父接口中继承而来的字段。首先是一个字段表计数器，后接若干个字段表。</p>
<p>数组类型描述符：每一维用一个的”[“来描述。如<code>java.lang.String[][]</code>被描述为<code>[[Ljava.lang.String</code>。</p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>字段表集合之后就是方法表集合，结构与字段表结构类似。首先是一个方法表计数器，后接若干个方法表。</p>
<p>方法描述符：先参数列表后返回值，如<code>int test(char[] a, int b)</code>被描述为<code>([CI)I</code>。</p>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814125020707.png" alt="image-20200814125020707"></p>
<p>方法里面的代码经过Javac编译器处理后，变为字节码指令存储在Code属性内。</p>
<p><strong>变量槽</strong>：变量槽是虚拟机为局部变量分配内存使用的最小单位。对于byte、char、float、int、short、boolean等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long占用两个变量槽。</p>
<h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><ul>
<li><p>Exception：列举方法描述时在throws关键字后面的异常。</p>
</li>
<li><p>LineNumberTable：用于描述Java源码行号与字节码行号（字节码的偏移量）之间对应的关系。</p>
</li>
<li><p>LocalVariable、LocalVariableTypeTable：LocalVariable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。LocalVariableTypeTable与LocalVariable类似，适用于泛型。</p>
</li>
<li><p>SourceFile、SourceDebugExtension：SourceFile用于记录生成这个Class文件的源码文件名称。SourceDebugExtension用于存储额外的代码调试信息。</p>
</li>
<li><p>ConstantValue：通知虚拟机自动变为静态变量赋值，只有被static关键字修饰的变量才可以使用这项属性。</p>
</li>
<li><p>InnerClasses：用于记录内部类与宿主类之间的关联。</p>
</li>
<li><p>Deprecated、Synthetic：Deprecated属性用于表示某个类、字段或方法已被程序作者定为不再推荐使用。Synthetic属性表示此字段或方法不是Java源码直接产生的，而是由编译器自行添加的。</p>
</li>
<li><p>StackMapTable：会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p>
</li>
<li><p>Signature：记录泛型前面信息。</p>
</li>
<li><p>BootstrapMethods：用于保存invokeddynamic指令引用的引导方法限定符。</p>
</li>
<li><p>MethodParameters：记录方法的各个形参名称和信息。</p>
</li>
<li><p>模块化相关属性：Module、ModulePackage、ModuleMainClass</p>
</li>
<li><p>运行时注解相关属性：RuntimeVisibleAnnotations、RuntimeInvisibleAnnotations、RuntimeVisibleAnnotations、RuntimeInvisibleParameterAnnotations、RuntimeVisibleParameterAnnotations、RuntimeInvisibleParameterAnnotations</p>
</li>
</ul>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程称为虚拟机的类加载机制。</p>
<p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814140338240.png" alt="image-20200814140338240"></p>
<p>一个类型从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期如图所示。</p>
<p>解析可能在初始化之后再开始，这是为了支持Java的动态绑定。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>有且只有六种情况需要立即对类进行到“初始化”阶段：</p>
<ul>
<li>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时。</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用时。</li>
<li>初始化类时发现其父类还没有初始化，则先触发其父类的初始化。</li>
<li>虚拟机启动时，初始化包含main()方法的主类。</li>
<li>使用JDK 7加入的动态语言支持时，需要初始化相应的类。</li>
<li>当一个接口中定义了JDK 8加入的default方法时，如果该接口的实现类发生了初始化，那么该接口要在其之前初始化。</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>加载、验证、准备、解析、初始化。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>非数组类型的加载阶段是开发人员可控性最强的阶段，可以使用虚拟机内置的引导类加载器也可以由用户自定义的类加载器完成。</p>
<p>虚拟机在加载阶段需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>加载阶段与连接阶段的部分动作是交叉进行的，如一部分字节码文件格式验证动作。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保Class文件的字节流包含的信息符合虚拟机要求，保证这些信息运行后不会危害虚拟机自身的安全。</p>
<p>包括四个阶段的验证动作：</p>
<ol>
<li>文件格式验证：验证字节流是否符合Class文件规范，能否被当前版本的虚拟机处理。</li>
<li>元数据验证：对字节码描述的信息进行语义分析，保证其描述的信息符合《Java语言规范》的要求。</li>
<li>字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：检查是否能够正常引用它依赖的某些外部类、方法、字段等，确保解析行为能正常执行。</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类中定义的静态变量分配内存并初始化为默认值，仅包括类变量，不包括实例变量。</p>
<p>实例变量会在对象实例化时随对象一起分配在Java堆中。</p>
<p>如果存在类字段被static final修饰，虚拟机会直接初始化为ConstantValue。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池内的符号引用解析为直接引用。</p>
<p>解析主要针对7类符号引用：类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</p>
<p>符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量。</p>
<p>直接引用：可以直接指向目标的指针、相对偏移量或者是能直接定位到目标的句柄。</p>
<p>类或接口的解析：根据类或接口的全限定名加载对应类或接口，然后验证访问权限。</p>
<p>字段解析：首先解析出字段所属的类或接口C，若C中包含匹配的字段则返回该字段的直接引用，否则依次搜索C实现的<strong>各个接口和父类</strong>，最后验证访问权限。</p>
<p>方法解析：首先解析出方法所属的类或接口C，若C中包含匹配的方法则返回该方法的直接引用，否则依次搜索C实现的<strong>父类和各个接口</strong>，最后验证访问权限。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行类构造器&lt;clinit&gt;()方法，&lt;clinit&gt;()方法是由编译器自动收集类中的<strong>类变量赋值语句和静态语句块</strong>合并产生的。</p>
<p>同一个类加载器下，一个类型只会被初始化一次。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器实现了<strong>加载</strong>过程中的“通过一个类的全限定名来获取定义此类的二进制字节流”这一动作。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，必须由加载它的类加载器和类本身（全限定名）共同确立在虚拟机中的唯一性。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><h4 id="JDK-9之前"><a href="#JDK-9之前" class="headerlink" title="JDK 9之前"></a>JDK 9之前</h4><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814171646877.png" alt="image-20200814171646877"></p>
<p>JDK 9之前的Java应用都是由启动类加载器、扩展类加载器、应用程序类加载器互相配合完成加载的，用户可以加入自定义的类加载器进行拓展。</p>
<p>双亲委派模型要求除了启动类加载器外，其余的类加载器都应有自己的父类加载器。父子关系不是以继承的关系实现的，而是使用组合关系来复用父类加载器的代码。</p>
<p>工作过程：当一个类加载器收到类加载的请求时，首先查看是否已加载过该类，若没有，则把这个请求委派给父加载器去完成，直到启动类加载器，若父加载器都没有加载过该类，当前类加载器才会尝试自己完成加载。</p>
<p>优点：保证稳定性，避免用户自己编写的类替换掉Java的一些核心类，同时也可以避免重复加载。</p>
<h4 id="JDK-9及之后"><a href="#JDK-9及之后" class="headerlink" title="JDK 9及之后"></a>JDK 9及之后</h4><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814173453876.png" alt="image-20200814173453876"></p>
<p>JDK 9中把Extension Class Loader替换为了Platform Class Loader。父类都发生了变化。</p>
<p>双亲委派模型：类加载请求会优先委派给负责待加载类所属模块的类加载器。</p>
<h1 id="字节码执行引擎"><a href="#字节码执行引擎" class="headerlink" title="字节码执行引擎"></a>字节码执行引擎</h1><p>以方法为基本单位执行Class文件中包含的字节码指令。</p>
<p>执行引擎执行Java代码时可以选择解释执行（通过解释器执行）或者编译执行（通过即时编译器产生本地代码执行）。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>虚拟机以方法作为最基本的执行单元，栈帧则是用于支持虚拟机进行方法调用和方法执行的数据结构。</p>
<p>栈帧存储了局部变量表、操作数栈、动态连接、方法返回地址等信息，一个栈帧需要分配多少内存在编译Java源码时就已经被分析计算出来了。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表以变量槽为最小单位存储方法参数、方法内部定义的局部变量。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>栈内每一个元素可以是任意Java数据类型，32位数据类型占用栈容量为1，64位数据类型占用栈容量为2。</p>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>为了支持方法调用过程中的动态连接，每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法退出之后，必须返回到最初方法被调用的位置，程序才能继续执行。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），不涉及方法内部运行过程。</p>
<h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>静态方法、私有方法、实例构造器、父类方法和被final修饰的方法这5种方法调用会在类加载的就把符号引用解析为该方法的直接引用，是一个静态的过程。</p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>静态分派：依赖静态类型来决定方法执行版本的分派动作称为静态分派，典型应用代表就是<strong>方法重载</strong>。静态分派发生在编译阶段，而不是虚拟机执行的。</p>
<p>动态分派：典型应用代表就是<strong>方法重写</strong>。</p>
<h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814182707365.png" alt="image-20200814182707365"></p>
<p>Javac编译器完成了程序源码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。而解释器则是在虚拟机内部实现的。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习系列一：内存管理</title>
    <url>/2020/08/11/Java/JVM%E5%AD%A6%E4%B9%A01%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>本文记录了《深入了解Java虚拟机：JVM高级特性与最佳实践》中第二部分“自动内存管理”的学习笔记。</p>
<a id="more"></a>

<h1 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h1><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0/image-20200811234856572.png" alt="image-20200811234856572"></p>
<ol>
<li><p><strong>程序计数器：</strong> <strong>线程私有</strong>，如果执行的是Java方法，可以看作是当前线程所执行的字节码的行号指示器；如果执行的是native方法，那么记录的值为空。是一块较小的内存空间，唯一一个没有规定任何OutOfMemoryError的区域。</p>
</li>
<li><p><strong>虚拟机栈：</strong> <strong>线程私有</strong>。每个Java方法被执行时，JVM会创建一个栈帧入栈，方法执行完毕时栈帧出栈。栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p>
</li>
<li><p><strong>本地方法栈：</strong> <strong>线程私有</strong>。与虚拟机栈的作用相似，区别在于虚拟机栈是为虚拟机执行Java方法服务的，而本地方法栈是为虚拟机使用到的本地（Native）方法服务。</p>
</li>
<li><p><strong>堆：</strong> <strong>线程共享</strong>。堆是虚拟机管理的内存中最大的一块，在虚拟机启动时创建，用于存放对象实例。是垃圾收集器管理的内存区域。逻辑上连续。</p>
</li>
<li><p><strong>方法区：</strong> <strong>线程共享</strong>。用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。又称为非堆。</p>
<ul>
<li><strong>运行时常量池：</strong>属于方法区的一部分。用于存放编译期生成的各种字面量与符号引用。</li>
</ul>
</li>
</ol>
<h2 id="对象的内存分配"><a href="#对象的内存分配" class="headerlink" title="对象的内存分配"></a>对象的内存分配</h2><p><strong>指针碰撞：</strong>使用<strong>Serial、ParNew等带整理过程的收集器</strong>时，堆中内存是规整的，所有被使用过的内存被放在一边，空闲的内存放在另一半，中间有一个指针作为分界点的指示器，为对象分配内存时只需要把指针向空闲方向移动一段与对象大小相等的区域。</p>
<p><strong>空闲列表：</strong>使用<strong>CMS这种基于清除算法的收集器</strong>时，堆中内存是不规整的，已被使用的和空闲的内存相互交错在一起，分配内存的时候从一个维护的列表中找到一块足够大的空间划分给对象实例。</p>
<p>并发情况下堆内存分配不是线程安全的，解决方法：</p>
<ul>
<li>对分配内存空间的动作进行同步——实际上虚拟机是采用CAS+失败重试的方式保证更新操作的原子性。</li>
<li>每个线程在堆中预先分配一小块内存（<strong>本地线程分配缓冲</strong>），只有本地缓冲区用完了，需要分配新的缓存区时才需要同步锁定。</li>
</ul>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>Java程序通过栈上的reference数据来操作堆上的具体对象：</p>
<p><strong>使用句柄：</strong>堆中划分出一块内存作为句柄池，reference数据中存储对象的句柄地址，句柄中存储对象实例与类型数据各自具体的地址信息。</p>
<p><img src="/images/JVM%E5%AD%A6%E4%B9%A01%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20200812084404106.png" alt="image-20200812084404106"></p>
<ul>
<li>优点：reference数据中存储稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而不影响reference本身。</li>
</ul>
<p><strong>直接指针：</strong>reference数据中直接存储对象地址。</p>
<p><img src="/images/JVM%E5%AD%A6%E4%B9%A01%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20200812084415956.png" alt="image-20200812084415956"></p>
<ul>
<li>优点：速度快，节省了一次指针定位的时间开销，HotSpot采用这种方法。</li>
</ul>
<h2 id="判断对象是否死去"><a href="#判断对象是否死去" class="headerlink" title="判断对象是否死去"></a>判断对象是否死去</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器加一，当引用失效时，计数器减一。计数器值为零的对象需要被回收。</p>
<p>缺点：很难解决对象之间相互循环引用的问题。</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>通过一系列称为“GC Roots”的根对象作为起始节点集，向下搜索过程所走过的路径称为“引用链”。如果某个对象到GC Roots间没有任何引用链相连，则此对象不可达。</p>
<p>固定可作为GC Roots的对象包括：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态变量引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
<li>JVM内部的引用。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映JVM内部情况的的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p><strong>强引用：</strong>指程序中普遍存在的引用赋值，只要强引用关系存在，被引用的对象就不会被回收。</p>
<p><strong>软引用：</strong>通过SoftReference类来实现，在系统将要发生内存溢出异常前，会把回收这些对象，如果回收之后内存还是不够，才会抛出内存溢出异常。</p>
<p><strong>弱引用：</strong>通过WeakReference类实现，只能生存到下一次垃圾收集发生为止。</p>
<p><strong>虚引用：</strong>通过PhantomReference类实现，虚引用不会影响对象的生存时间，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被回收时收到一个系统通知。</p>
<h3 id="两次标记"><a href="#两次标记" class="headerlink" title="两次标记"></a>两次标记</h3><p>在可达性分析算法中，宣告一个对象死亡至少要经历两次标记过程。</p>
<ol>
<li><p>如果对象没有与GC Roots相连的引用链，会被第一次标记。</p>
</li>
<li><p>如果对象没有覆盖finalize()方法或fianlize()方法已被调用过一次，那么该对象可以被回收。</p>
<p>否则，该对象会被放置在低优先级的F-Queue队列中等待执行finalize()方法，稍后收集器会对F-Queue中的对象进行第二次小规模标记：</p>
<ul>
<li>如果对象在finalize()方法中成功自救，那么该对象会被移出“即将回收”集合。</li>
<li>否则该对象可以被回收。</li>
</ul>
</li>
</ol>
<h3 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h3><p>回收内容主要包括：废弃的常量和不再使用的类。</p>
<p>回收废弃常量与回收堆中的对象类似。</p>
<p>不再使用的类需要同时满足三个条件：</p>
<ul>
<li>该类的所有实例都已被回收。</li>
<li>加载该类的类加载器已被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用。</li>
</ul>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭，内存分配和回收具有确定性。</p>
<p>堆和方法区则有明显的不确定性，内存分配和回收是动态的。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>从如何判定对象消亡的角度可将垃圾收集算法划分为“引用计数式垃圾收集”和“追踪式垃圾收集”两大类，也被称为“直接垃圾收集”和“间接垃圾收集器”。而主流JVM使用的算法都属于<strong>追踪式垃圾收集</strong>。</p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>弱分代假说：绝大多数对象都是朝生夕灭的。</p>
<p>强分代假说：熬过越多次垃圾回收过程的对象越难以消亡。</p>
<p>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</p>
<p><strong>部分收集（Partial GC）</strong>，指目标不是完整收集整个Java堆的垃圾收集，又分为：</p>
<ul>
<li>新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。</li>
<li>混合收集（Mixed GC）：指目标是整个新生代和部分老年代的垃圾收集。</li>
</ul>
<p><strong>整堆收集（Full GC）</strong>，收集整个Java堆和方法区的垃圾收集。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，然后统一回收掉所有被标记的对象。</p>
<p>会产生大量不连续的内存碎片。</p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当前使用区域内存用完时，标记出存活的对象并复制到另一个区域，然后把当前使用区域全部清理掉。</p>
<p>简单高效，不会产生内存碎片，但是会浪费空间，对象存活率高时，复制代价高。</p>
<p><strong>Appel式回收</strong>：将新生代分为一块较大的Eden区和两块较小的Survivor区，HotSpot默认比例大小为8:1:1。每次分配只使用Eden和其中一块Survivor，发生垃圾收集时，标记出Eden和Survivor中存活的对象并复制到另一块Survivor空间上，然后把已用空间全部清理掉。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>针对老年代的存亡特征，该算法在标记后将存活的对象移动在一起，然后将其他对象清理掉。</p>
<p>标记-整理算法通过移动对象来整理内存，对象移动操作需要暂停整个应用程序（Stop The World）。</p>
<p>标记-清楚算法不需要移动对象来整理内存，影响应用程序的吞吐量。</p>
<h2 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h2><p>目前，所有的收集器在根节点枚举时必须暂停用户线程。</p>
<p>HotSpot在类加载时就会把对象的引用信息记录在<strong>OopMap</strong>中，OopMap记录了方法执行时用到的本地变量到堆上变量的引用关系，这样就不需要一个不漏地从方法区等GC Roots开始查找。</p>
<h3 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h3><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>导致引用关系变化的指令非常多，不可能为每一条指令都生成对应的OopMap，于是HotSpot<strong>只是在安全点记录这些信息</strong>。</p>
<p>安全点位置：循环末尾、方法临返回前、方法调用之后、抛异常的位置。</p>
<p>使所有用户线程中断：</p>
<ul>
<li><p>抢占式中断：在GC发生时，首先中断所有用户线程，若某个线程未执行到安全点，则恢复线程使其执行到安全点。<strong>基本不用此方法。</strong></p>
</li>
<li><p>主动式中断：设置一个中断标志，各线程不断地主动轮询这个标志，中断标志为真时就在最近的安全点上主动中断挂起。</p>
</li>
</ul>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>用户线程处于Sleep或者Blocked状态时，无法响应虚拟机的中断请求，不能走到安全点去中断挂起自己。</p>
<p><strong>安全区域</strong>是指在代码片段中，引用关系不会发生变化，相当于是拉伸了的安全点。</p>
<p>在GC发生时，虚拟机不用去管处于安全区域的线程。线程要离开安全区域时，需要检查虚拟机是否已完成根节点枚举，如果完成了，就可以继续执行，否则需要等待收到可以离开安全区域的信号。</p>
<h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><h4 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h4><p>在进行Minor GC时，新生代中的对象有可能被老年代引用，需要在固定的GC Roots之外，再额外遍历整个老年代来寻找跨代引用，保证可达性分析的准确性。但这会给内存回收带来很大的性能负担。</p>
<p><strong>记忆集</strong>把老年代划分为若干个小块，标识出哪些块存在跨代引用，发生GC时只需要将存在跨代引用的块中的对象加入GC Roots进行扫描。</p>
<h4 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h4><p>记忆集分块的精度可以选择：</p>
<ul>
<li>字长精度：记录一个机器字长是否包含跨代指针。</li>
<li>对象精度：记录一个对象是否有字段包含跨代指针。</li>
<li>卡精度：记录一个内存区域是否有对象包含跨代指针。</li>
</ul>
<p><strong>卡表</strong>：采用卡精度实现的记忆集。卡表可以是一个字节数组，数组中每一个元素（1字节）对应着一个特定大小（512字节）的内存区域的起始地址，这个内存区域称为<strong>卡页</strong>。只要卡页内的一个或多个对象的字段存在跨代指针，此卡页<strong>变脏</strong>，该卡页对应卡表的数组元素的值为1。</p>
<h3 id="卡表维护——写屏障"><a href="#卡表维护——写屏障" class="headerlink" title="卡表维护——写屏障"></a>卡表维护——写屏障</h3><p>对于解释执行的字节码，虚拟机有充分的介入空间来维护卡表，但是对于即时编译后的机器指令流，虚拟机无法处理。</p>
<p>HotSpot虚拟机通过<strong>写屏障维护卡表</strong>，引用对象赋值时会产生一个环形通知供程序执行额外操作，即赋值的前后都在写屏障的范围内，可以在赋值后更新卡表状态。</p>
<p>卡表在高并发下的“<strong>伪共享</strong>”问题：CPU读取数据以缓存行为单位（64字节），而每个卡表元素只占1字节，当多个线程修改的卡表元素属于同一个缓存行时，就会彼此影响（写回、无效化或者同步）而导致性能降低。</p>
<ul>
<li>解决方法：更新卡表时，增加一个判断条件，只有当前卡表元素未变脏时才将其标记为变脏。</li>
</ul>
<h2 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h2><p>可达性分析理论上要求全过程都基于一个能保障一致性的快照中才能进行分析，这意味着必须全程冻结用户线程。</p>
<p>为什么可达性分析必须在一个能保障一致性的快照上才能保证正确性？</p>
<p>可达性分析遍历过程中根据“是否访问过”这个条件将对象标记为三种颜色（<strong>三色标记</strong>）：</p>
<ul>
<li>黑色：该对象已被访问过且该对象的所有引用已被扫描过。</li>
<li>灰色：该对象已被访问过但至少还有一个引用没有被扫描过。</li>
<li>白色：该对象未被访问过。可达性分析开始时全部都是白色，结束时仍是白色的对象不可达。</li>
</ul>
<p>若用户线程没有冻结，与收集器并发，有可能造成<strong>对象消失</strong>：将原本存活的对象标记为已消亡</p>
<p>对象消失需要以下两个条件同时满足：</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用。</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
<p>解决对象消失的方法：</p>
<ul>
<li><strong>增量更新</strong>：破坏第一个条件。当黑色对象插入新的指向白色对象的引用时，记录该引用，在扫描结束后，再以这些黑色对象为根重新扫描一次。</li>
<li><strong>原始快照</strong>：破坏第二个条件。当灰色对象要删除指向白色对象的引用关系时，记录被删除的引用，在扫描结束后，再以这些灰色对象为根重新扫描一次。</li>
</ul>
<p>对引用关系的记录都是通过<strong>写屏障</strong>实现的。</p>
<h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20200813162127059.png" alt="image-20200813162127059"></p>
<p>连线表示可以搭配使用，分为新生代和老年代收集器。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><strong>新生代</strong>收集器。单线程进行垃圾收集，需要暂停用户线程。采用<strong>标记-复制</strong>算法。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p><strong>老年代</strong>收集器。Serial收集器的老年代版本。单线程进行垃圾收集，需要暂停用户线程。采用<strong>标记-整理</strong>算法。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><strong>新生代</strong>收集器。多线程并行进行垃圾收集，需要暂停用户线程。采用<strong>标记-复制</strong>算法。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p><strong>新生代</strong>收集器。类似ParNew收集器，多线程并行进行垃圾收集，需要暂停用户线程。采用<strong>标记-复制</strong>算法。特点是可以通过调整新生代大小、Eden与Survivor比例控制<code>吞吐量=代码运行时间 / (代码运行时间+垃圾收集时间)</code>。</p>
<p>参数：</p>
<ul>
<li>MaxGCPauseMillis：控制最大GC停顿时间（通过降低新生代空间来降低停顿时间，吞吐量也会下降）。</li>
<li>GCTimeRatio：直接设置吞吐量大小。</li>
<li>UseAdaptiveSizePolicy：虚拟机会根据当前运行情况动态调整新生代大小、Eden与Survivor比例等参数，以提供最合适的停顿时间或最大的吞吐量。</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p><strong>老年代</strong>收集器。Parallel Scavenge收集器的老年代版本，多线程并行进行垃圾收集，需要暂停用户线程。采用<strong>标记-整理</strong>算法。</p>
<h3 id="CMS（Concurrent-Mark-Sweep）收集器"><a href="#CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Concurrent Mark Sweep）收集器"></a>CMS（Concurrent Mark Sweep）收集器</h3><p><strong>老年代</strong>收集器。采用<strong>标记-清除</strong>算法实现。</p>
<p>收集过程：</p>
<ol>
<li>初始标记：标记GC Roots能直接关联到的对象，速度很快，<strong>需要停顿</strong>。</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历，耗时长，<strong>并发执行</strong>。</li>
<li>重新标记：修正并发标记期间的<strong>增量更新</strong>，比初始标记耗时长，<strong>需要停顿</strong>。</li>
<li>并发清除：清理死亡对象，<strong>并发执行</strong>。</li>
</ol>
<p>优点：并发收集、低停顿。</p>
<p>缺点：</p>
<ul>
<li>并发执行也会占用CPU资源，导致用户线程吞吐量降低（变慢）。</li>
<li>无法处理<strong>浮动垃圾</strong>。CMS并发标记和清除时，用户线程还会产生新的垃圾对象，只能等下一次GC再清理。</li>
<li>需要预留足够的内存空间给用户线程使用，要是垃圾收集期间预留的内存无法满足程序分配新对象的需求，就会出现“<strong>并发失败</strong>”。这时JVM只能冻结用户线程，临时启用Serial Old收集器来对老年代进行垃圾收集。可以设置触发CMS的百分比，</li>
<li>标记-清除算法会<strong>产生内存碎片</strong>。可以设置为标记-整理算法，但是内存整理时无法并发。可以设置在若干次不整理空间的Full GC后，下一次Full GC前先进行碎片整理。</li>
</ul>
<h3 id="G1（Garbage-First）收集器"><a href="#G1（Garbage-First）收集器" class="headerlink" title="G1（Garbage First）收集器"></a>G1（Garbage First）收集器</h3><p>整堆收集器，基于区域收集。采用<strong>标记-整理</strong>算法实现。</p>
<p><strong>基于区域收集</strong>：G1将堆内存划分为若干个大小相等的独立区域（Region），Humongous是一种特殊的区域，专门用来存储大对象，通常被看着老年代的一部分。新生代和老年代是一系列区域（不一定连续）的动态集合。</p>
<p><strong>可预测的停顿时间</strong>：将区域最作为单次回收的最小单元，G1会跟踪各个区域里面垃圾的“价值”，即回收获得的空间与耗时的经验值，然后每次根据用户设定允许的停顿时间优先处理价值最大的那些区域。</p>
<p>收集过程：</p>
<ol>
<li>初始标记：标记与GC Roots直接相连的对象，并在区域中划分一部分用于并发回收过程的新对象分配，<strong>需要停顿</strong>。</li>
<li>并发标记：从GC Roots开始对堆中对象进行可达性分析，<strong>并发执行</strong>。</li>
<li>最终标记：处理并发标记期间<strong>原始快照</strong>记录，<strong>需要停顿</strong>。</li>
<li>筛选回收：更新各个区域的统计数据，根据用户期望的停顿时间制定回收计划。把决定回收的区域的存活对象复制到空的区域中，然后清理掉这些区域，<strong>需要停顿</strong>。</li>
</ol>
<p>细节问题：</p>
<ul>
<li>跨Region引用对象：记忆集，更复杂的<strong>卡表</strong>，占用内存较大（20%）。</li>
<li>并发标记时保证收集线程与用户现场互不干扰：<strong>原始快照</strong>，需要学前屏障来跟着并发时的指针变化情况，写屏障消耗较大。此外G1把区域中一部分划分出来用于并发回收过程的新对象分配，默认为存活的。也会出现CMS的“<strong>并发失败</strong>”情况。</li>
<li>以<strong>衰减均值</strong>为理论基础实现停顿预测。</li>
</ul>
<h2 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h2><p>衡量垃圾收集器的重要指标：内存占用（Footprint）、吞吐量（Throughout）、延迟（Latency）。</p>
<h3 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h3><p>Oracle拒绝在Oracle JDK12中支持Shenandoah收集器，只能在OpenJDK中使用。</p>
<p>基于区域收集，不设分代，采用区域间的<strong>连接矩阵代替记忆集</strong>记录区域之间的引用关系。使用了<strong>读屏障</strong>、<strong>指针转发</strong>等技术实现可并发的标记整理算法。</p>
<p>收集过程：</p>
<ol>
<li>初始标记：标记与GC Roots直接相连的对象，并在区域中划分一部分用于并发回收过程的新对象分配，需要停顿。</li>
<li>并发标记：标记出可达对象，并发执行。</li>
<li>最终标记：处理并发标记期间的原始快照记录，需要停顿。</li>
<li>并发清理：清理没有存活对象的区域，并发执行。</li>
<li>并发回收：把回收区域里的存活对象复制到空的区域。通过<strong>读屏障</strong>和<strong>转发指针</strong>解决并发回收期间用户线程继续读写被移动对象的问题，并发执行。</li>
<li>初始引用更新：建林一个线程集合点，确保所有并发回收阶段进行的收集器线程已经完成对象移动任务，需要停顿。</li>
<li>并发引用更新：按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值，并发执行。</li>
<li>最终引用更新：修正存在于GC Roots中的引用，需要停顿。</li>
<li>并发清理：再次清理掉回收集中所有的区域。</li>
</ol>
<p>细节问题：</p>
<ul>
<li><p><strong>转发指针</strong>：在每一个对象头的最前面增加一个新的引用字段，初始指向对象自己。当对象有了一个新的副本时，只需要修改旧对象上转发指针的引用位置指向新对象即可。</p>
</li>
<li><p>如果发生并发写入，必须保证写操作发生在新复制的对象上而不是旧对象。收集器线程或者用户现场只有其中一个可以对对象进行修改，使用比较并转换（Compare And Swap，<strong>CAS</strong>）来保证并发时对象访问的准确性。</p>
</li>
<li><p>使用<strong>读屏障</strong>来通知虚拟机有读操作，需要进行指针转发。</p>
</li>
</ul>
<h3 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h3><p>基于区域收集，不设分代。使用了<strong>读屏障</strong>、<strong>染色指针</strong>和<strong>内存多重映射</strong>等技术实现可并发的标记-整理算法。</p>
<p>ZGC的区域分为三种：</p>
<ul>
<li>小型区域：容量为2MB，用于存放小于256KB的小对象。</li>
<li>中型区域：容量为32MB，用于存放256到4MB的对象。</li>
<li>大型区域：容量不固定，但必须为2MB的整数倍，用于存放4MB及以上的大对象，不会被重分配。</li>
</ul>
<p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20200813194055382.png" alt="image-20200813194055382"></p>
<p><strong>染色指针</strong>：Linux下64位指针的高18位不能用了寻址，但剩余的46位指针能够充分满足大型服务器的需求，ZGC将其高4位用于存储4个标志信息——三色标记状态、是否被移动过、是否只能通过finalize()方法才能访问。ZGC能够管理的内存不可以超过4TB（2的42次方）。</p>
<p>染色指针优势：</p>
<ul>
<li>某个区域的存活对象被移走后，这个区域可以立即被释放和重用，不必等待所有指向该区域的引用都被修正。</li>
<li>可以大幅减少GC过程中内存屏障的使用数量。</li>
<li>染色指针可以作为一种可扩展的存储结构用于记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li>
</ul>
<p>收集过程：</p>
<ul>
<li><p>初始标记：需要停顿。</p>
</li>
<li><p>并发标记：遍历对象图进行可达性分析，更新染色指针中Marked 0、Marked 1标志位。</p>
</li>
<li><p>并发预备重分配：统计出需要清理的区域组成重分配集。</p>
</li>
<li><p>并发重分配：把重分配集中的存活对象复制到新的区域中，并为重分配集中的每个区域维护一个转发表，记录旧对象到新对象的转发关系。ZGC进从引用上就能确定一个对象是否处于重分配集之中，如果用户线程此时访问了位于重分配集中的对象，这次访问会被内存屏障截获然后根据转发表将访问转发到新复制的对象上面，并修正更新该引用的值。</p>
</li>
<li><p>并发重映射：修正整个堆中指向重分配集中旧对象的所有引用。</p>
</li>
</ul>
<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><h2 id="优先在Eden分配"><a href="#优先在Eden分配" class="headerlink" title="优先在Eden分配"></a>优先在Eden分配</h2><p>当Eden区没有足够空间进行分配时，将发起一次Minor GC。</p>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>大对象指需要大量连续内存空间的Java对象，内存还有不少空间但是缺乏连续空间时，会提前触发GC，而对大对象的复制（新生代主要采用标记-复制算法）也会产生极大开销。</p>
<h2 id="长期存活对象进入老年代"><a href="#长期存活对象进入老年代" class="headerlink" title="长期存活对象进入老年代"></a>长期存活对象进入老年代</h2><p>对于通常在Eden中诞生，如果经过一次Minor GC仍然存活且能被Survivor容纳，则该对象被移动到Survivor空间中，并且该对象年龄设为1岁。对象在Survivor中没熬过一次Minor GC，年龄就增加1，当年龄达到一定程度（15）时就会被晋升到老年代中。</p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>如果在Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，大于或等于该年龄的对象可以直接进入老年代。</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>当出现大量对象在Minor GC后仍然存活的情况时，需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代。</p>
<p>在Minor GC前，虚拟机必须先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果满足，则进行Minor GC，否则继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则尝试一次Minor GC，如果小于则进行一次Full GC。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java项目设计</title>
    <url>/2020/08/29/Java/Java%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>记录常问的项目设计思路。</p>
<a id="more"></a>

<h1 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h1><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><ul>
<li>高并发：时间极短，瞬间用户量大。</li>
<li>超卖：实际下单数量超出了限购的数量。</li>
<li>恶意请求：</li>
<li>链接暴露：</li>
<li>数据库：</li>
</ul>
<h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><p><img src="/images/Java%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1/v2-8aade443815c569af8599b0683e04b69_r.jpg" alt="preview"></p>
<ul>
<li>服务单一职责：单独建立秒杀数据库。</li>
<li>秒杀链接加盐：url动态化，通过MD5等加密算法加密随机的字符串做url。</li>
<li>Redis集群：主从同步、读写分离、哨兵。</li>
<li>Nginx：负载均衡。</li>
<li>资源静态化</li>
<li>限流<ul>
<li>前端限流：点击一次后置灰一定时间防止连续点击。</li>
<li>后端限流：只有秒杀成功的用户进行后续订单生成和支付等操作。</li>
</ul>
</li>
<li>库存预热：提前把商品的库存加载到Redis中，让整个流程都在Redis中进行，秒杀结束后再写回数据库。分布式锁。</li>
<li>限流、降级、熔断、隔离：</li>
<li>削峰填谷：消息队列。</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后台开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java项目问题</title>
    <url>/2020/08/29/Java/Java%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Java项目问题。</p>
<a id="more"></a>

<h1 id="论坛后台"><a href="#论坛后台" class="headerlink" title="论坛后台"></a>论坛后台</h1><h2 id="基于拦截器检查登录状态和权限"><a href="#基于拦截器检查登录状态和权限" class="headerlink" title="基于拦截器检查登录状态和权限"></a>基于拦截器检查登录状态和权限</h2><p><img src="/images/Java%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/image-20200902164036093.png" alt="image-20200902164036093"></p>
<p>对于一些需要登录才能访问或者需要一定权限的路径如个人信息，需要使用拦截器检查登录状态。</p>
<p>在用户浏览网页时，需要检查用户登陆状态，通过拦截器实现：</p>
<ol>
<li><p>实现HandlerInterceptor接口中的三个方法：</p>
<ul>
<li><p>preHandler()：在Controller之前执行。获取Cookie中的凭证id，然后在数据库中查询凭证有效状态并根据凭证获取到User对象并保存到ThreadLocal变量hostHolder中。</p>
</li>
<li><p>postHandler()：在Controller之后，模板引擎之前执行。从hostHolder获取到User并传给模板引擎。</p>
</li>
<li><p>afterCompletion()：在模板引擎之后执行。清除hostHolder。</p>
</li>
</ul>
</li>
<li><p>在实现WebMvcConfigurer接口的类中addInterceptors()配置拦截器：拦截哪些路径，不拦截哪些路径。</p>
</li>
</ol>
<h2 id="基于Kafka实现消息队列"><a href="#基于Kafka实现消息队列" class="headerlink" title="基于Kafka实现消息队列"></a>基于Kafka实现消息队列</h2><p>私信通知，评论点赞通知等。</p>
<h3 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h3><ol>
<li>不使用消息队列时，用户的请求会直接到达服务器并通过数据库或者缓存响应，而在高并发情况下，可能会超过数据库的承受能力，造成响应速度缓慢甚至宕机。而使用消息队列后，用户的请求数据存入消息队列后就可以立即返回，<strong>减少了响应时间</strong>，消息队列的消费者进程可以异步地处理消息队列中的消息，<strong>降低数据库在高峰期的压力</strong>。</li>
<li>使用消息队列还可以<strong>降低系统的耦合性</strong>，生产者和消费者之间不需要直接通信，而是通过共享消息队列进行交互。</li>
</ol>
<h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><h2 id="网站数据统计"><a href="#网站数据统计" class="headerlink" title="网站数据统计"></a>网站数据统计</h2><h3 id="UV（Unique-Visitor）"><a href="#UV（Unique-Visitor）" class="headerlink" title="UV（Unique Visitor）"></a>UV（Unique Visitor）</h3><p>统计不重复IP的访问次数。</p>
<h3 id="DAU（Daily-Active-User）"><a href="#DAU（Daily-Active-User）" class="headerlink" title="DAU（Daily Active User）"></a>DAU（Daily Active User）</h3><p>日活跃用户，使用Bitmap，以用户ID作为下标。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>后台开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/2020/09/26/%E6%9E%B6%E6%9E%84/Kafka/</url>
    <content><![CDATA[<p>Kafka相关知识点，主要参考《Apache Kafka实战》一书。</p>
<a id="more"></a>

<h1 id="消息队列模型与发布订阅模型"><a href="#消息队列模型与发布订阅模型" class="headerlink" title="消息队列模型与发布订阅模型"></a>消息队列模型与发布订阅模型</h1><ul>
<li><strong>消息队列：</strong>基于队列提供消息传输服务，点对点（p2p）的消息传递方式，也就是说一旦消息被一个消费者消费，就会从消息队列中移除该消息。</li>
<li><strong>发布&#x2F;订阅：</strong>有主题（topic）的概念，订阅了同一个topic的所有订阅者都能接受到该topic下的所有消息。</li>
</ul>
<h1 id="Kafka如何做到高吞吐量、低延时？"><a href="#Kafka如何做到高吞吐量、低延时？" class="headerlink" title="Kafka如何做到高吞吐量、低延时？"></a>Kafka如何做到高吞吐量、低延时？</h1><ul>
<li>大量使用操作系统<strong>页缓存</strong>，内存操作速度快且命中率高。</li>
<li>采用追加写入消息的方式，利用<strong>磁盘顺序读写</strong>的进行快速写入。</li>
<li>使用以sendfile为代表的<strong>零拷贝</strong>技术加强网络间的数据传输效率。</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习系列三：高效并发</title>
    <url>/2020/08/14/Java/JVM%E5%AD%A6%E4%B9%A03%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>本文记录了《深入了解Java虚拟机：JVM高级特性与最佳实践》中第五部分“高效并发”的学习笔记。</p>
<a id="more"></a>

<p>前端编译器：把*.java文件转变为*.class文件的过程。如JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）。</p>
<p>即时编译器：Java虚拟器运行期把字节码转变为本地机器码的过程。如HotSpot的C1、C2编译器，Graal编译器。</p>
<p>提前编译器：直接把源代码编译成目标机器指令集相关的二进制代码的过程。JDK的Jaotc、Excelsior JET。</p>
<p>HotSpot内置了两个（或三个）即时编译器，分别是客户端编译器（C1）和服务端编译器（C2）（Graal是JDK 10出现的即时编译器）。</p>
<p>热点探测：基于采样、基于计数器。</p>
<h1 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h1><p>在计算机中，增加高速缓存可以解决处理器与内存读写速度之间的矛盾，此外处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果一致。</p>
<p>Java虚拟机的即时编译器中也有<strong>指令重排序</strong>优化。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。</p>
<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/image-20200815225312598.png" alt="image-20200815225312598"></p>
<p>Java内存模型规定了所有变量都存储在<strong>主内存</strong>中，每条线程还有自己的工作内存（类比计算机中的高速缓存）。</p>
<p>线程的<strong>工作内存</strong>中保存了该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。</p>
<p>主内存主要对应Java堆中的对象实例数据部分。</p>
<p>工作内存主要对应于虚拟机栈中的部分区域。</p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>主内存与工作内存知己交互主要通过8种操作来完成：</p>
<ol>
<li>lock：作用于主内存变量，把一个变量标识为一条线程独占的状态。</li>
<li>unlock：作用于主内存变量，释放一个lock状态的变量。</li>
<li>read：作用于主内存变量，把一个变量的值从主内存传输到工作内存中。</li>
<li>load：作用于工作内存变量，把read操作得到的变量放入工作内存的变量副本中。</li>
<li>use：作用于工作内存变量，把工作内存中一个变量的值传递给执行引擎。</li>
<li>assign：作用于工作内存变量，把一个从执行引擎接收的值赋给工作内存的变量。</li>
<li>store：作用于工作内存变量，把工作内存中一个变量的值传送到主内存中。</li>
<li>write：作用于主内存变量，把store操作得到的变量放入主内存变量中。</li>
</ol>
<h3 id="volatile型变量"><a href="#volatile型变量" class="headerlink" title="volatile型变量"></a>volatile型变量</h3><p>当一个变量被volatile关键字修饰时，具有两个特性：</p>
<ol>
<li>此变量对所有线程可见，即当一个线程修改了变量的值，新值对于其他线程来说是可以立即得知的。</li>
<li>禁止指令重排序优化。</li>
</ol>
<p>volatile修饰的变量赋值后会多执行一个<code>lock add1 $0x0,(%esp)</code>操作，这个操作相对于一个内存屏障，不能把内存屏障后面的指令重排序到内存屏障之前的位置。</p>
<p>lock可以将本处理器的缓存写入内存，该写入操作也会引起别的处理器或别的内核无效化其缓存，相当于对缓存中的变量做了一次“store和write”操作。</p>
<h3 id="long和double的非原子性协定"><a href="#long和double的非原子性协定" class="headerlink" title="long和double的非原子性协定"></a>long和double的非原子性协定</h3><p>Java内存模型要求8中操作都具有原子性，但是允许虚拟机将没有被volatile修饰的64位的long和double数据的读写操作划分为两次32位的操作来进行。</p>
<h3 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h3><p>在Java内存模型中，基本数据类型的访问、读写都是具备原子性的。</p>
<p>volatile、synchronized、final关键字都能实现可见性。</p>
<p>volatile、synchronized关键字能保证线程之间操作的有序性。</p>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>使用内核线程实现（1:1），使用用户线程实现（1:N），使用用户线程加轻量级进程混合实现（N:M）。</p>
<p>Java线程的实现：主流Java虚拟机的线程模型普遍基于操作系统原生线程模型来实现，即采用1:1的线程模型。</p>
<h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>协同式线程调度：线程的执行时间由线程本身控制，线程把自己的工作执行完成之后，要主动通知系统切换到另一个线程上去。</p>
<p>抢占式线程调度：由系统来分配执行时间。<strong>Java使用这种调度方式</strong>。</p>
<p>主流虚拟机的Java线程是被映射到系统的原生线程上实现的，所以线程调度最终还是由操作系统控制。</p>
<h3 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h3><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/image-20200814235021618.png" alt="image-20200814235021618"></p>
<p>Java定义了6中线程状态，一个线程在一个时间点只能处于一个状态：</p>
<ol>
<li><strong>新建（New）</strong>：线程创建后尚未启动。</li>
<li><strong>运行（Runnable）</strong>：包括操作系统线程状态中的Running和Ready，也就是可能正在执行，也可能在等待分配执行时间。</li>
<li><strong>无限期等待（Waiting）</strong>：无参数的wait()，join()等方法会进入该状态，需要等待其他线程唤醒。</li>
<li><strong>限期等待（Timed Waiting）</strong>：带参数的sleep()，wait()，join()等方法会进入该状态，一定时间后会被系统自动唤醒。</li>
<li><strong>阻塞（Blocked）</strong>：在程序进入同步区域的时候，线程将进入这个状态。</li>
<li><strong>结束（Terminated）</strong>：线程已经结束执行。</li>
</ol>
<h1 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>当多个线程同时访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他操作的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p>
<h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p><strong>同步</strong>是指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条（或是一些，当使用信号量的时候）线程使用。</p>
<p><strong>互斥</strong>是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。</p>
<p>互斥是因，同步是果；互斥是方法，同步是目的。</p>
<p><strong>synchronized</strong>：经过Javac编译之后，在同步块的前后分别形成monitorenter和monitorexit两个字节码指令，执行monitorenter指令时会将锁计数器的值加一，执行monitorexit指令时会将锁的计数器的值减一。</p>
<ul>
<li>可重入：被synchronized修饰的同步块对同一条线程来说是可重入的。</li>
<li>重量级锁：无法强制已获取所得线程释放锁，也无法强制正在等待锁的线程中断等待或超时退出。</li>
</ul>
<p><strong>ReentrantLock</strong>：与synchronized相似，也是可重入，多了一些高级功能，如等待可中断、可实现公平锁、锁可以绑定多个条件。</p>
<ul>
<li>等待可中断：持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，处理其他事情。</li>
<li>公平锁：多个线程等待同一个线程时，按照申请锁的时间顺序来依次获取锁，性能会下降。</li>
<li>锁绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象。</li>
</ul>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p><strong>互斥同步的主要问题是进行线程阻塞和唤醒带来的性能开销</strong>，因此互斥同步也被称为阻塞同步。</p>
<p>非阻塞同步：基于冲突检测的乐观并发策略（乐观锁），即在执行操作后若与其他线程产生了冲突，再进行其他补偿操作，如不断重试直到没有冲突。</p>
<p>非阻塞同步必须要求操作和冲突检测这两个步骤具有原子性，可以只通过一条处理指令完成，如<strong>比较并交换（Compare-and-Swap，CAS）</strong>。</p>
<p>在IA64、x86指令集中用cmpxchg指令完成CAS功能。</p>
<p><strong>CAS</strong>需要三个操作数，分别是内存地址V、旧的预期值A和准备设置的新值B。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则不执行更新。但是不管是否更新了V的值，都会返回V的旧值。原子操作。</p>
<p><strong>ABA问题</strong>：如果一个变量V初次读取的是A值，但是在赋值检查之前，有可能被修改为B值，然后又被改回A值，此时CAS操作会误认为它从来没有改变过。可以增加<strong>版本号</strong>来保证CAS的正确性。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>自旋锁：线程在获取锁的时候，如果锁已被其他线程获取，那么该线程执行忙循环（自旋）检查是否可以获取锁。</p>
<ul>
<li><p>如果自旋超过限定的次数仍然没有成功获得锁，就应当挂起线程。</p>
</li>
<li><p>避免了线程切换的开销，但是要占用处理器时间，需要一个以上的处理器核心。</p>
</li>
</ul>
<p>自适应自旋：在JDK 6引入，自旋的时间由上一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<ul>
<li>对于同一个锁对象，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机会认为这次自旋也很有可能再次成功。</li>
<li>如果对于某个锁，自旋很少成功获得锁，那么在以后要获取这个锁的时候直接跳过自旋过程。</li>
</ul>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对被检测到不可能存在共享数据竞争的锁进行消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>当一串零碎的操作都对同一个对象加锁时，虚拟机会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>“轻量级”锁是JDK 6加入的新型锁机制，目的是在无竞争的情况下使用CAS操作去消除同步使用的互斥量。</p>
<p>“轻量级”是相对于使用操作系统互斥量来实现的“重量级”锁而言的。</p>
<p>HotSpot虚拟机的对象头第一部分称为“Mark Word”，存储对象自身的运行时数据，如HashCode、分代年龄、偏向模式、锁标志位等信息。这部分是实现轻量级锁和偏向锁的关键。</p>
<p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/image-20200815204815564.png" alt="image-20200815204815564"></p>
<p>MarkWord被设计成一个非固定的动态数据结构，可以根据对象的状态存储不同的信息。</p>
<p>轻量级锁工作过程：</p>
<ol>
<li>代码即将进入同步块时，如果同步对象没有被锁定（MarkWord中锁标志位为01），虚拟机首先在当前线程的栈中建立一个Lock Record空间，用于存储同步对象的MarkWord拷贝。</li>
<li>然后虚拟机使用CAS操作尝试把同步对象的MarkWord内容更新为指向Lock Record的指针，如果更新成功，则表示该线程拥有了这个对象的锁，并且更新锁标志位为“00”表示处于轻量级锁定模式。</li>
<li>如果更新同步对象的MarkWord内容失败，则检测对象的Mark Word是否指向当前线程的Lock Record区域，如果是，则说明已经拥有了这个对象的锁，否则说明此对象已经被其他线程抢占了。</li>
<li>如果出现两个以上的线程争用同一个锁，那么轻量级锁必须膨胀为重量级锁，锁标志位变为10，此时MarkWord中存储的就是指向重量级锁（互斥量）的指针。</li>
<li>解锁过程同样通过CAS操作进行，如果对象的MarkWord仍然指向线程的Lock Record，则用CAS操作把Lock Record中对象原本的MarkWord内容替换回去，如果替换失败，则说明其他线程尝试获取过该锁，在释放锁的时候，唤醒其他被挂起的线程。</li>
</ol>
<p>轻量级锁提升性能的依据是对于绝大部分的锁，整个同步周期内是不存在竞争的。但如果存在锁竞争，额外的CAS操作使得轻量级锁反而比重量级锁更慢。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁也是JDK 6引入的一项锁优化措施，目的是消除数据在无竞争情况下的同步原语，既不使用互斥量，也不使用CAS操作。</p>
<p>当锁对象第一次被线程获取时，虚拟机会把MarkWord中的锁标志位改为01，偏向模式改为1，MarkWord的内容进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的MarkWord中。如果CAS操作成功，持有偏向锁的线程以后每次获取这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（如加锁、解锁、对MarkWord的更新操作等）。</p>
<p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/image-20200815205631602.png" alt="image-20200815205631602"></p>
<p>当另一个线程尝试获取这个锁的时候，若对象未被锁定，则撤销偏向并设定标志位为01；若对象已被锁定，则设定标志位为轻量级锁状态（00）。</p>
<p>当一个对象已经计算过一致性哈希码后，就再也无法进入偏向锁状态了。</p>
<p>当一个对象在偏向锁状态收到需要计算一致性哈希码请求时，偏向状态会被立即撤销，并且锁会膨胀为重量级。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>面试问题</title>
    <url>/2020/09/13/Java/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>记录面试问题。</p>
<a id="more"></a>

<h1 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h1><p><a href="https://www.jianshu.com/p/9fe2c140fa52" target="_blank" rel="noopener">https://www.jianshu.com/p/9fe2c140fa52</a></p>
<h2 id="TCP的KeepAlive"><a href="#TCP的KeepAlive" class="headerlink" title="TCP的KeepAlive"></a>TCP的KeepAlive</h2><p>在保持连接时，一方会不定期发送心跳包给另一方，判断连接是否还需要。</p>
<h2 id="HTTP的Keep-Alive"><a href="#HTTP的Keep-Alive" class="headerlink" title="HTTP的Keep-Alive"></a>HTTP的Keep-Alive</h2><p>该功能HTTP1.0及以前默认关闭，HTTP1.1中默认开启。开启该功能后，在完成一个HTTP请求后，不会立即关闭TCP连接，而是等待一段时间（几十秒）接收浏览器可能发来的其他请求。</p>
<h1 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h1><ul>
<li>-Xms：初始堆大小，默认物理内存的1&#x2F;64。</li>
<li>-Xmx：最大堆大小，默认物理内存的1&#x2F;4。</li>
<li>-Xmn：年轻代大小</li>
</ul>
<h1 id="Socket编程基本流程"><a href="#Socket编程基本流程" class="headerlink" title="Socket编程基本流程"></a>Socket编程基本流程</h1><p><a href="https://www.cnblogs.com/cy568searchx/p/3728586.html" target="_blank" rel="noopener">https://www.cnblogs.com/cy568searchx/p/3728586.html</a></p>
<p>三次握手：</p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20200914153512157.png" alt="image-20200914153512157"></p>
<p>四次挥手：</p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20200914153544195.png" alt="image-20200914153544195"></p>
<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><ol>
<li>socket()创建socket。</li>
<li>bind()将socket与IP地址和端口绑定。</li>
<li>listen()将socket设置为监听模式等待连接请求。</li>
<li>accept()请求到来时，返回一个对应于此次请求的socket。</li>
<li>recv()&#x2F;send()，在socket上收发数据。</li>
<li>closesocked()，关闭套接字。</li>
</ol>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">55533</span>); <span class="comment">// 括号内为端口号</span></span><br><span class="line">Socket socket = server.accept(); <span class="comment">// 等待建立连接	</span></span><br><span class="line"><span class="comment">// 数据传输省略</span></span><br><span class="line">socket.close();</span><br><span class="line">server.close();</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="c语言"><a href="#c语言" class="headerlink" title="c语言"></a>c语言</h3><ol>
<li>socket()创建socket。</li>
<li>connect()向服务器发起连接请求。</li>
<li>recv()&#x2F;send()，在套接字上收发数据。</li>
<li>closesocked()，关闭socket。</li>
</ol>
<h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">55533</span>); <span class="comment">// 建立连接</span></span><br><span class="line"><span class="comment">// 数据传输省略</span></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

<h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><p><a href="https://www.jianshu.com/p/735a3d4789fc" target="_blank" rel="noopener">https://www.jianshu.com/p/735a3d4789fc</a></p>
<p>首先对计算存储结点的哈希值，并将存储结点映射到在一个抽象的环（哈希值空间）上；然后对计算数据的哈希值并映射到环上，按顺时针方向将其配置到最近的存储结点上面。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/2020/08/15/Java/Java%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>Java并发编程。</p>
<a id="more"></a>

<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="线程创建的方式"><a href="#线程创建的方式" class="headerlink" title="线程创建的方式"></a>线程创建的方式</h2><ul>
<li>Thread：继承<strong>Thread</strong>类并重写run方法，直接使用this可以获取当前线程。</li>
<li>Runnable：实现<strong>Runnable</strong>接口并传递给<strong>Thread</strong>。可以继承其他类，多个线程可以共用一个代码逻辑。</li>
<li>FutureTask：实现<strong>Callable</strong>接口传递给<strong>FutureTask</strong>，然后把FutureTask传递给<strong>Thread</strong>。可获取返回结果。</li>
</ul>
<h2 id="线程通知与等待"><a href="#线程通知与等待" class="headerlink" title="线程通知与等待"></a>线程通知与等待</h2><p><strong>Object</strong>类中的通知与等待系列函数，这些方法<strong>获得该对象的锁后才能调用</strong>：</p>
<ul>
<li>wait()：线程阻塞并释放当前对象的锁。返回情况：<ul>
<li>其他线程调用<strong>锁对象</strong>的notify()或notifyAll()。</li>
<li>其他线程调用<strong>该线程</strong>的interrupt()，该线程抛出InterruptedException异常返回。</li>
</ul>
</li>
<li>notify()：随机唤醒一个被挂起的线程来竞争锁。</li>
<li>notifyAll()：唤醒所有被挂起的线程来竞争锁。</li>
</ul>
<p><strong>Thread</strong>类中的通知与等待系列函数：</p>
<ul>
<li>join()：阻塞当前线程，等待目标线程执行完毕。</li>
<li>sleep()：当前线程让出CPU使用权，被阻塞挂起，但是不会释放锁。</li>
<li>yield()：当前线程让出CPU使用权，不会被阻塞，处于就绪状态。</li>
</ul>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>JVM会等待所有用户线程结束后才退出，而守护线程（Daemon Thread）是否结束不影响JVM的退出。</p>
<h2 id="线程本地变量"><a href="#线程本地变量" class="headerlink" title="线程本地变量"></a>线程本地变量</h2><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>访问ThreadLocal变量的线程会在线程中有一个本地副本，操作这个变量不需要与主内存同步。</p>
<p>实现原理：每个<strong>Thread实例</strong>中有一个ThreadLocalMap类型的threadLocals变量，threadLocals以当前ThreadLocal的实例对象引用（this）为key对数据进行存储与读取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; <span class="keyword">var</span> = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="keyword">var</span>.set(<span class="string">"test"</span>);</span><br><span class="line">System.out.println(<span class="keyword">var</span>.get());</span><br></pre></td></tr></table></figure>

<p>内存泄漏问题：ThreadLocalMap的key是对ThreadLocal对象的弱引用，当其他地方没有对ThreadLocal对象的引用时，ThreadLocal对象会被回收，但是对应的value没有被回收，这时候就存在key为null但是value不为null的项。解决方法是使用完毕后调用remove()。</p>
<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>InheritableThreadLocal继承自ThreadLocal，可以让子线程访问父线程中设置的本地变量。</p>
<p>实现原理：每个Thread实例中保存了类似threadLocals的inheritableThreadLocals变量，在当前线程创建新线程时，把当前线程的inheritableThreadLocals变量赋给新线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread parent = currentThread(); <span class="comment">// parent为当前线程</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">this</span>.inheritableThreadLocals = <span class="comment">// this为当前线程正在初始化的新线程</span></span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocalRandom"><a href="#ThreadLocalRandom" class="headerlink" title="ThreadLocalRandom"></a>ThreadLocalRandom</h3><p>每个Thread实例维护一个线程级别的种子变量threadLocalRandomSeed，避免了竞争。</p>
<h2 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h2><p>多线程情况下，可能会出现<strong>缓存一致性</strong>问题（其他线程修改了变量的值并刷新到了主内存中，但是当前线程的工作内存没有及时刷新，与主内存的值不一致）。</p>
<p>锁的可见性就是通过缓存无效化解决这一问题。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul>
<li><p>加锁时，先清除工作内存变量值，然后从主内存读取。</p>
</li>
<li><p>释放锁时，把代码块里的共享变量修改刷新到主内存。</p>
</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>内存语义</p>
<ul>
<li><p>读volatile变量时，先清除工作内存变量值，然后从主内存读取。</p>
</li>
<li><p>写volatile变量时，把共享变量刷新到主内存。</p>
</li>
</ul>
<p>禁止重排序</p>
<ul>
<li>读volatile变量时，确保读之后的操作不会被重排序到读之前。</li>
<li>写volatile变量时，确保写之前的操作不会被重排序到写之后。</li>
</ul>
<h2 id="锁的类别"><a href="#锁的类别" class="headerlink" title="锁的类别"></a>锁的类别</h2><ul>
<li>悲观锁：认为共享变量很容易发生竞争，因此对共享变量进行操作时会加锁。</li>
<li>乐观锁：任务共享变量一般情况下不会发生竞争，所以在操作前不会加锁，而是在更新时才进行冲突检测。</li>
<li>公平锁：线程获取锁的顺序是按照现场请求锁的时间决定的，会带来性能开销。</li>
<li>非公平锁：线程获取锁的顺序不确定。</li>
<li>独占锁：保证任何时候只能有一个线程获得锁。是一种悲观锁。</li>
<li>共享锁：允许多个线程同时进行读操作。是一种乐观锁。</li>
<li>可重入锁：线程再次获取当前已有的锁不会被阻塞。通过在锁内部维护一个线程标志和计数器实现。</li>
<li>自旋锁：执行忙循环检测是否可以获得锁。</li>
</ul>
<h1 id="JUC并发包（java-util-concurrent）"><a href="#JUC并发包（java-util-concurrent）" class="headerlink" title="JUC并发包（java.util.concurrent）"></a>JUC并发包（java.util.concurrent）</h1><h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><h3 id="AtomicInteger、AtomicLong、AtomicBoolean"><a href="#AtomicInteger、AtomicLong、AtomicBoolean" class="headerlink" title="AtomicInteger、AtomicLong、AtomicBoolean"></a>AtomicInteger、AtomicLong、AtomicBoolean</h3><p>属于java.util.concurrent.atomic包</p>
<ul>
<li>基于Unsafe的<strong>CAS</strong>保证数据操作的<strong>原子性</strong>。</li>
<li>通过对value加<strong>volatile关键字</strong>保证<strong>可见性</strong>和<strong>有序性</strong>。</li>
</ul>
<h3 id="LongAdder、DoubleAdder"><a href="#LongAdder、DoubleAdder" class="headerlink" title="LongAdder、DoubleAdder"></a>LongAdder、DoubleAdder</h3><p>AtomicLong等类在有大量线程竞争时，会不断自旋尝试CAS操作，造成了CPU资源浪费，LongAdder类在内部维护多个Cell变量（一个Cell数组），每个Cell有一个<strong>volatile修饰</strong>的long型变量。当线程在当前Cell变量CAS失败后，可以在其他Cell上进行CAS尝试，最后把<strong>所有Cell的值累加后再加上base</strong>返回。</p>
<p>使用<code>@sun.misc.Contended</code>注解修饰Cell类<strong>避免伪共享</strong>。</p>
<p>调用sum()返回当前的值，但是没有加锁，所以返回的值不一定准确。</p>
<h2 id="并发List"><a href="#并发List" class="headerlink" title="并发List"></a>并发List</h2><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>是一个线程安全的ArrayList，使用了写时复制策略，对其进行的修改操作都是在一个复制的数组上进行的。</p>
<p>内部使用一个<strong>volatile修饰</strong>的数组来存放具体元素。</p>
<p>get()不加锁。add()、set()、remove()时加<strong>ReentrantLock</strong>锁，对数组的一个快照进行操作，不影响其他线程读取原数组，然后更新原数组的引用。</p>
<p>迭代器的弱一致性：返回迭代器后，其他线程对list的增删改对迭代器是不可见的。</p>
<p>CopyOnWriteArraySet底层是使用CopyOnWriteArrayList实现的。</p>
<h2 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h2><h3 id="LockSupport工具类"><a href="#LockSupport工具类" class="headerlink" title="LockSupport工具类"></a>LockSupport工具类</h3><p>主要作用是挂起和唤醒线程，是创建锁和其他同步类的基础。基于Unsafe类的park()和unpark()实现。</p>
<p>LockSupport类与每个使用它的线程会关联一个许可证，默认情况下调用LockSupport类方法的线程是不持有许可证的。</p>
<ul>
<li>park()：调用线程如果已经获得许可证，则调用时会马上返回，否则会被阻塞挂起。</li>
<li>unpark(Thread thread)：如果线程没有持有许可证，则让线程持有，如果线程因调用park()挂起，则唤醒线程。</li>
</ul>
<h3 id="抽象同步队列AQS（AbstractQueueSynchronizer）"><a href="#抽象同步队列AQS（AbstractQueueSynchronizer）" class="headerlink" title="抽象同步队列AQS（AbstractQueueSynchronizer）"></a>抽象同步队列AQS（AbstractQueueSynchronizer）</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200903224211947.png" alt="image-20200903224211947"></p>
<p>是实现同步器的基础组件，JUC中锁的底层就是使用AQS实现的。</p>
<p>AQS是一个双向队列，head和tail记录队首和队尾结点。</p>
<h4 id="静态内部类Node"><a href="#静态内部类Node" class="headerlink" title="静态内部类Node"></a>静态内部类Node</h4><ul>
<li>Thread thread：<strong>volatile</strong>修饰，存放进入AQS的线程。</li>
<li>Node SHARED：标记该线程是获取<strong>共享资源</strong>时被阻塞后放入AQS的。</li>
<li>Node EXCLUSIVE：标记该线程是获取<strong>独占资源</strong>时被阻塞后加入AQS的。</li>
<li>Node pre, next：<strong>volatile</strong>修饰，记录前驱和后继结点。</li>
</ul>
<h4 id="AQS维护了一个volatile修饰的状态信息state"><a href="#AQS维护了一个volatile修饰的状态信息state" class="headerlink" title="AQS维护了一个volatile修饰的状态信息state"></a>AQS维护了一个volatile修饰的状态信息state</h4><ul>
<li>在ReentrantLock中：state表示当前线程获取锁的可重入次数。</li>
<li>在ReentrantReadWriteLock中：state高16位表示读锁的次数，低16位表示获取到写锁的线程可重入次数。</li>
<li>在Semaphore中：state用于表示当前可用信号的个数。</li>
<li>在CountDownLatch中：state表示计数器的值。</li>
</ul>
<h4 id="内部类ConditionObject"><a href="#内部类ConditionObject" class="headerlink" title="内部类ConditionObject"></a>内部类ConditionObject</h4><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200819100243950.png" alt="image-20200819100243950"></p>
<p>实现了Condition接口，每个条件变量对应一个条件队列，用于存放条件变量的await()后被阻塞的线程。</p>
<p>Node firstWaiter, lastWaiter分别记录了条件队列的头、尾结点。</p>
<p><strong>Condition</strong>类中的通知与等待系列函数，这些方法<strong>在调用锁的lock()方法获取锁后才能调用</strong>：</p>
<ul>
<li>await()：将当前线程封装成一个Node结点插入到条件队列的尾部，释放当前线程获取的锁，并调用LockSupport.park(this)挂起当前线程。</li>
<li>signal()：把队头线程结点从条件队列中移除并放入AQS的阻塞队列里面，然后激活这个线程。</li>
<li>signalAll()：移除条件队列中所有节点并放入AQS的阻塞队列里面。</li>
</ul>
<h4 id="其他锁在基于AQS实现时，关键是定义state的操作方法"><a href="#其他锁在基于AQS实现时，关键是定义state的操作方法" class="headerlink" title="其他锁在基于AQS实现时，关键是定义state的操作方法"></a>其他锁在基于AQS实现时，关键是定义state的操作方法</h4><ul>
<li><p>独占方式：acquire()，acquireInterruptibly()，release()。</p>
<p>获取与释放资源：</p>
<ul>
<li><p>线程调用acquire()获取资源：方法内部调用**tryAcquire()**尝试设置state的值，成功则直接返回，失败则将当前线程封装为一个Node结点插入到AQS队列的尾部，并调用LockSupport.park(this)挂起自己。</p>
</li>
<li><p>线程调用release()释放资源：方法内部调用**tryRelease()<strong>尝试设置state的值，然后调用LockSupport.unpark(thread)激活AQS队列中的一个线程，被激活的线程调用</strong>tryAcquire()**尝试获取锁。</p>
</li>
</ul>
<p>acquireInterruptibly()：忽略中断，不对中断进行响应。</p>
</li>
<li><p>tryAcquire()和tryRelease()需要由具体的子类根据需求来实现。</p>
</li>
<li><p>共享方式：acquireShared()，acquireSharedInterruptibly()，releaseShared()。获取、释放资源流程与独占方式类似。</p>
</li>
</ul>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200903223938171.png" alt="image-20200903223938171"></p>
<p>基于AQS实现，state表示该线程获取该锁的可重入次数，可以设置为公平锁或非公平锁。</p>
<ul>
<li>非公平锁：当一个线程第一次获取该锁时会尝试使用<strong>CAS</strong>设置state的值为1，如果成功则设置锁持有者为当前线程，否则检查锁的持有线程是不是当前线程，是的话更新state加一，否则将当前线程放入AQS队列。</li>
<li>公平锁：线程获取锁时，首先检查锁是否已被占有：如果没有被占有，再检查AQS队列中是否有其他线程在等待，如果没有则尝试获取锁，如果有则将当前线程加入到AQS队列尾部。如果已被占用，则检查持有锁的线程是不是当前线程，是的话则更新state加一，否则将当前线程加入到AQS队列尾部。</li>
</ul>
<p>释放锁时将state值减一，若state为0则表示释放锁。</p>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200903224043298.png" alt="image-20200903224043298"></p>
<p>读写分离策略，内部维护了两个锁：ReadLock和WriteLock。</p>
<p>使用AQS实现，state的高16位表示获取到读锁的次数，低16位表示获取到写锁的线程可重入次数。</p>
<ul>
<li>写锁WriteLock：独占可重入锁，如果当前已有其他线程持有读锁或写锁，则当前线程会被阻塞挂起。</li>
<li>读锁ReadLock：如果当前没有其他线程持有写锁，则可以获取读锁，state的高16加1。如果有其他线程持有写锁，则当前线程会被阻塞。</li>
</ul>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>提供了三种模式的读写控制，调用获取锁的函数时，会返回一个long型stamp表示锁的状态，当调用释放锁和转换锁的方法时需要传入这个stamp值。</p>
<p>StampedLock提供三种读写模式的锁：</p>
<ul>
<li>写锁writeLock：独占锁，不可重入。当目前没有其他线程持有读锁或者写锁时才能获取到该锁。</li>
<li>悲观读锁readLock：共享锁，不可重入。其他线程可以加读锁，不能加写锁。</li>
<li>乐观读锁tryOptimisticRead：没有显式的加锁释放锁，在具体操作数据前根据stamp验证期间是否有其他线程持有了写锁。</li>
</ul>
<h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>继承自AbstractQueue，使用单向链表实现，无界队列，入队和出队操作使用<strong>CAS</strong>来实现线程安全。</p>
<ul>
<li><p>队列中保存了<strong>volatile</strong>关键字修饰的head和tail结点。</p>
</li>
<li><p>每个Node包括<strong>volatile</strong>修饰的元素和next结点。</p>
</li>
</ul>
<p>添加元素时通过CAS操作来保证只有一个线程可以成功追加元素到队列尾部，失败的线程会循环尝试添加元素。</p>
<p>通过无限循环的CAS尝试来代替阻塞，<strong>使用CPU资源换阻塞带来的用户态与内核态切换、线程切换等开销</strong>。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200901234217695.png" alt="image-20200901234217695"></p>
<p>都继承自AbstractQueue类，除LinkedTransferQueue外都实现了<strong>BlockingQueue</strong>接口。</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904192818763.png" alt="image-20200904192818763"></p>
<p>使用单向链表实现，无界队列。</p>
<ul>
<li>两个ReentrantLock实例保证操作的原子性：<ul>
<li>putLock：调用put()、offer()等操作时在内部会尝试获取该锁，保证同时<strong>只有一个线程可以操作尾结点</strong>。</li>
<li>takeLock：调用take()、poll()等操作时在内部会尝试获取该锁，保证同时<strong>只有一个线程可以操作头结点</strong>。</li>
</ul>
</li>
<li>notEmpty为takeLock的条件变量，notFull为putLock的条件变量，是生产者-消费者模型。</li>
</ul>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904192834599.png" alt="image-20200904192834599"></p>
<p>使用数组实现，有界队列，构造时必须传入队列大小。与LinkedBlockingQueue不同的是，ArrayBlockingQueue采用一个全局锁，加锁粒度更大。</p>
<ul>
<li>数组items用于存放队列元素。</li>
<li>一个<strong>ReentrantLock</strong>实例lock用于保证同时只有一个线程可以进行出队入队操作。</li>
<li>两个lock的条件变量：<ul>
<li>notEmpty：队列空时，出队线程被阻塞挂起放入该条件队列。</li>
<li>notFull：队列满时，入队线程被阻塞挂起放入该条件队列。</li>
</ul>
</li>
</ul>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904200910774.png" alt="image-20200904200910774"></p>
<p>使用平衡二叉树堆（数组实现）实现，带优先级的无界队列。</p>
<ul>
<li>数组queue用于存放队列元素。</li>
<li>一个<strong>volatile</strong>修饰的int类型自旋锁allocationSpinLock保证同时只有一个线程可以扩容队列：<ul>
<li>0表示当前没有进行扩容。</li>
<li>1表示当前正在扩容。</li>
</ul>
</li>
<li>一个全局锁<strong>ReentrantLock</strong>实例lock用于保障同时只有一个线程可以进行出队入队操作。</li>
<li>一个lock的条件变量notEmpty用于实现出队的阻塞模式，由于是无界队列，入队时是非阻塞的。</li>
</ul>
<p>使用数组存放队列元素，一个自旋锁通过CAS操作来保证同时只有一个线程可以扩容队列，一个ReentrantLock控制只有一个线程可以进行入队、出队操作。notEmpty条件变量控制出队同步。</p>
<h2 id="线程池ThreadPoolExecutor"><a href="#线程池ThreadPoolExecutor" class="headerlink" title="线程池ThreadPoolExecutor"></a>线程池ThreadPoolExecutor</h2><p>在执行大量异步任务时线程池能够提供较好的性能，线程池里面的线程是可复用的，不需要每次执行异步任务时都重新创建和销毁线程。</p>
<ul>
<li>参数ctl是一个AtomicInteger变量，高3位表示线程池状态，低29位记录线程个数。</li>
<li>内部类Worker继承AQS和Runnable接口，一个Worker封装了一个线程，并实现了简单不可重入独占锁，state为0时表示锁未被获取，state为1时表示锁已被获取。</li>
<li>HashSet&lt;Worker&gt;类型的workers用于存储线程。</li>
</ul>
<p>使用完线程池需要调用shutdown()关闭线程池，否则会导致主线程已经退出，但是JVM仍然存在。</p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><ul>
<li><strong>RUNNING</strong>：接受新任务并处理阻塞队列里的任务。</li>
<li><strong>SHUTDOWN</strong>：拒绝新任务但是<strong>处理阻塞队列里的任务</strong>。</li>
<li><strong>STOP</strong>：拒绝新任务并<strong>抛弃阻塞队列里的任务，同时中断正在处理的任务</strong>。</li>
<li><strong>TIDYING</strong>：所有任务执行完毕后线程数为0，即将调用terminated方法。</li>
<li><strong>TERMINATED</strong>：终止状态。</li>
</ul>
<h3 id="线程池构造参数"><a href="#线程池构造参数" class="headerlink" title="线程池构造参数"></a>线程池构造参数</h3><ul>
<li>corePoolSize：线程池核心线程个数。</li>
<li>maximumPoolSize：线程池最大线程数量。</li>
<li>workQueue：保存等待执行的任务的阻塞队列：<ul>
<li>基于数组的有界阻塞队列ArrayBlockingQueue。</li>
<li>基于链表的无界阻塞队列LinkedBlockingQueue。</li>
<li>最多只有一个元素的阻塞队列SynchronousQueue。</li>
<li>优先级阻塞队列PriorityBlockingQueue。</li>
</ul>
</li>
<li>ThreadFactory：创建线程的工厂。</li>
<li>RejectedExecutionHandler：队列满并且线程个数达到最大后采取的策略。<ul>
<li>AbortPolicy：抛出异常。</li>
<li>CallerRunsPolicy：使用调用者所在的线程来运行任务。</li>
<li>DiscardOldestPolicy：调用poll()丢弃一个任务，执行当前任务。</li>
<li>DiscardPolicy：丢弃任务，不抛出异常。</li>
</ul>
</li>
<li>keepAliveTime：线程数量比核心线程数量多且闲置时，表示闲置线程的最大存活时间。</li>
<li>TimeUnit：存活时间的单位。</li>
</ul>
<h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><ul>
<li><strong>newFixedThreadPool</strong>：核心和最大线程数都为参数nThread，阻塞队列长度为整型最大值，可以设置存活时间和阻塞队列类型。</li>
<li><strong>newSingleThreadExecutor</strong>：<strong>核心和最大线程数都为1</strong>，阻塞队列长度为整型最大值，可以设置存活时间和阻塞队列类型。</li>
<li><strong>newCachedThreadPool</strong>：按任务创建线程，初始线程个数为0，最多为整型最大值，阻塞队列为同步队列且加入同步队列的任务会被马上执行，<strong>同步队列中对多只有一个任务</strong>。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>execute(Runnable command)：提交任务command到线程池执行。如果当前线程池的线程数量小于核心线程数量，则通过CAS操作向workers里面新增一个核心线程执行该任务。</p>
<p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904225713537.png" alt="image-20200904225713537"></p>
</li>
</ul>
<h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p>可以在指定一定延迟时间后或者定时进行任务调度执行的线程池。</p>
<p>使用DelayQueue来存放任务，任务分为三种：</p>
<ul>
<li>一次性执行任务：执行完毕就结束了。</li>
<li>fixed-delay任务：同一任务在多次执行之间间隔固定时间。</li>
<li>fixed-rate任务：保证按照固定的频率执行。</li>
</ul>
<h2 id="线程同步器"><a href="#线程同步器" class="headerlink" title="线程同步器"></a>线程同步器</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904230700998.png" alt="image-20200904230700998"></p>
<p>使用AQS实现，把计数器的值赋给AQS的状态变量state，多个线程调用countDown()实际是原子性递减state。当线程调用await()方法后会被放入AQS的阻塞队列等待计数器为0再返回。</p>
<p>以线程数量为参数创建一个CountDownLatch实例，主线程调用countDownLatch.await()后会被阻塞，子线程执行完毕后调用countDownLatch.countDown()使countDownLatch内部的计数器减1，计数器为0时主线程的await()方法返回，表示所有子线程已执行完毕。</p>
<p>使用线程池管理线程时一般是直接添加Runnable到线程池，这时候就无法调用线程的join()，而CountDownLatch使我们对线程同步有更灵活的控制。</p>
<h3 id="回环屏障CyclicBarrier"><a href="#回环屏障CyclicBarrier" class="headerlink" title="回环屏障CyclicBarrier"></a>回环屏障CyclicBarrier</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904231215070.png" alt="image-20200904231215070"></p>
<p>CyclicBarrier可以让一组线程全部达到一个状态后再全部同时执行。</p>
<p>线程调用await()后会被阻塞，这个阻塞点称为屏障点，等所有线程都调用了await()后，线程们就会冲破屏障，继续向下执行。</p>
<p>基于ReentrantLock实现，本质底层还是基于AQS，parties记录线程数量，count记录还有多少个线程没有到达屏障点。使用ReentrantLock保证count更新的原子性。</p>
<h3 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904231439695.png" alt="image-20200904231439695"></p>
<p>也是一个同步器，计数器是递增的并且可以指定一个初始值，在需要同步的地方调用acquire()指定需要达到的计时器值，在线程内部调用release()使计数器加1。</p>
<p>也是使用AQS实现的，获取信号量时有公平和非公平策略。</p>
<h1 id="NIO模型——Tomcat的NioEndPoint"><a href="#NIO模型——Tomcat的NioEndPoint" class="headerlink" title="NIO模型——Tomcat的NioEndPoint"></a>NIO模型——Tomcat的NioEndPoint</h1><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904233842705.png" alt="image-20200904233842705"></p>
<p>使用队列把接受请求与处理请求操作进行解耦，实现异步处理。实际Poller中维护一个ConcurrentLinkedQueue用于缓存任务，其本身也是一个多生产者-单消费者模型。</p>
<ul>
<li>Acceptor：套接字接受线程，用于接受用户的请求，并把请求封装为事件放入Poller的队列。只有一个。</li>
<li>Poller：套接字处理线程，每个Poller内部都有一个独有的队列，Poller线程从自己的队列中获取事件任务交给Worker进行处理。Poller线程的个数与处理器的核数有关。</li>
<li>Worker：实际处理请求的线程。</li>
</ul>
<h2 id="生产者——Acceptor线程"><a href="#生产者——Acceptor线程" class="headerlink" title="生产者——Acceptor线程"></a>生产者——Acceptor线程</h2><p>Acceptor线程中一直循环接收客户端连接请求，当成功获取到一个连接套接字后，将其封装为一个Channel对象并注册为事件存放到Poller对象的队列中。</p>
<h2 id="消费者——Poller线程"><a href="#消费者——Poller线程" class="headerlink" title="消费者——Poller线程"></a>消费者——Poller线程</h2><p>Poller线程中从事件队列中获取一个事件，遍历所有注册的Channel并对感兴趣的事件进行处理。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习1</title>
    <url>/2020/08/29/%E6%9E%B6%E6%9E%84/Spring%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<p>Spring学习。</p>
<a id="more"></a>

<h1 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h1><p>IoC（Inverse of Control，反转控制）是一种设计思想，将原本手动创建对象的控制权交给Spring框架来管理。</p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，减少系统的重复代码，降低模块的耦合度，有利于提高系统的可扩展性和可维护性。</p>
<p><img src="/images/Spring%E5%AD%A6%E4%B9%A01/image-20200830194807094.png" alt="image-20200830194807094"></p>
<p>AOP基于动态代理，如果代理的对象实现了某个接口，那么Spring AOP会使用JDK Proxy去创建代理对象，而对于没有实现接口的对象，使用Cglib生成一个被代理对象的子类来作为代理。</p>
<h2 id="Spring-AOP与Aspect-AOP"><a href="#Spring-AOP与Aspect-AOP" class="headerlink" title="Spring AOP与Aspect AOP"></a>Spring AOP与Aspect AOP</h2><ul>
<li>Spring AOP：运行时增强，基于动态代理，简单。</li>
<li>Aspect AOP：编译时增强，基于字节码操作，强大，更快。</li>
</ul>
<h1 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h1><p>@scope(“singleton”)</p>
<ul>
<li><strong>singleton</strong>：在Spring IoC容器中只存在一个Bean实例，即以单例方式存在，默认值。</li>
<li><strong>prototype</strong>：每次从容器中调用Bean时，都返回一个新的实例。</li>
<li>request：每次HTTP请求都会创建一个新的Bean，仅适用于WebApplicationContext环境。</li>
<li>session：同一个HTTP Session共享一个Bean，仅适用于WebApplicationContext环境。</li>
<li>global-session：全局session，一般用于Portlet应用环境，仅适用于WebApplicationContext环境。</li>
</ul>
<h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><p><img src="/images/Spring%E5%AD%A6%E4%B9%A01/880f402c83a0e04f2b4ccfcec3239dc8_r.jpg" alt="preview"></p>
<ol>
<li><p>实例化Bean：new操作，调用构造方法。</p>
</li>
<li><p>设置对象属性：利用依赖注入调用setter设置属性值。</p>
</li>
<li><p>BeanNameAware接口，Spring将Bean的id传给setBeanName()。</p>
</li>
<li><p>BeanFactoryAware接口，Spring调用setBeanFactory()，将BeanFactory容器实例传入。</p>
</li>
<li><p>ApplicationContextAware接口，Spring调用setApplicationContext()，将bean所在应用的上下文引用传入。</p>
</li>
<li><p>BeanPostProcessor接口，Spring调用他们的postProcess<strong>Before</strong>Initialization()。</p>
</li>
<li><p>InitializingBean接口，Spring调用他们的afterPropertiesSet()。</p>
</li>
<li><p>调用配置文件中包含init-method属性的方法</p>
</li>
<li><p>BeanPostProcessor接口，Spring调用他们的postProcess<strong>After</strong>Initialization()。</p>
</li>
<li><p>Bean已经准备就绪，可以被使用。</p>
</li>
<li><p>DisposableBean接口，Spring将调用destory()。</p>
</li>
<li><p>调用配置文件中包含destroy-method属性的方法。</p>
</li>
</ol>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p>Spring MVC是一个基于MVC设计模式的框架，通过把Model，View，Controller分离，将表现层（其他两层：业务层，数据访问层）进行解耦，简化开发，减少出错，方便组内人员之间的配合。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>用户发送请求到前端控制器DispatcherServlet。</li>
<li>DispatcherServlet根据请求调用HandlerMapping，获取到对应的Handler。</li>
<li>DispatcherServlet调用HandlerAdapter来执行Handler，并返回一个ModelAndView对象。</li>
<li>DispatcherServlet调用ViewResolver对视图进行解析，并将Model数据填充到视图中。</li>
<li>最后DispatcherServlet将View返回给用户。</li>
</ol>
<h1 id="相关设计模式"><a href="#相关设计模式" class="headerlink" title="相关设计模式"></a>相关设计模式</h1><ol>
<li>工厂模式：BeanFactory、ApplicationContext创建Bean对象。</li>
<li>代理模式：Spring AOP的实现。</li>
<li>单例模式：Bean的默认作用域。</li>
<li>装饰器模式：不同的客户在每次访问中会根据需求去访问不同的数据库。</li>
<li>观察者模式：Spring事件驱动模型。</li>
<li>适配器模式：Spring AOP的增强或通知、Spring MVC使用适配器模式适配Controller。</li>
</ol>
<h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><h2 id="管理事务的方式"><a href="#管理事务的方式" class="headerlink" title="管理事务的方式"></a>管理事务的方式</h2><ul>
<li>编程式事务：代码中硬编码。</li>
<li>声明式事务：在配置文件中配置。基于XML或基于注解。</li>
</ul>
<h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p>规定了事务方法或事务方法嵌套调用时的事务传播方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation=propagation.REQUIRED)</span><br><span class="line">methodA &#123;</span><br><span class="line">	methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation=propagation.[以下七种传播机制])</span><br><span class="line">methodB &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><blockquote>
<p>如果当前没有事务，则新建一个事务，如果已经存在一个事务中，则加入该事务。</p>
</blockquote>
<p>如果当前没有事务，则创建一个事务；如果当前已经处于一个事务中，则加入到该事务。默认设置。</p>
<h3 id="supports"><a href="#supports" class="headerlink" title="supports"></a>supports</h3><blockquote>
<p>支持当前事务，如果当前没有事务，则以非事务方式执行。</p>
</blockquote>
<p>如果当前没有事务，则以非事务方式执行；如果当前已经处于一个事务中，则加入到该事务。</p>
<h3 id="mandatory"><a href="#mandatory" class="headerlink" title="mandatory"></a>mandatory</h3><blockquote>
<p>使用当前事务，如果当前没有事务，则抛出异常。</p>
</blockquote>
<p>如果当前没有事务，则抛出异常；如果当前已经处于一个事务中，则加入到该事务。</p>
<h3 id="requires-new"><a href="#requires-new" class="headerlink" title="requires_new"></a>requires_new</h3><blockquote>
<p>新建事务，如果当前存在事务，则把当前事务挂起。</p>
</blockquote>
<p>如果当前没有事务，则创建一个事务；如果当前已经处于一个事务中，则把已存在的事务挂起，新创建一个事务并执行。</p>
<h3 id="not-supported"><a href="#not-supported" class="headerlink" title="not_supported"></a>not_supported</h3><blockquote>
<p>以非事务方式执行，如果当前存在事务，则把当前事务挂起。</p>
</blockquote>
<p>如果当前没有事务，则以非事务方式执行；如果当前已经处于一个事务中，则把已存在的事务挂起。</p>
<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><blockquote>
<p>以非事务方式执行，如果当前存在事务，则抛出异常。</p>
</blockquote>
<p>如果当前没有事务，则以非事务方式执行；如果当前已经处于一个事务中，则抛出异常。</p>
<h3 id="nested"><a href="#nested" class="headerlink" title="nested"></a>nested</h3><p>如果当前没有事务，则创建一个事务；如果当前已经处于一个事务中，则创建一个嵌套事务。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习2：InnoDB存储引擎</title>
    <url>/2020/08/14/%E6%9E%B6%E6%9E%84/MySQL%E5%AD%A6%E4%B9%A02%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>InnoDB存储引擎。</p>
<a id="more"></a>

<h1 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h1><ul>
<li>第一范式（1NF）：字段是单一属性，不可再分的。</li>
<li>第二范式（2NF）：在第一范式的基础上，所有非主键字段都完全依赖于任意一个主键或联合主键，即不能存在非主键字段对联合主键的部分依赖。</li>
<li>第三范式（3NF）：在第二范式的基础上，所有非主键字段都直接依赖于主键不能存在传递依赖。</li>
</ul>
<h1 id="MyISAM与InnoDB的区别"><a href="#MyISAM与InnoDB的区别" class="headerlink" title="MyISAM与InnoDB的区别"></a>MyISAM与InnoDB的区别</h1><ol>
<li>锁粒度：MyISAM只支持表级锁，InnoDB支持行级锁和表级锁。</li>
<li>事务：MyISAM不支持事务，InnoDB支持事务。</li>
<li>外键：MyISAM不支持外键，InnoDB支持外键。</li>
<li>索引：MyISAM为非聚簇索引，InnoDB为聚簇索引，叶结点中存储所有行数据。</li>
</ol>
<h1 id="一条SQL语句在MySQL中的执行过程"><a href="#一条SQL语句在MySQL中的执行过程" class="headerlink" title="一条SQL语句在MySQL中的执行过程"></a>一条SQL语句在MySQL中的执行过程</h1><ol>
<li>连接器：验证身份和权限。</li>
<li>分析器：对SQL语句进行词法分析和语法分析。</li>
<li>优化器：选择最优的执行方案，如索引选择。</li>
<li>执行器：验证执行权限，调用存储引擎接口，返回引擎的执行结果。</li>
</ol>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul>
<li>普通索引：加速查询。</li>
<li>唯一索引：加速查询，列值唯一。</li>
<li>主键索引：加速查询，列值唯一，每个表只有一个。</li>
<li>联合索引：多列值组合成一个索引。</li>
<li>全文索引：对文本内容进行分词，进行搜索。</li>
</ul>
<h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><p>聚簇索引在叶结点存储了所有的行数据。根据辅助索引查找时，需要先查出主键值，然后根据得到的主键值在主键索引中查询出行数据（回表查询）。</p>
<p>非聚簇索引在叶结点存储的是行数据的地址。根据辅助索引查找时，可以直接得到数据的地址。</p>
<h2 id="自适应哈希索引（AHI）"><a href="#自适应哈希索引（AHI）" class="headerlink" title="自适应哈希索引（AHI）"></a>自适应哈希索引（AHI）</h2><p>InnoDB会自动根据访问频率和模式来为某些热点页建立哈希索引。</p>
<ul>
<li>以相同条件查询了100次。</li>
<li>页通过该条件访问了N次，其中N&#x3D;页中记录*1&#x2F;16。</li>
</ul>
<p>只能用于等值查询</p>
<h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>指构建索引的字段包含了SELECT的数据列。</p>
<h2 id="索引在什么情况下会失效"><a href="#索引在什么情况下会失效" class="headerlink" title="索引在什么情况下会失效"></a>索引在什么情况下会失效</h2><ol>
<li>多列查询没有按最左原则进行查询。</li>
<li>使用like查询时%在前面。</li>
<li>查询条件为字符串时没有使用引号。</li>
<li>使用or时，存在条件没有使用索引。</li>
<li>当MySQL认为全表扫描更快时。</li>
</ol>
<h2 id="哪些字段需要建立索引"><a href="#哪些字段需要建立索引" class="headerlink" title="哪些字段需要建立索引"></a>哪些字段需要建立索引</h2><ol>
<li><p>主键自动建立唯一索引。</p>
</li>
<li><p>频繁作为where条件查询的字段。</p>
</li>
<li><p>外键字段。</p>
</li>
<li><p>总是成对出现在where中的建立联合索引。</p>
</li>
</ol>
<h2 id="哪些字段不适合建立索引"><a href="#哪些字段不适合建立索引" class="headerlink" title="哪些字段不适合建立索引"></a>哪些字段不适合建立索引</h2><ol>
<li>频繁更新的字段。</li>
<li>where条件中用不到的字段。</li>
<li>表数据比较少时。</li>
</ol>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是逻辑上的一组数据库操作，要么全部执行，要么都不执行。</p>
<h2 id="四大特性——ACID"><a href="#四大特性——ACID" class="headerlink" title="四大特性——ACID"></a>四大特性——ACID</h2><ul>
<li><strong>原子性</strong>（Atomic）：事务是最小执行单位，不允许分割，要么全部执行，要么都不执行。</li>
<li><strong>一致性</strong>（Consistent）：事务使系统从一个一致的状态转换到另一个一致状态。事务开始和结束的中间状态不会被其他事务观察到。</li>
<li><strong>隔离性</strong>（Isolation）：并发访问数据库时，事务之间互不影响。适当破坏一致性来提高性能与并行度。</li>
<li><strong>持久性</strong>（Durability）：事务提交后对数据库中数据的改变是永久的，不会被回滚。</li>
</ul>
<h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><ul>
<li><p><strong>丢失修改</strong>：一个事务正在访问并修改某个数据，但是修改后还没提交，如果此时另一个事务也对该数据进行了修改，那么第一个事务的修改就被覆盖了，称为丢失修改。</p>
</li>
<li><p><strong>脏读</strong>：一个事务正在访问并修改某个数据，但是修改后还没提交，如果此时另一个事务也访问了该数据，那么另一个事务读到的是未提交的数据，称为脏读。</p>
</li>
<li><p><strong>不可重复读</strong>：在一个事务两次访问同一个数据之间，另一个事务对该数据进行了<strong>修改</strong>，导致第一个事务两次访问的结果不一致。</p>
</li>
<li><p><strong>幻读</strong>：在一个事务两次进行相同查询之间，另一个事务进行了<strong>插入</strong>操作，导致第一个事务两次查询到的数据行数不一致。</p>
</li>
</ul>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul>
<li><strong>读未提交</strong>（READ UNCOMMITED）：事务中允许读取其他事务未提交的数据变更，可能导致<strong>脏读、不可重复读、幻读</strong>。</li>
<li><strong>读已提交</strong>（READ COMMITED）：事务中允许读取其他事务已提交的数据，可能导致<strong>幻读、不可重复读</strong>。</li>
<li><strong>可重复读</strong>（REPEATABLE READ）：事务中对同一字段的多次读取结果一样，就算期间被其他事务修改过，可能存在<strong>幻读</strong>。</li>
<li><strong>串行化</strong>（SERIALIZABLE）：所有事务依次逐个执行，事务之间互不干扰。</li>
</ul>
<p>InnoDB默认的隔离级别是可重复读，使用Next-Key Lock算法，也可以避免<strong>幻读</strong>。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="从粒度划分"><a href="#从粒度划分" class="headerlink" title="从粒度划分"></a>从粒度划分</h3><ul>
<li><p>表级锁：对当前操作的整张表加锁，资源消耗少，加锁快，不会出现死锁，但是并发度最低。</p>
</li>
<li><p>行级锁：对当前操作行加锁，并发度高。</p>
</li>
</ul>
<h3 id="从操作类型分"><a href="#从操作类型分" class="headerlink" title="从操作类型分"></a>从操作类型分</h3><ul>
<li>共享锁（S）：多个读锁可以共存。</li>
<li>排他锁（X）：不能和其他写锁和读锁共存。</li>
<li>意向共享锁（IS）：加S锁之前要先加IS锁，从粗粒度到细粒度依次加锁。</li>
<li>意向排他锁（IX）：加X锁之前要先加IX锁，从粗粒度到细粒度依次加锁。</li>
</ul>
<h3 id="InnoDB锁算法"><a href="#InnoDB锁算法" class="headerlink" title="InnoDB锁算法"></a>InnoDB锁算法</h3><ul>
<li><strong>Record Lock</strong>：锁定符合条件的行，其他事务不能修改和删除加锁行。</li>
<li><strong>Gap Lock</strong>：间隙锁，对第一条记录前的间隙或最后一条记录后的间隙加锁，不包括自身，其他事务不能加锁范围内插入数据。</li>
<li><strong>Next-key Lock</strong>：Record Lock + Gap Lock，可避免幻读。当查询的索引含有唯一属性时，自动降级为Record Lock。</li>
</ul>
<h2 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h2><p>当MySQL单表数据量过大时，数据库的CRUD性能会明显下降，一些常见优化措施如下：</p>
<ul>
<li><p>限定数据范围：禁止不带任何数据范围条件的查询语句。</p>
</li>
<li><p>读写分离：主库负责写，从库负责读。</p>
</li>
<li><p>垂直分区：按列拆成多张表。可以使列数据变小，简化表结构，但是会出现冗余，会让事务变得复杂。</p>
</li>
<li><p>水平分区：按行拆成多张表，逻辑上还是一个表，物理上拆分为多个文件，可以避免单个表数据量过大对性能造成影响，但会带来逻辑、部署、运维的各种复杂的。</p>
</li>
</ul>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>可以实现对数据库连接的复用，不用每次都进行创建销毁操作，减少了用户等待建立数据库连接的时间。</p>
<p>可以通过连接池最大值等属性动态控制数据库连接数量。</p>
<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><ul>
<li>RANGE分区：基于某个字段按多个连续区间进行分区。如按年月存放数据。</li>
<li>LIST分区：基于某个字段按给定的多个LIST进行分区，LIST中指定了分区的值。</li>
<li>HASH分区：基于某个字段利用自定义hash算法进行分区，如取余。</li>
<li>KEY分区：与HASH分区类似，但是使用MySQL数据库提供的函数进行分区。</li>
</ul>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>MVCC通过版本控制在undolog中找回数据的历史版本，可以并发读与读，读与写操作，只有写与写之间会相互阻塞，提高了并发度。只在READ COMMITED和REPEATABLE READ两个隔离级别下工作。</p>
<h2 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h2><ul>
<li>DB_TRX_ID（6字节）：记录最近一次对本行数据进行修改（插入，更新，删除）的事务ID。</li>
<li>DB_ROLL_PTR（7字节）：回滚指针。</li>
<li>DB_ROW_ID（6字节）：InnoDB默认递增ID（与MVCC无关）。</li>
</ul>
<h2 id="快照（read-view）关键参数"><a href="#快照（read-view）关键参数" class="headerlink" title="快照（read view）关键参数"></a>快照（read view）关键参数</h2><ul>
<li>low_limit_id：当前最大事务ID+1，即下一个将分配的事务ID。</li>
<li>up_limit_id：trx_ids中最小的事务ID，若trx_ids为空，则等于low_limit_id</li>
<li>trx_ids：快照创建时其他未提交的活跃事务ID列表。</li>
<li>create_trx_id：当前创建事务的ID，是一个递增ID。</li>
</ul>
<h2 id="可见性比较算法"><a href="#可见性比较算法" class="headerlink" title="可见性比较算法"></a>可见性比较算法</h2><p>判断数据行中记录的事务ID是否存在于活跃事务ID之中：</p>
<ol>
<li>若数据行记录的事务ID<strong>小于</strong>活跃事务ID列表中的最小ID，则当前事务可以直接读取该行数据。</li>
<li>若数据行记录的事务ID大于活跃事务ID列表的最小ID且小于活跃事务ID列表的最大ID，则表示当前行记录的ID可能处于活跃状态，需要遍历活跃事务ID列表进行判断可见性。</li>
</ol>
<p>若数据行记录的事务ID大于生成快照时系统的最大事务ID，则数据行对当前事务不可见。</p>
<p>通过回滚指针回滚直到找到对当前事务可见的数据版本。</p>
<h2 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h2><ul>
<li>快照读：普通的SELECT语句，不会产生幻读。</li>
<li>当前读：SELECT…LOCK IN SHARE MODE、SELECT…FOR UPDATE、INSERT、UPDATE、DELETE等都是获取最新数据。通过next-key lock避免幻读。</li>
</ul>
<p>InnoDB在快照读的情况下并没有真正避免幻读，但是在当前读的情况下可以避免不可重复读和幻读。</p>
<h2 id="REPEATABLE-READ和READ-COMMETED时生成快照的区别"><a href="#REPEATABLE-READ和READ-COMMETED时生成快照的区别" class="headerlink" title="REPEATABLE READ和READ COMMETED时生成快照的区别"></a>REPEATABLE READ和READ COMMETED时生成快照的区别</h2><ol>
<li>RR级别下，事务只有执行第一条SELECT语句时会生成一个快照。</li>
<li>RC级别下，事务每次执行SELECT语句时都会重新生成快照。</li>
</ol>
<h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><p>在master结点中，可选择以下三种模式将数据变化写到binary-log文件中：</p>
<ul>
<li>statement：将数据库操作的<strong>sql语句</strong>写入binlog，实时性更好。</li>
<li>row：将<strong>每一条数据的变化</strong>写入binary-log，会消耗更大的磁盘空间和磁盘IO。</li>
<li>mixed：statement和row的混合。由MySQL决定什么时候写statement格式，什么时候写row格式。</li>
</ul>
<p><strong>master结点：</strong>当slave结点连接到master结点时，master结点会为slave结点开启binlog dump线程，当master结点的binlog发生变化时，binlog dump线程会通知slave，并将对应的binlog内容发送给slave。</p>
<p><strong>slave结点：</strong>当主从同步开启时，slave结点上会创建2个线程。</p>
<ul>
<li>IO线程：该线程负责接收master结点发送的binlog内容，并写入到本地的relay log。</li>
<li>SQL线程：该线程负责读取relay log并根据内容进行相应的操作。</li>
</ul>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p><a href="https://zhuanlan.zhihu.com/p/25933039" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25933039</a></p>
<p>分布式事务是指事务的操作位于不同的结点上，需要保证事务的ACID特性。</p>
<p>如下单时，库存和订单的数据库不在同一个结点。</p>
<h2 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h2><ol>
<li>协调者询问事务参与者是否执行成功，参与者发回事务执行结果。</li>
<li>若事务在每个参与者上都执行成功，协调者通知所有参与者提交事务，否则通知回滚事务。</li>
</ol>
<p><strong>存在的问题：</strong></p>
<ul>
<li>同步阻塞：已完成事务的参与者需要阻塞等待其他参与者完成事务。</li>
<li>单点问题：当协调者发送故障时，可能导致参与者一直处于等待状态。</li>
<li>数据不一致：在第二阶段，可能由于网络问题，只有部分参与者收到了commit通知。</li>
<li>任意一个结点的失败会导致整个事务的失败。</li>
</ul>
<h2 id="补偿事务（TCC：try-confirm-cancel）"><a href="#补偿事务（TCC：try-confirm-cancel）" class="headerlink" title="补偿事务（TCC：try-confirm-cancel）"></a>补偿事务（TCC：try-confirm-cancel）</h2><ol>
<li>try阶段对业务系统做检测及资源预留。</li>
<li>confirm阶段对业务系统做提交确认。</li>
<li>cancel阶段在业务执行错误时，取消业务，释放预留资源。</li>
</ol>
<h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><ol>
<li>消息生产方需要额外建立一个消息表，并记录消息发送状态。消息表和业务数据需要在一个事务里提交。</li>
<li>消息消费方需要处理这个消息，并完成自己的业务逻辑。如果本地事务执行成功，则回复给生产方一个confirm消息，否则将该消息放回消息队列。</li>
<li>消息生产方需要定时扫描本地消息表，把没有处理完成的消息继续重新发送。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习1：SQL语句</title>
    <url>/2020/08/14/%E6%9E%B6%E6%9E%84/MySQL%E5%AD%A6%E4%B9%A01%EF%BC%9ASQL%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p><code>{}</code>表示必选项，<code>[]</code>表示可选项</p>
<a id="more"></a>

<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p><code>CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset_name</code></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>整型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT</p>
<p>浮点型：FLOAT、DOUBLE</p>
<p>日期时间型：YEAR、TIME、DATE、DATETIME、TIMESTAMP</p>
<p>字符型：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM(‘value1’,’value2’,…)、SET(‘value1’,’value2’,…)</p>
<h1 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h1><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><p><code>CREATE TABLE [IF NOT EXIST] table_name (column_name data_type,...);</code></p>
<ul>
<li><p>NULL，字段允许为空；NOT NULL，字段禁止为空。</p>
</li>
<li><p>AUTO_INCREMENT：自动编号，必须与主键组合使用，默认情况下起始值为1，每次增量为1。</p>
</li>
<li><p>PRIMARY：主键，每张数据表只能存在一个主键字段，自动为NOT NULL。</p>
</li>
<li><p>UNIQUE KEY：唯一约束，每张数据表可以存在多个唯一约束字段，可以为NULL。</p>
</li>
<li><p>DEFAULT：默认值，插入记录时，如果没有明确赋值，则自动赋予默认值。</p>
</li>
<li><p>FOREIGN KEY：外键，子表（具有FOREIGN KEY的表）和父表必须使用InnoDB存储引擎；外键列和参照列必须具有相似的数据类型，必须创建索引。</p>
<p><code>FOREIGN KEY (pid) REFERENCES tb_name (id) ON DELETE CASCADE</code></p>
<p>外键约束的参照操作：</p>
<ul>
<li>CASCADE：从父表删除或更新行时自动删除或更新子表对应的行。</li>
<li>SET NULL：从父表删除或更新行时设置子表外键列为NULL，必须保证子表外键列没有指定NOT NULL。</li>
<li>RESTRICT：拒绝对父表的删除或更新操作。</li>
<li>NO ACTION：在MySQL中与RESTRICT相同。</li>
</ul>
</li>
</ul>
<h3 id="CREATE-…-SELECT-…"><a href="#CREATE-…-SELECT-…" class="headerlink" title="CREATE … SELECT …"></a>CREATE … SELECT …</h3><p><code>CREATE tb_name (col_name,...) SELECT ...;</code></p>
<p>将查询的数据写入到新建的数据表中。</p>
<h2 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h2><p>添加单列：<code>ALTER TABLE tb_name ADD (column_name data_type,...);</code></p>
<p>删除列：<code>ALTER TABLE tb_name DROP column_name;</code></p>
<p>添加外键：<code>ALTER TABLE tb_name ADD FOREIGN KEY (pid) REFERENCES tb2_name (id);</code></p>
<p>删除主键、添加&#x2F;删除默认约束、添加&#x2F;删除唯一约束、删除外键约束等</p>
<h2 id="操作数据表中的记录"><a href="#操作数据表中的记录" class="headerlink" title="操作数据表中的记录"></a>操作数据表中的记录</h2><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p><code>INSERT tb_name(col_name,...) VALUES(value1,...);</code>可以用NULL或DEFAULT占用递增字段。</p>
<p><code>INSERT tb_name SET col_name1=value1,...;</code>，这种方法可以使用子查询。</p>
<p><code>INSERT tb_name(col_name,...) SELECT ...</code>，将查询结果插入表中。</p>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p><code>UPDATE tb_name SET col_name=value,... [WHERE ...];</code></p>
<p>使用<strong>连接</strong>进行多表更新：</p>
<p><code>UPDATE tb_name INNER JOIN tb_name2 ON 连接条件 SET col_name=value,...</code></p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p><code>DELETE FROM tb_name [WHERE ...];</code></p>
<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p><code>SELECT expr,... [FROM tb_name [WHERE ...] [GROUP BY ... [ASC|DESC]] [HAVING ...] [ORDER BY ... [ASC|DESC]] [LIMIT row_count OFFSET row_count]]</code></p>
<p>字段表达式的顺序会影响结果的顺序</p>
<p>可以在字段前加上表名避免多表连接查询时字段名冲突</p>
<p>可以使用AS赋予别名，会影响结果的字段名，可用于GROUP BY，ORDER BY，HAVING子句。</p>
<h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><p>WHERE</p>
<h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><p>查询结果分组，查询某一个字段的所有取值。</p>
<h4 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h4><p>分组条件</p>
<h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><p>按一个或多个字段对查询结果进行排序</p>
<h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h4><p>限制查询结果返回的数量</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>嵌套在查询内部的SELECT子句，必须出现在圆括号内。</p>
<p>子查询的返回值可以是标量、行、列、子查询。</p>
<h4 id="比较子查询"><a href="#比较子查询" class="headerlink" title="比较子查询"></a>比较子查询</h4><p><code>SELECT * FROM tb_name WHERE col_name &gt; ANY (子查询);</code></p>
<p><img src="/images/MySQL1/image-20200826112320549.png" alt="image-20200826112320549"></p>
<h4 id="IN、NOT-IN子查询"><a href="#IN、NOT-IN子查询" class="headerlink" title="IN、NOT IN子查询"></a>IN、NOT IN子查询</h4><p><code>IN (子查询)</code>与<code>=ANY (子查询)</code>等效</p>
<p><code>NOT IN (子查询)</code>与<code>!=ALL (子查询)</code>、<code>&lt;&gt;ALL (子查询)</code>等效</p>
<h4 id="EXISTS、NOT-EXISTS子查询"><a href="#EXISTS、NOT-EXISTS子查询" class="headerlink" title="EXISTS、NOT EXISTS子查询"></a>EXISTS、NOT EXISTS子查询</h4><p>子查询语句查询到结果，EXISTS返回TRUE、否则返回FALSE</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>MySQL在SELECT语句、多表更新、多表删除中支持JOIN操作。</p>
<p>使用ON设定连接条件，也可以使用WHERE代替。</p>
<h4 id="内连接INNER-JOIN等价于JOIN、CROSS-JOIN"><a href="#内连接INNER-JOIN等价于JOIN、CROSS-JOIN" class="headerlink" title="内连接INNER JOIN等价于JOIN、CROSS JOIN"></a>内连接INNER JOIN等价于JOIN、CROSS JOIN</h4><p><code>SELECT col_name FROM tb_name INNER JOIN tb_name2 ON 连接条件;</code></p>
<p>显示左表（当前查询表）和右表（连接表）符合连接条件的记录（交集）。</p>
<p><img src="/images/MySQL1/image-20200826224618172.png" alt="image-20200826224618172"></p>
<h4 id="左外连接LEFT-JOIN"><a href="#左外连接LEFT-JOIN" class="headerlink" title="左外连接LEFT JOIN"></a>左外连接LEFT JOIN</h4><p>显示左表的全部记录及右表符合连接条件的记录。</p>
<p><img src="/images/MySQL1/image-20200826224854158.png" alt="image-20200826224854158"></p>
<h4 id="右外连接RIGHT-JOIN"><a href="#右外连接RIGHT-JOIN" class="headerlink" title="右外连接RIGHT JOIN"></a>右外连接RIGHT JOIN</h4><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h3><p><img src="/images/MySQL1/image-20200826232137034.png" alt="image-20200826232137034"></p>
<p><img src="/images/MySQL1/image-20200826232205853.png" alt="image-20200826232205853"></p>
<p>SUBSTRING()从1开始计数，可以用负值从末尾开始数。</p>
<h3 id="数值运算符与函数"><a href="#数值运算符与函数" class="headerlink" title="数值运算符与函数"></a>数值运算符与函数</h3><p><img src="/images/MySQL1/image-20200826232654739.png" alt="image-20200826232654739"></p>
<h3 id="比较运算符与函数"><a href="#比较运算符与函数" class="headerlink" title="比较运算符与函数"></a>比较运算符与函数</h3><p><img src="/images/MySQL1/image-20200826233006754.png" alt="image-20200826233006754"></p>
<h3 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h3><p><img src="/images/MySQL1/image-20200826233244090.png" alt="image-20200826233244090"></p>
<h3 id="信息函数"><a href="#信息函数" class="headerlink" title="信息函数"></a>信息函数</h3><p><img src="/images/MySQL1/image-20200826233613821.png" alt="image-20200826233613821"></p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><img src="/images/MySQL1/image-20200826233855766.png" alt="image-20200826233855766"></p>
<h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h3><p><img src="/images/MySQL1/image-20200826234102940.png" alt="image-20200826234102940"></p>
<h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p><code>CREATE FUNCTION function_name(参数) RETURNS {STRING|INTEGER|REAL|DECIMAL} 函数体;</code></p>
<p>函数体由合法的SQL语句构成，可以使用声明、循环等流程控制。</p>
<p>只能有一个返回值。</p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>SQL语句和控制语句的预编译集合，可以增强SQL语句的功能和灵活性，实现较快的执行速度，存储过程名字代替SQL语句减少网络流量。</p>
<p>可以返回多个值。</p>
<p><code>CREATE PROCEDURE sp_name([IN|OUT|INOUT]参数) 过程体;</code></p>
<ul>
<li><p>IN输入类型参数，表示该参数的值必须在调用存储过程时指定。</p>
</li>
<li><p>OUT输出类型参数，表示该参数的值可以被存储过程改变，并且可以返回。</p>
</li>
<li><p>INOUT输入&amp;输出类型参数，表示改参数在调用时指定，并且可以被改变和返回。</p>
</li>
</ul>
<p>过程体由合法的SQL语句构成，可以使用声明、循环等流程控制。</p>
<p>调用存储过程：<code>CALL sp_name();</code></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2020/08/30/%E6%9E%B6%E6%9E%84/Redis/</url>
    <content><![CDATA[<p>Redis相关知识点。</p>
<p>Redis是一个开源的高性能键值对的内存数据库，可以用作数据库、缓存、消息中间件等，是一种NoSQL数据库（Not-only SQL，非关系型数据库）。</p>
<a id="more"></a>

<h1 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h1><ol>
<li>基于内存操作。</li>
<li>单线程模型，避免了上下文切换。</li>
<li>多路复用IO模型，非阻塞IO。</li>
</ol>
<h1 id="Redis优点"><a href="#Redis优点" class="headerlink" title="Redis优点"></a>Redis优点</h1><ol>
<li>基于内存操作，读写速度快。</li>
<li>数据类型丰富，string，hash，list，set，sorted set等。</li>
<li>支持事务，操作都是原子性的。</li>
<li>支持发布订阅，设置过期时间等。</li>
</ol>
<h1 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h1><h2 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h2><p>用途：键，string类型，缓冲区（AOF缓冲区，客户端状态的输入缓冲区等）。</p>
<p>SDS结构如图所示</p>
<p><img src="/images/Redis/image-20200921213725636.png" alt="image-20200921213725636"></p>
<ul>
<li>free：记录该SDS的空闲空间。</li>
<li>len：记录该SDS的已用空间。</li>
<li>buf：char数组，用于保存字符串。</li>
</ul>
<h2 id="双端链表linkedlist"><a href="#双端链表linkedlist" class="headerlink" title="双端链表linkedlist"></a>双端链表linkedlist</h2><p>用途：list类型等。</p>
<h2 id="字典hashtable"><a href="#字典hashtable" class="headerlink" title="字典hashtable"></a>字典hashtable</h2><p>用途：hash类型等。</p>
<h2 id="跳跃表skiplist"><a href="#跳跃表skiplist" class="headerlink" title="跳跃表skiplist"></a>跳跃表skiplist</h2><p>用途：zset类型，集群节点等。</p>
<p>每个节点会根据幂次定律（越大的数出现的概率越小）随机生成多个层，每个层中保存了下一个<strong>同级层</strong>的指针及其跨度。</p>
<h2 id="整数集合intset"><a href="#整数集合intset" class="headerlink" title="整数集合intset"></a>整数集合intset</h2><p>用途：set类型等。</p>
<p>可以保存的类型为int16_t、int32_t、int64_t的整数值，通过自动升级策略节约内存，提高灵活性。</p>
<p>当一个set只包含整数值元素，且元素数量不多时（512），<strong>Redis采用intset作为set的底层实现</strong>。</p>
<h2 id="压缩列表ziplist"><a href="#压缩列表ziplist" class="headerlink" title="压缩列表ziplist"></a>压缩列表ziplist</h2><p>用途：list类型，hash类型等。</p>
<p>当一个<strong>list键</strong>只包含少量元素（512），且元素长度都小于64字节时，Redis采用ziplist作为底层实现。</p>
<p>当一个<strong>hash键</strong>只包含少量键值对（512），且键值都小于64字节时，Redis采用ziplist作为底层实现。</p>
<p>当一个<strong>zset键</strong>只包含少量元素（512），且元素长度都小于64字节时，Redis采用ziplist作为底层实现。</p>
<p>压缩列表的节点包括三个属性：</p>
<ul>
<li>previous_entry_length：以字节为单位，记录了前一个节点的长度。</li>
<li>encoding：记录了content保存的数据的类型和长度。</li>
<li>content：保存节点的值，是一个char数组或整数。</li>
</ul>
<p>节约内存，从尾向头遍历。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>值可以是string，也可以是数字、二进制数据等。底层数据结构可以是<strong>int，raw(SDS)或embstr</strong>。</p>
<p><img src="/images/Redis/image-20220112153608910.png" alt="image-20220112153608910"></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>使用ziplist时，先将key推入表尾，再将value推入表尾。</p>
<p>编码转换</p>
<p><img src="/images/Redis/image-20220112164857610.png" alt="image-20220112164857610"></p>
<p><img src="/images/Redis/image-20220112155327565.png" alt="image-20220112155327565"></p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>编码转换</p>
<p><img src="/images/Redis/image-20220112164809306.png" alt="image-20220112164809306"></p>
<p><img src="/images/Redis/image-20220112155241467.png" alt="image-20220112155241467"></p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>编码转换</p>
<p><img src="/images/Redis/image-20220112164950571.png" alt="image-20220112164950571"></p>
<p><img src="/images/Redis/image-20220112155402241.png" alt="image-20220112155402241"></p>
<h2 id="Zset（Sorted-Set）"><a href="#Zset（Sorted-Set）" class="headerlink" title="Zset（Sorted Set）"></a>Zset（Sorted Set）</h2><p>使用ziplist时，元素和分数存放在相邻节点。</p>
<p>编码转换</p>
<p><img src="/images/Redis/image-20220112165205470.png" alt="image-20220112165205470"></p>
<p>当底层结构为skiplist时，zset中有一个字典用于保存key到score的映射，且key和score是共享跳跃表中的数据，因此不需要额外的内存空间。</p>
<p><img src="/images/Redis/image-20220112172951475.png" alt="image-20220112172951475"></p>
<h1 id="内存回收与对象共享"><a href="#内存回收与对象共享" class="headerlink" title="内存回收与对象共享"></a>内存回收与对象共享</h1><p>基于引用计数实现内存回收。</p>
<p>Redis在初始化服务器时，会创建0-9999的字符串共享对象。</p>
<h1 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line">EXPIRE &lt;key&gt; &lt;ttl&gt; 设置key的生存时间为ttl秒</span><br><span class="line">PEXPIRE &lt;key&gt; &lt;ttl&gt; 设置key的生存时间为ttl毫秒</span><br><span class="line">EXPIREAT &lt;key&gt; &lt;timestamp&gt; 设置key的过期时间为秒时间戳timestamp</span><br><span class="line">PEXPIREAT &lt;key&gt; &lt;timestamp&gt; 设置key的过期时间为毫秒时间戳timestamp</span><br></pre></td></tr></table></figure>

<p>过期时间保存在redisDb结构的expires字典中，key指向键对象的内存地址，value为long long过期时间</p>
<h1 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h1><p>定期删除+惰性删除。</p>
<ul>
<li><p>定时删除：设置过期时间的同时创建一个定时器，在键到达过期时间时立即删除。</p>
</li>
<li><p>定期删除：定时随机抽取一些（或全部）设置了过期时间的key，检查其是否过期，如果过期就删除。</p>
</li>
<li><p>惰性删除：尝试访问一个已过期但还没被删除的key时，redis会把该数据删除掉。</p>
</li>
</ul>
<h3 id="主从复制下的过期键"><a href="#主从复制下的过期键" class="headerlink" title="主从复制下的过期键"></a>主从复制下的过期键</h3><ul>
<li>主服务器在删除一个过期键之后，会向所有从服务器发送一个DEL命令。</li>
<li>从服务器<strong>只有在接到主服务器发来的DEL命令时才会删除过期键</strong>。在执行客户端发送的请求时，不会考虑键是否已经过期。保证主从数据一致性。</li>
</ul>
<h3 id="持久化时过期键处理"><a href="#持久化时过期键处理" class="headerlink" title="持久化时过期键处理"></a>持久化时过期键处理</h3><ul>
<li>生成RDB文件时不会保存已过期的键。</li>
<li>只有在过期键被惰性或者定期删除时，程序会向AOF文件append一条DEL命令。</li>
<li>AOF重写时，过期键不会保存到重写后的AOF文件中。</li>
</ul>
<h1 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h1><ul>
<li>volatile-lru：从已设置过期时间的数据中挑选<strong>最近最少使用</strong>的数据淘汰。</li>
<li>volatile-lfu：从已设置过期时间的数据中挑选<strong>使用频率最低</strong>的数据淘汰。</li>
<li>volatile-ttl：从已设置过期时间的数据中挑选<strong>将要过期</strong>的数据淘汰。</li>
<li>volatile-random：从已设置过期时间的数据中<strong>随机选择</strong>数据淘汰。</li>
<li>allkeys-lru：从所有数据中选择<strong>最近最少使用</strong>的数据淘汰。</li>
<li>allkeys-lfu：当所有数据中选择<strong>使用频率最低</strong>的数据淘汰。</li>
<li>allkeys-random：从所有数据中<strong>随机选择</strong>数据淘汰。</li>
<li>no-eviction：<strong>不淘汰数据</strong>，内存不足以容纳新写入数据时报错。</li>
</ul>
<h1 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h1><p>若服务器在启动时优先检测是否开启AOF持久化（AOF更新频率更高），若没有则检测RDB文件并自动载入RDB文件。</p>
<h2 id="快照持久化RDB"><a href="#快照持久化RDB" class="headerlink" title="快照持久化RDB"></a>快照持久化RDB</h2><p>适合于定时文件备份和灾难恢复，恢复大数据集时比AOF快。但由于是全量备份，因此备份需要花费较多的时间，且不会记录备份期间的数据变化。</p>
<h3 id="SAVE和BGSAVE"><a href="#SAVE和BGSAVE" class="headerlink" title="SAVE和BGSAVE"></a>SAVE和BGSAVE</h3><ul>
<li><p>SAVE：save会阻塞Redis服务器进程，直到RDB文件创建完毕，期间无法执行其他命令。</p>
</li>
<li><p>BGSAVE：bgsave会派生出一个子进程（fork()方法），然后由子进程负责创建RDB文件。在bgsave执行期间，会拒绝其他的save和bgsave命令。</p>
<p>Redis服务器启动时，可以通过指定配置文件或者传入启动参数的方式设置save选项。默认save选项如下：</p>
<ul>
<li>save 900 1：在900秒内，至少1个key发生变化，执行BGSAVE。</li>
<li>save 300 10：在300秒内，至少10个key发生变化，执行BGSAVE。</li>
<li>save 60 10000：在1分钟内，至少10000个key发生变化，执行BGSAVE。</li>
</ul>
<p>每100ms检查是否满足保存条件，满足时其中一个条件时执行<strong>BGSAVE</strong>命令。</p>
</li>
</ul>
<h3 id="RDB过期键处理"><a href="#RDB过期键处理" class="headerlink" title="RDB过期键处理"></a>RDB过期键处理</h3><ul>
<li>生成RDB文件时，只保存未过期键。</li>
<li>主服务器载入RDB文件时，只读取未过期键；从服务器则会读取所有键。</li>
</ul>
<h2 id="只追加文件AOF"><a href="#只追加文件AOF" class="headerlink" title="只追加文件AOF"></a>只追加文件AOF</h2><p>恢复速度比RDB慢，通常比快照文件大。但是备份的实时性较好。</p>
<h3 id="备份步骤"><a href="#备份步骤" class="headerlink" title="备份步骤"></a>备份步骤</h3><ol>
<li><p><strong>命令追加：</strong>服务器执行一个写命令，并将该命令追加到服务器状态的<strong>aof_buf</strong>缓冲区。</p>
</li>
<li><p><strong>文件写入和同步：</strong>在事件循环结束之前会根据以下配置决定AOF文件同步方式。</p>
</li>
</ol>
<ul>
<li><p>appendfsync always：将缓冲区所有内容写入并<strong>立即同步</strong>AOF文件。效率最慢，但是最安全。</p>
</li>
<li><p>appendfsync everysec：将缓冲区所有内容写入AOF文件，<strong>每秒钟同步</strong>一次。默认选项。</p>
</li>
<li><p>appendfsync no：将缓冲区所有内容写入AOF文件，让<strong>操作系统决定何时进行同步</strong>。效率最快，但是出现故障停机时，操作系统没有来得及写入到文件的缓冲区部分会丢失。</p>
</li>
</ul>
<p>说明：在操作系统中，当用户调用write()函数时，操作系统通常会将写入数据暂时<strong>保存在一个内存缓冲区aof_buf</strong>中，可以通过fsync和fdatasync两个<strong>同步函数</strong>强制让操作系统立即将缓冲区中的数据写入到硬盘，保证安全性。</p>
<h3 id="AOF载入"><a href="#AOF载入" class="headerlink" title="AOF载入"></a>AOF载入</h3><p>由于Redis命令只能在客户端上下文中执行，因此在载入AOF文件时，会创建一个不带网络连接的<strong>伪客户端</strong>来执行逐行读取AOF文件中的命令并执行。</p>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>AOF文件会随着时间越来越大，因此需要对AOF文件进行重写来减少一些冗余的命令。首先从数据库中读取键现在的值（不需要对AOF文件进行任何读取、分析或者写入操作），然后<strong>用一条命令去记录键值对</strong>，代替之前记录这个键值对的多条命令。实际在处理list、hash、set、zset类型时，若带有较多元素（默认64）时，会使用多条命令来记录。</p>
<p>AOF重写是在<strong>带有主进程数据副本的子进程</strong>中执行的（防止锁冲突），Redis服务器会将AOF重写期间执行的命令同时发送到<strong>AOF缓冲区和AOF重写缓冲</strong>区。当子进程完成重写任务后，父进程会将AOF重写缓冲区里的所有内容写入新AOF文件中，然后原子地覆盖原本的AOF文件，在此期间父进程会被阻塞。</p>
<h3 id="AOF过期键处理"><a href="#AOF过期键处理" class="headerlink" title="AOF过期键处理"></a>AOF过期键处理</h3><p>当过期键被惰性删除或者定期删除时，Redis会向AOF文件中追加一条DEL命令来显式地记录该键已被删除。</p>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>​	服务器使用redisClient结构保存客户端属性。</p>
<h2 id="客户端通用属性"><a href="#客户端通用属性" class="headerlink" title="客户端通用属性"></a>客户端通用属性</h2><ul>
<li>套接字描述符fd：当前客户端正在使用的套接字描述符，伪客户端为-1（AOF文件或者Lua脚本）。</li>
<li>名字name：客户端名字，默认为空，可以设置。</li>
<li>标志flag：可以是多个标志组成的二进制或，包括客户端角色和状态。</li>
<li>输入缓冲区querybuf：保存客户端发送的命令请求。超过1GB时服务器会关闭该客户端。</li>
<li>命令及参数argv：是一个数组，argv[0]是要执行的命令，其它项是命令参数（key，value等）。</li>
<li>argc：记录argv的长度。</li>
<li>命令的实现函数cmd：</li>
<li>输出缓冲区：默认是一个固定16KB的字节数组，bufpos属性记录buf已使用的字节数。当buf数组的空间用完时，改为使用reply链表保存一个或多个返回的字符串对象。</li>
<li>身份验证authenticated：当该属性为0时，出了AUTH命令验证身份外，其他命令都会被拒绝执行。</li>
<li>时间相关属性：<ul>
<li>ctime：创建客户端的时间。</li>
<li>lastinteraction：客户端与服务端上一次互动的时间（客户端发送或者服务端回复）。</li>
<li>obuf_soft_limit_reached_time：输出缓冲区第一次到达soft limit的时间。</li>
</ul>
</li>
</ul>
<h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h2><h3 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h3><p>普通客户端通过网络连接到服务器时，服务器会创建相应的redisClient结构并添加到clients链表末尾。</p>
<h3 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h3><p>关闭的原因：</p>
<ul>
<li>客户端进程或被杀死时，网络连接关闭造成客户端关闭。</li>
<li>客户端发送了带有不符合协议格式的命令请求。</li>
<li>客户端成为了CLIENT KILL命令的目标。</li>
<li>若用户为服务器设置了timeout配置，客户端空转时间超时会被关闭。但如果客户端是主服务器、从服务器、正在被BLPOP等命令阻塞或者正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令时，客户端不受timeout时间限制。</li>
<li>客户端发送的请求超过了输入缓冲区大小（默认1GB）。</li>
<li>服务端发送的回复超过了输出缓冲区大小时：<ul>
<li>硬性限制（hard limit）：输出缓冲区超过了hard limit设置的大小时，立即关闭客户端。</li>
<li>软性限制（soft limit）：输出缓冲区超过了soft limit设置的大小，但没超过hard limit时，记录超出时间，持续时间超过设定阈值时，关闭客户端。</li>
</ul>
</li>
</ul>
<h3 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h3><p>服务器初始化时，会创建执行Lua脚本的伪客户端，并创建redisClient结构添加到lua_client链表末尾。</p>
<h3 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h3><p>服务器载入AOF文件时，会创建执行AOF文件的伪客户端，并在载入完成后关闭。</p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>Redis的主从复制分为同步和命令传播两个操作：</p>
<ul>
<li><strong>同步：</strong>更新从服务器的数据库状态与主服务器一致</li>
<li><strong>命令传播：</strong>主服务器的数据库状态变化时，需要将这些命令同步给从服务器。</li>
</ul>
<p>当从服务器初次对主服务器进行复制时，主服务器会将自己的<strong>运行ID</strong>传送给从服务器保存，以便从服务器断线重连后进行主服务器确认。</p>
<h2 id="完整重同步"><a href="#完整重同步" class="headerlink" title="完整重同步"></a>完整重同步</h2><p><img src="/images/Redis/image-20200924000325035.png" alt="image-20200924000325035"></p>
<p>当客户端向从服务器发送SLAVEOF命令时，从服务器需要执行同步操作。</p>
<ol>
<li>从服务器向主服务器发送<code>PSYNC ? -1</code>（2.8之前为SYNC）命令。</li>
<li>主服务器收到PSYNC后执行BGSAVE生成一个RDB文件，并将期间执行的所有写命令记录在一个缓冲区中。</li>
<li>主服务器将生成好的RDB文件发送给从服务器，从服务器接收并载入RDB文件。</li>
<li>主服务器将缓冲区中的写命令发送给从服务器，从服务器执行这些写命令。</li>
</ol>
<h2 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h2><p><img src="/images/Redis/image-20200924001048756.png" alt="image-20200924001048756"></p>
<p>部分重同步用于处理从服务器断线后重复制的情况。</p>
<ul>
<li><strong>复制偏移量</strong>：主服务器向从服务器发送N个字节的数据时，将自己的复制偏移量加N。从服务器收到主服务器发送的N个字节的数据时，将自己的复制偏移量加N。</li>
<li><strong>复制积压缓冲区</strong>：是主服务器维护的一个固定长度先进先出队列，默认为1MB。主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会写入到复制积压缓冲区中。</li>
</ul>
<p>当从服务器断线重连时，会向服务器发送<code>PSYNC 主服务器ID 从服务器复制偏移量</code>，若从服务器与主服务器的复制偏移量之差小于复制积压缓冲区的大小，则主服务器执行部分重同步，只发送断线期间缺失的数据。否则主服务器执行完整重同步。</p>
<h2 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h2><p>完成同步后，主从服务器就会进入命令传播阶段，当客户端向主服务器发送新的写命令时，主服务器会将这些写命令发送给从服务器执行。</p>
<h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>在命令传播阶段，从服务器默认以每秒一次的频率向主服务器发送命令<code>REPLCONF ACK 复制偏移量</code>。其作用为：</p>
<ul>
<li>检测主从服务器的网络连接状态。</li>
<li>辅助实现min-salves选项，如可以设置在检测到从服务器数量少于3个，或者3个从服务器的延迟都大于等于10s时，可能处于不安全状态，主服务器拒绝执行写命令。</li>
<li>检测命令丢失。</li>
</ul>
<h1 id="哨兵-Sentinel-模式"><a href="#哨兵-Sentinel-模式" class="headerlink" title="哨兵(Sentinel)模式"></a>哨兵(Sentinel)模式</h1><p>哨兵模式是Redis集群的<strong>高可用性</strong>的解决方案：由一个或多个哨兵实例组成的哨兵系统可以监视主服务器及其所有从服务器，并在监视到主服务器进入下线状态时，自动地将某个从服务器升级为新的主服务器。</p>
<h2 id="启动并初始化Sentinel"><a href="#启动并初始化Sentinel" class="headerlink" title="启动并初始化Sentinel"></a>启动并初始化Sentinel</h2><p>Sentinel本质上是一个运行在特殊模式下的Redis服务器。</p>
<ol>
<li>初始化服务器。</li>
<li>将普通Redis服务器代码替换为Sentinel专用代码。</li>
<li>初始化Sentinel状态：根据配置文件初始化监听的主服务器列表。</li>
<li>创建与主服务器的网络连接：成为主服务器的客户端，包括<strong>一个命令连接和一个订阅连接</strong>：<ul>
<li>命令连接：用于向主服务器发送命令并接收回复。</li>
<li>订阅连接：用于订阅服务器的__sentinel__:hello频道，用于避免丢失命令，也用于多个订阅了同一服务器的sentinel信息同步。</li>
</ul>
</li>
</ol>
<h2 id="获取服务器信息"><a href="#获取服务器信息" class="headerlink" title="获取服务器信息"></a>获取服务器信息</h2><p>Sentinel默认每10秒向被监听服务器发送<strong>INFO命令</strong>来获取服务器状态，通过分析INFO命令回复，Sentinel可以获取到被监听服务器信息（服务器ID，角色，IP地址，复制偏移量等），然后Sentinel根据信息更新服务器的实例结构。</p>
<p>如果主服务器返回的信息中存在<strong>新的从服务器</strong>，则会创建与新从服务器的<strong>命令连接和订阅连接</strong>。</p>
<h2 id="向服务器发送频道信息"><a href="#向服务器发送频道信息" class="headerlink" title="向服务器发送频道信息"></a>向服务器发送频道信息</h2><p>Sentinel默认每2秒向被监听服务器发送命令<code>PUBLISH __sentinel__: hello sentinel信息 主服务器或从服务器正在复制的主服务器的信息</code>。</p>
<h2 id="接收来自服务器频道信息"><a href="#接收来自服务器频道信息" class="headerlink" title="接收来自服务器频道信息"></a>接收来自服务器频道信息</h2><p>当Sentinel与一个服务器建立订阅连接后，会向服务器发送命令<code>SUBSCRIBE __sentinel__:hello</code>，对于监视同一个服务器的多个Sentinel，<strong>1</strong>，并被用于更新对应主服务器的实例结构。</p>
<p>当一个Sentinel接收到其他Sentinel的消息时，会从中提取出源Sentinel和主服务器的相关参数并进行更新。</p>
<p>若源Sentinel是一个<strong>新的Sentinel</strong>，则会创建与新Sentinel的<strong>命令连接</strong>，而新Sentinel也会创建一个连向当前Sentinel的<strong>命令连接</strong>。</p>
<h2 id="检查主观下线状态"><a href="#检查主观下线状态" class="headerlink" title="检查主观下线状态"></a>检查主观下线状态</h2><p>Sentinel默认会每秒向其他创建了命令连接的服务器，Sentinel发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。</p>
<p>若实例在<strong>down-after-milliseconds</strong>（Sentinel的配置文件中）毫秒内连续返回无效回复，当前Sentinel则判定此实例已主观下线。</p>
<ul>
<li>有效回复：+PONG、-LOADING、-MASTERDOWN。</li>
<li>无效回复：除有效回复之外的回复或在指定时间内没有回复。</li>
</ul>
<h2 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h2><p>当Sentinel发送命令<code>SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</code>从其他Sentinel询问到足够数量（quorum）的主观下线判定后，会将该服务器判定为客观下线。</p>
<h2 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h2><p>当一个主服务器被判定为客观下线时，监视该主服务器的所有Sentinel会协商选举一个领头Sentinel，然后由领头Sentinel对下线主服务器进行故障转移操作。</p>
<p>每个发现主服务器进入客观下线的Sentinel都会向其他Sentinel发送命令要求对方将自己设置为局部领头Sentinel，在一个配置纪元中，每个Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，而每个Sentinel会设置命令最早到达的Sentinel为局部领头Sentinel。</p>
<p>若某个Sentinel被半数以上的Sentinel设置为局部领头Sentinel，那么这个Sentinel成为领头Sentinel。若在给定时限内没有产生Sentinel，那么会在一段时间后再次进行选举，直到选出领头Sentinel为止。</p>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>领头Sentinel对已下线的主服务器执行故障转移操作包括三个步骤：</p>
<ol>
<li><p>在已下线主服务器的从服务器中挑选一个<strong>状态良好、数据完整</strong>的从服务器作为新的主服务器。</p>
<ol>
<li><p>排除处于下线或断线的从服务器。</p>
</li>
<li><p>排除最近5秒没有回复过领头Sentinel的INFO命令的从服务器。</p>
</li>
<li><p>排除与旧主服务器连接断开超过down-after-milliseconds * 10毫米的从服务器。</p>
</li>
<li><p>选择优先级最高的服务器。</p>
</li>
<li><p>选择复制偏移量最大的服务器。</p>
</li>
<li><p>选择运行ID最小的服务器。</p>
</li>
</ol>
</li>
<li><p>让其他从服务器复制新主服务器。</p>
</li>
<li><p>将旧主服务器设置为新主服务器的从服务器。</p>
</li>
</ol>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="CLUSTER-MEET命令"><a href="#CLUSTER-MEET命令" class="headerlink" title="CLUSTER MEET命令"></a>CLUSTER MEET命令</h2><p>刚开始时，每个节点都属于自己的集群，向一个节点发送CLUSTER MEET命令，可以让当前节点和目标节点进行握手，握手成功时，将ip和port指定的节点加入到当前节点所在的集群中，握手过程：</p>
<p><img src="/images/Redis/image-20200924232022113.png" alt="image-20200924232022113"></p>
<h2 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h2><p><strong>集群的整个数据库被分为16384（2^14）个槽（slot）</strong>，数据库中的每个键都属于其中某一个slot，每个节点负责处理若干个slot，当所有slot都有节点负责处理时，集群处于上线状态，否则处于下线状态（fail）。</p>
<ul>
<li>节点结构中的clusterNode.slots是一个16384位的二进制数组，记录了节点负责处理哪些slot。</li>
<li>集群状态结构中的clusterState.slots是一个clusterNode节点数组，记录了集群中16384个slot分别分配给了哪个节点。</li>
</ul>
<h2 id="集群命令执行过程"><a href="#集群命令执行过程" class="headerlink" title="集群命令执行过程"></a>集群命令执行过程</h2><p>当客户端向节点发送与某个键相关的命令时，节点得到键所属的slot，若该slot指派给了当前节点，则直接执行该命令，否则会向客户端返回一个<code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code>错误，指引客户端redirect到正确的节点，并再次发送命令。</p>
<p><img src="/images/Redis/image-20200924233646774.png" alt="image-20200924233646774"></p>
<h3 id="键所属slot的计算与存储"><a href="#键所属slot的计算与存储" class="headerlink" title="键所属slot的计算与存储"></a>键所属slot的计算与存储</h3><p>键所属的slot根据<code>CRC16(key) &amp; (16384 - 1)</code>进行计算，其中CRC16(key)用于计算键的CRC-16校验和。</p>
<p>除了将键值对保存在数据库之外，节点会用clusterState.slots_to_keys来保存slot和键之间的关系，<strong>跳跃表</strong>的<strong>score为slot号，member为键</strong>。</p>
<h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p>将任意数量已经指派的slot重新指派给另一个节点，并且slot相关的键值对数据也会移动过去。</p>
<p>重新分片是由Redis集群管理软件redis-trib负责执行的，对单个slot重新分片的步骤如下：</p>
<p><img src="/images/Redis/image-20200925000826229.png" alt="image-20200925000826229"></p>
<ol>
<li>redis-trib向目标节点发送命令<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>，让目标节点准备接受slot相关的键值对。</li>
<li>redis-trib向源节点发送命令<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code>，让源节点准备将slot相关的键值对迁移到目标节点。</li>
<li>redis-trib向源节点发送命令<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>，获得最多count个属于slot的键名。</li>
<li>对于步骤3获得的每个键名，redis-trib都向源节点发送命令<code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code>，原子性地迁移键的数据。</li>
<li>重复执行步骤3、4直到所有属于slot的键值对都迁移完毕。</li>
<li>redis-trib向集群中的任意一个节点发送命令<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code>，最终所有节点都会知道slot已经被指派给了目标节点。</li>
</ol>
<p>如果在重新分片期间，客户端需要访问一个属于正在迁移的slot的键，那么源节点首先在自己的数据库中进行查找，若没有找到，则返回一个<code>ASK &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code>，指引客户端redirect到目标节点执行命令。</p>
<h2 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h2><p>Redis集群的节点分为主节点和从节点，其中主节点用于处理slot，从节点用于复制某个主节点，并在复制的主节点下线时，代替下线主节点继续处理命令请求。</p>
<h3 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h3><p>命令<code>CLUSTER REPLICATE &lt;node_id&gt;</code>可以让当前节点称为node_id的从节点，并开始对主节点进行复制（相当于执行SLAVEOF命令）。</p>
<h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>集群中的每个节点会定期向其他节点发送<strong>PING消息</strong>，若某个节点没有在规定时间内返回PONG消息，则标记该节点为疑似下线（PFAIL），节点之间会通过相互发送消息的方式获取其他节点的状态信息，当半数以上负责处理slot的主节点都将某个主节点标记为疑似下线时，那么该节点将被标记为已下线（FAIL），并立即通知其他节点。</p>
<h3 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h3><p>当一个从节点发现自己复制的主节点已下线时，开始对主节点进行故障转移：</p>
<ol>
<li><p>选举一个从节点执行命令<code>SLAVEOF on one</code>，成为新的主节点。<strong>选举方式</strong>（与领头Sentinel选举基本一致）：</p>
<p>每个发现主节点已下线的从节点都会向集群广播一条命令，<strong>第一次</strong>收到该命令且<strong>正在负责处理slot的主节点</strong>会返回一条投票消息，若某个从节点收到的返回消息数量大于<strong>正在负责处理slot的主节点数量</strong>的一半时，该节点成为新主节点。</p>
<p>若在一个配置纪元里没有成功选举出一个新主节点，那么集群进入一个新的配置纪元再次进行选举。</p>
</li>
<li><p>新主节点撤销已下线主节点的所有slot指派，并将这些slot指派给自己。</p>
</li>
<li><p>新主节点向集群广播一条PONG消息，通知其他节点自己是新主节点。</p>
</li>
<li><p>新主节点开始接收和负责处理slot相关请求，故障转移完成。</p>
</li>
</ol>
<h1 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h1><h2 id="订阅与退订"><a href="#订阅与退订" class="headerlink" title="订阅与退订"></a>订阅与退订</h2><p>Redis将所有频道的订阅关系保存在服务器状态的<strong>pubsub_channels字典</strong>中，键是频道，值是订阅该频道的客户端链表。</p>
<h3 id="SUBSCRIBE"><a href="#SUBSCRIBE" class="headerlink" title="SUBSCRIBE"></a>SUBSCRIBE</h3><p>当客户端执行SUBSCRIBE命令订阅某个频道时，若该频道已存在，则将客户端加入到对应链表尾部，否则在字典中添加一个新频道，并将客户端加入到对应链表。</p>
<h3 id="UNSUBSCRIBE"><a href="#UNSUBSCRIBE" class="headerlink" title="UNSUBSCRIBE"></a>UNSUBSCRIBE</h3><p>当客户端执行UNSUBSCRIBE命令退订某个频道时，服务器会从对应链表中删除该客户端节点，若删除后为空链表，则将频道对应的键也从字典中删除。</p>
<h2 id="模式订阅与退订"><a href="#模式订阅与退订" class="headerlink" title="模式订阅与退订"></a>模式订阅与退订</h2><p>模式订阅可以通过模式匹配来定义满足该模式的所有频道，如<code>PSUBSCRIBE &quot;news.*&quot;</code>。</p>
<p>模式的订阅关系都被保存在服务器状态的<strong>pubsub_patterns链表</strong>里面，链表的每个节点记录了被订阅的模式和客户端。PSUBSCRIBE和PUNSUBSCRIBE命令分别添加和删除一个节点。</p>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>命令<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>将消息message发送给频道channel。</p>
<p>Redis服务器首先将消息发送给<strong>pubsub_channels字典</strong>中频道channel对应的所有订阅者，然后遍历<strong>pubsub_patterns链表</strong>，当遇到与channel频道相匹配的模式时，将消息发送给对应客户端。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务开始：<code>MULTI</code>命令。</p>
<p>命令入队：每个Redis客户端都有自己的事务状态，其中的事务队列来保存事务期间的多条命令。</p>
<p>事务执行：<code>EXEC</code>命令开始执行事务，服务器会遍历客户端的事务队列，执行队列中的所有命令，最后将结果返回给客户端。</p>
<h2 id="WATCH命令"><a href="#WATCH命令" class="headerlink" title="WATCH命令"></a>WATCH命令</h2><p><strong>WATCH命令是一个乐观锁</strong>，可以在EXEC命令执行之前调用来监视一些键的变化。</p>
<p>若在EXEC执行时，被WATCH监视的键发生了修改，服务器则拒绝执行事务，并向客户端返回空回复（nil）。</p>
<h3 id="WATCH原理"><a href="#WATCH原理" class="headerlink" title="WATCH原理"></a>WATCH原理</h3><p>Redis数据库中保存着一个<strong>watched_keys字典</strong>，该字典的键是被WATCH命令监视的键，值是监视该键的客户端链表。</p>
<p>对于SET、LPUSH、SADD、ZREM、DEL等会对数据库进行修改的命令，在执行之后会检查watched_keys字典是否存在刚刚操作的键，若存在，则打开将该键对应链表中的客户端的<strong>REDIS_DIRTY_CAS标识</strong>。而在EXEC执行时，服务器会根据客户端的REDIS_DIRTY_CAS状态来决定是否执行事务。</p>
<p>避免MULTI（开始事务）和EXEC（执行事务）执行之间，其他客户端操作当前客户端事务涉及的key。</p>
<h2 id="Redis中事务的性质"><a href="#Redis中事务的性质" class="headerlink" title="Redis中事务的性质"></a>Redis中事务的性质</h2><p>在Redis中，事务总是满足<strong>原子性，一致性和隔离性</strong>的，并且当Redis开启持久化模式时，也满足<strong>持久性</strong>。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>Redis事务队列中的命令要么全部执行，要么一个都不执行。但是Redis<strong>不支持事务回滚</strong>，即使事务队列中某个命令执行出现了错误，整个事务也会继续执行下去。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>Redis通过错误检测和一些设计来保证食物的一致性。</p>
<p><strong>入队错误：</strong>如果一个事务在命令入队时出现了命令不存在或命令格式错误的情况，Redis会拒绝执行该事务。</p>
<p><strong>执行错误：</strong>执行错误是一些不能在入队时被检查出来的错误。若事务在执行过程中发生了错误，服务器不会中断事务的执行。</p>
<p><strong>服务器停机：</strong>若Redis在执行事务的过程中停机，服务器要么无持久化机制，重启之后为空白数据库，要么根据RDB或者AOF文件恢复数据。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>Redis使用<strong>单线程模式</strong>来执行事务，因此Redis的隔离级别总是<strong>串行化</strong>的。</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>Redis只是简单的用队列包裹了一组Redis命令，没有为事务提供额外的持久化机制，因此Redis的持久性由Redis的持久化模式决定。</p>
<p>若Redis运行在无持久化、RDB持久化、AOF持久化（appendfsync值为everysec）下，事务不具有持久性。</p>
<p>若Redis运行在<strong>AOF持久化且appendfsync值为always</strong>，事务具有持久性。</p>
<p>或者在<strong>事务的最后，EXEC之前加上SAVE</strong>命令，可以保证事务的持久性。</p>
<h1 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h1><p>Redis在服务器嵌入Lua环境，客户端可以使用Lua脚本直接在服务器端原子地执行多个Redis命令。</p>
<h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><ul>
<li>slowlog-log-slower-than：执行时间超过指定微秒的命令会记录在日志上。</li>
<li>slowlog-max-len：最多保存多少条慢查询日志，<strong>链表保存，先进先出</strong>。</li>
</ul>
<h1 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h1><p>通过执行MONITOR命令，客户端可以将自己变为一个监视器。每当一个客户端向服务器发送一条命令时，服务器除了会处理命令之外，还会将命令信息发给monitors链表中的所有监视器。</p>
<h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><h2 id="缓存和数据库一致性问题"><a href="#缓存和数据库一致性问题" class="headerlink" title="缓存和数据库一致性问题"></a>缓存和数据库一致性问题</h2><p>使用缓存只能通过合适的策略来降低缓存和数据库之间不一致的概率，无法保证两者间的强一致性。</p>
<p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md" target="_blank" rel="noopener">https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md</a></p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>指对于会被高并发访问的若干个热点数据，在这个数据失效的瞬间，这些高并发访问直接落到了数据库上。</p>
<p>解决方法：</p>
<ul>
<li>设置热点数据永不过期，需要时再进行更新。</li>
<li>对热点数据加互斥锁，同时只能有一个线程访问数据库的数据，一个线程访问后重建缓存。</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>指某个时间点缓存数据大规模失效，此时请求就会直接到达数据库，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方法：</p>
<ul>
<li><p>设置热点数据永不过期，需要时再进行更新。</p>
</li>
<li><p>对数据的过期时间额外加上一个随机值，避免同时失效。</p>
</li>
<li><p>构建多级缓存。</p>
</li>
<li><p>对于集群Redis，可以将热点数据均匀分布在不同的Redis库中。</p>
</li>
</ul>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>指大量请求的key根本不存在于缓存中，导致请求直接到达数据库。</p>
<p>解决方法：</p>
<ul>
<li><p>在接口层过滤掉不合法的查询，如负数id。</p>
</li>
<li><p>布隆过滤器：把所有有效请求的值都存放在布隆过滤器中，通过布隆过滤器判断请求是否有效。</p>
<p><img src="/images/Redis/image-20200904164234280.png" alt="image-20200904164234280"></p>
<p>布隆过滤器由一个二进制数组和一系列Hash函数组成，当一个元素加入过滤器时，通过K个Hash函数将这个元素映射为K个下标，然后把二进制中对应位置置为1。</p>
</li>
<li><p>缓存无效key：查询数据库中也没用的数据时，返回一个key-null缓存到Redis中，并设置一个较短过期时间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式相关知识点</title>
    <url>/2020/07/25/%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>记录分布式相关知识点。</p>
<a id="more"></a>

<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p><a href="https://blog.csdn.net/huyaowei789/article/details/87873977" target="_blank" rel="noopener">https://blog.csdn.net/huyaowei789/article/details/87873977</a></p>
<p>任何一个分布式系统都无法同时满足<strong>CAP</strong>，最多只能同时满足两项：</p>
<ul>
<li>一致性（Consistency）：所有用户看到一致的数据。</li>
<li>可用性（Availability）：非故障的结点在合理的时间内返回合理的响应。</li>
<li>分区容错性（Partition tolerance）：容忍网络中断。</li>
</ul>
<h2 id="数据库实现分布式锁"><a href="#数据库实现分布式锁" class="headerlink" title="数据库实现分布式锁"></a>数据库实现分布式锁</h2><h3 id="基于数据库表实现"><a href="#基于数据库表实现" class="headerlink" title="基于数据库表实现"></a>基于数据库表实现</h3><p>利用主键冲突实现，当一个结点执行某个方法前，尝试向数据库中插入一条数据（如<strong>以方法名为唯一索引</strong>的数据），若插入成功，表示当前没有其他节点在执行相同方法，在方法执行完毕删除该行数据。</p>
<h3 id="基于数据库的排他锁实现"><a href="#基于数据库的排他锁实现" class="headerlink" title="基于数据库的排他锁实现"></a>基于数据库的排他锁实现</h3><p>在执行数据操作之前，使用<strong>for update</strong>查询为该数据加上排他锁，执行完数据操作后，通过commit释放所。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>依赖于数据库的可用性，而数据库是一个单点，一旦数据库不可用，会导致整个业务不可用。数据库可以采用双机部署、主备切换。</p>
</li>
<li><p>没有锁失效机制，一旦解锁失败，就会导致其他线程无法获取锁。可以通过一个字段记录失效时间，并且需要定时任务清除失效的数据。</p>
</li>
<li><p>非重入的。可以增加字段记录锁的机器编号和线程编号。</p>
</li>
</ul>
<h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><p>基于Redis的setnx()、expire()、getset()方法实现分布式锁。</p>
<ul>
<li>setnx(key, value)：setnx的含义是set if not exist，该方法具有原子性。通常key为锁名，value为超时时间。如果key不存在，则设置当前key成功，返回1。否则检查当前key是否过期，如果已过期，可以获得锁。</li>
<li>expire(key, timeout)：在Redis中设置key的过期时间，防止某个程序崩溃了无法释放锁。</li>
<li>getset(key, newValue)：该方法具有原子性，替换key的value为newValue并返回value。可以通过该方法实现锁的续时。</li>
</ul>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>性能高，但是实现复杂，且需要自己根据需求配置超时时间。</p>
<h2 id="Zookeeper实现分布式锁"><a href="#Zookeeper实现分布式锁" class="headerlink" title="Zookeeper实现分布式锁"></a>Zookeeper实现分布式锁</h2><h3 id="zk结点类型"><a href="#zk结点类型" class="headerlink" title="zk结点类型"></a>zk结点类型</h3><ul>
<li><p><strong>持久结点：</strong>默认的结点类型，创建结点的客户与zk断开连接后，结点依然存在。</p>
</li>
<li><p><strong>持久顺序结点：</strong>在创建结点时，zk根据创建的时间顺序给结点名称进行编号。</p>
</li>
<li><p><strong>临时结点：</strong>当创建结点的客户与zk断开连接后，临时结点会被删除。</p>
</li>
<li><p><strong>临时顺序结点：</strong>创建结点时，zk根据创建的时间顺序给结点名称进行编号。</p>
</li>
</ul>
<h3 id="锁过程"><a href="#锁过程" class="headerlink" title="锁过程"></a>锁过程</h3><p><strong>获取锁：</strong>在Zookeeper中创建一个持久结点Lock，当一个客户获取锁时，需要在Lock结点下创建一个临时顺序结点，若该临时顺序结点是最靠前的一个结点，则获取锁成功。否则向该结点的前一个结点注册<strong>Watcher</strong>来监听前一个结点的状态。</p>
<p><strong>释放锁：</strong>当最靠前的结点任务完成或者崩溃时，该结点会被删除，后面一个结点会收到通知，并再次检查自己是否是当前最考前的结点，如果是则该节点获取到锁。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>高可用，可重入，易实现。但是Zookeeper中只能通过leader结点创建和删除结点，因此创建结点（加锁）和删除结点（释放锁）的性能不如Redis。</p>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统</title>
    <url>/2020/09/19/%E6%9E%B6%E6%9E%84/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>高并发秒杀系统实战。</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><p><img src="/./images/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/image-20200919233729150.png" alt="image-20200919233729150"></p>
<h2 id="系统总览"><a href="#系统总览" class="headerlink" title="系统总览"></a>系统总览</h2><p><img src="/./images/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/image-20200919233712253.png" alt="image-20200919233712253"></p>
<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="两次MD5"><a href="#两次MD5" class="headerlink" title="两次MD5"></a>两次MD5</h2><p>用户端：MD5（明文+固定salt），防止明文密码在网络上传输。</p>
<p>服务端：MD5（前端+随机salt），防止数据库异常被他人破解密码。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>提交命令</title>
    <url>/2020/08/03/%E5%85%B6%E4%BB%96/%E6%8F%90%E4%BA%A4%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<a id="more"></a>

<p>git add .<br>git commit -m “some descrption”<br>git push origin hexo<br>hexo g -d</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>更换电脑时Hexo博客迁移流程</title>
    <url>/2021/12/31/%E5%85%B6%E4%BB%96/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E6%97%B6Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>更换电脑时Hexo博客迁移流程</p>
<a id="more"></a>

<ol>
<li>配置环境</li>
</ol>
<p>​	Mac环境下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install node</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取代码</li>
<li>进入代码根目录，安装模块</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>配置typora</li>
</ol>
<p><img src="/../images/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E6%97%B6Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E6%B5%81%E7%A8%8B/image-20211231232809498.png" alt="image-20211231232809498"></p>
<ol start="5">
<li>创建新文章</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">"title"</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>提交部署</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"some descrption"</span></span><br><span class="line">git push origin hexo</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/07/23/%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式是一套被反复使用、多数人知晓、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>模式&amp;藐视</th>
<th>包括</th>
</tr>
</thead>
<tbody><tr>
<td><strong>创建型模式</strong><br />创建对象的同时隐藏创建逻辑</td>
<td><strong>工厂模式</strong>（Factory Pattern）<br />抽象工厂模式（Abstract Factory Pattern）<br /><strong>单例模式</strong>（Singleton Pattern）<br />建造者模式（Builder Pattern）<br />原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td><strong>结构型模式</strong><br />关注类和对象的组合</td>
<td><strong>适配器模式</strong>（Adapter Pattern）<br />桥接模式（Bridge Pattern）<br />过滤器模式（Filter Pattern）<br />组合模式（Composite Pattern）<br />装饰器模式（Decorator Pattern）<br />外观模式（Facade Pattern）<br />享元模式（Flyweight Pattern）<br /><strong>代理模式</strong>（Proxy Pattern）</td>
</tr>
<tr>
<td><strong>行为型模式</strong><br />关注对象之间的通信</td>
<td>责任链模式（Chain of Responsibility Pattern）<br /><strong>命令模式</strong>（Command Pattern）<br />解释器模式（Interpreter Pattern）<br />迭代器模式（Iterator Pattern）<br />中介者模式（Mediator Pattern）<br />备忘录模式（Memento Pattern）<br /><strong>观察者模式</strong>（Observer Pattern）<br />状态模式（State Pattern）<br />空对象模式（Null Object Pattern）<br />策略模式（Strategy Pattern）<br />模板模式（Template Pattern）<br />访问者模式（Visitor Pattern）</td>
</tr>
<tr>
<td><strong>J2EE模式</strong><br />关注表示层</td>
<td>MVC模式（MVC Pattern）<br />业务代表模式（Business Delegate Pattern）<br />组合实体模式（Composite Entity Pattern）<br />数据访问对象模式（Data Access Object Pattern）<br />前端控制器模式（Front Controller Pattern）<br />拦截过滤器模式（Intercepting FIlter Pattern）<br />服务定位模式（Service Locator Pattern）<br />传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody></table>
<h1 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h1><ol>
<li>开闭原则：在程序需要扩展时，不能修改原有的代码，而应该借助接口和抽象类实现扩展性。</li>
<li>里氏代换原则：任何基类可以出现的地方，子类一定也可以出现。即子类继承实现了基类的所有功能。</li>
<li>依赖倒转原则：针对接口编程，依赖于抽象而不依赖于具体。</li>
<li>接口隔离原则：使用多个隔离的接口比使用单个接口好。即降低类之间的耦合度。</li>
<li>最少知道原则：一个实体应该尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
<li>合成复用原则：尽量使用合成&#x2F;聚合的方式，而不是使用继承。</li>
</ol>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><strong>作用：</strong>当对象存在一对多关系时，可使用观察者模式，如当一个对象（被观察者）被修改时，则会通知依赖它的对象（观察者）。</p>
<p><strong>关键代码</strong>：在被观察者类中有一个ArrayList存放观察者。</p>
<p><strong>应用实例：</strong>消息通知，广播等。</p>
<p><strong>优点：</strong>①观察者和被观察者是抽象耦合的。②建立了一套触发机制。</p>
<p><strong>缺点：</strong>①当观察者太多时，更新通知会花费很多时间。②如果观察者和被观察者之间有循环依赖的话，更新会触发循环循环调用，可能导致系统崩溃。③只能知道被观察者发生了变化，而无法知道是如何变化的。</p>
<p><strong>注意事项：</strong>如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p>
<p><strong>实现：</strong>使用三个类Subject、Observer和Client。Subject为被观察者类，Observer为观察者抽象类，Client为Observer的实体类。</p>
<h2 id="Subject类"><a href="#Subject类" class="headerlink" title="Subject类"></a>Subject类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">		notifyAllObservers();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">		observers.add(observer);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Observer observer : observers)&#123;</span><br><span class="line">			observer.update();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Observer抽象类"><a href="#Observer抽象类" class="headerlink" title="Observer抽象类"></a>Observer抽象类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> Subject subject;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Observer实体类"><a href="#Observer实体类" class="headerlink" title="Observer实体类"></a>Observer实体类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(subject.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p><strong>作用：</strong>结合两个独立的接口。</p>
<p><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。</p>
<p><strong>应用实例：</strong></p>
<p><strong>优点：</strong></p>
<p><strong>缺点：</strong></p>
<p><strong>注意事项：</strong></p>
<p><strong>实现：</strong></p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><strong>作用：</strong>在直接访问某个对象比较麻烦时，可以加一个对此对象的访问类。</p>
<p><strong>关键代码：</strong></p>
<p><strong>应用实例：</strong></p>
<p><strong>优点：</strong></p>
<p><strong>缺点：</strong></p>
<p><strong>注意事项：</strong></p>
<p><strong>实现：</strong>创建一个Image接口，一个实现了Image的实体类RealImage。ProxyImage是一个代理类，其中保存了一个RealImage对象。</p>
<h2 id="Image接口"><a href="#Image接口" class="headerlink" title="Image接口"></a>Image接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Image接口的实体类"><a href="#实现Image接口的实体类" class="headerlink" title="实现Image接口的实体类"></a>实现Image接口的实体类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        loadFromDisk(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying "</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading "</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> RealImage realImage;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxyImage</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> display&#123;</span><br><span class="line">        <span class="keyword">if</span>(realImage == <span class="keyword">null</span>)&#123;</span><br><span class="line">            realImage = <span class="keyword">new</span> RealImage(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        realImage.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPatternDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Image image = <span class="keyword">new</span> ProxyImage(<span class="string">"test.jpg"</span>);</span><br><span class="line">		<span class="comment">// 图像从磁盘加载</span></span><br><span class="line">		image.display();</span><br><span class="line">		<span class="comment">// 图像不需要从磁盘加载</span></span><br><span class="line">		image.display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p><strong>作用：</strong>在不同条件下需要不同实例时。</p>
<p><strong>关键代码：</strong>创建过程在子类执行。</p>
<p><strong>应用实例：</strong></p>
<p><strong>优点：</strong></p>
<p><strong>缺点：</strong></p>
<p><strong>注意事项：</strong></p>
<p><strong>实现：</strong>创建一个Shape接口和实现Shape的实体类，定义工厂类可根据给定信息生成对应的实体类。</p>
<h2 id="创建一个接口"><a href="#创建一个接口" class="headerlink" title="创建一个接口"></a>创建一个接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建接口的实体类"><a href="#创建接口的实体类" class="headerlink" title="创建接口的实体类"></a>创建接口的实体类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Rectangle"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Circle"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建一个工厂，基于给定信息生成对应的实体类对象"><a href="#创建一个工厂，基于给定信息生成对应的实体类对象" class="headerlink" title="创建一个工厂，基于给定信息生成对应的实体类对象"></a>创建一个工厂，基于给定信息生成对应的实体类对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p><strong>作用：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><strong>关键代码：</strong>私有化类的构造函数。</p>
<p><strong>应用实例：</strong></p>
<p><strong>优点：</strong></p>
<p><strong>缺点：</strong></p>
<p><strong>注意事项：</strong>getInstance()方法中需要使用同步锁synchronized防止多线程同时进入造成Instance被多次实例化。</p>
<p><strong>实现：</strong></p>
<h2 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h2><p>优点：第一次调用才初始化，避免浪费内存。</p>
<p>缺点：加锁影响效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>优点：没有加锁，执行效率高。</p>
<p>缺点：类加载时就初始化，浪费内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双检锁-x2F-双重校验锁"><a href="#双检锁-x2F-双重校验锁" class="headerlink" title="双检锁&#x2F;双重校验锁"></a>双检锁&#x2F;双重校验锁</h2><p>采用双锁机制，安全且在多线程情况下保持高性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglObjetc</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingleObject singleObject;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleObject == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleObjecy<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleObject == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleObject = <span class="keyword">new</span> SingleObject();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p><strong>作用：</strong></p>
<p><strong>关键代码：</strong></p>
<p><strong>应用实例：</strong></p>
<p><strong>实现：</strong></p>
<p><strong>优点：</strong></p>
<p><strong>缺点：</strong></p>
<p><strong>注意事项：</strong></p>
<h1 id="责任链模式（okhttp）"><a href="#责任链模式（okhttp）" class="headerlink" title="责任链模式（okhttp）"></a>责任链模式（okhttp）</h1><h1 id="主要参考资料"><a href="#主要参考资料" class="headerlink" title="主要参考资料"></a>主要参考资料</h1><p><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/design-pattern-intro.html</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟面试问答之经典网络模型二：Fast RCNN</title>
    <url>/2020/07/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/FastRCNN/</url>
    <content><![CDATA[<p>本文总结了面试过程中可能问到的关于Fast RCNN模型的一些问题。</p>
<p><a href="https://arxiv.org/abs/1504.08083" target="_blank" rel="noopener">论文地址：Fast R-CNN</a><br><img src="/./images/FastRCNN/1.jpg" alt="1"></p>
<center><b>图1 Fast RCNN网络结构图</b></center>

<a id="more"></a>

<h1 id="简述一下Fast-RCNN测试时的检测流程？"><a href="#简述一下Fast-RCNN测试时的检测流程？" class="headerlink" title="简述一下Fast RCNN测试时的检测流程？"></a>简述一下Fast RCNN测试时的检测流程？</h1><ol>
<li>使用Selective Search在输入图像上提取约2000个候选区域。</li>
<li>将原始图像输入卷积网络，获得最后一个池化层之前的特征图（16倍下采样）。</li>
<li>对于每个候选区域，RoI pooling层将候选区域定位到特征图中的对应区域产生RoI，然后将每个RoI转化为相同尺寸（7×7）。</li>
<li>通过全连接层将RoI转化为一维向量，分别输入并行的分类器和回归器。分类器由一个全连接层和Softmax组成，对每一个RoI输出20+1个类别概率。回归器输出通过一个全连接层对每一个RoI输出20×4维向量，即所有类别下回归RoI的位置和大小。</li>
</ol>
<h1 id="描述一下RoI-pooling的工作原理？"><a href="#描述一下RoI-pooling的工作原理？" class="headerlink" title="描述一下RoI pooling的工作原理？"></a>描述一下RoI pooling的工作原理？</h1><p>先将候选区域定位到特征图中的对应区域产生RoI，然后将RoI划分为H×W的区域，然后分别取每个区域的最大值代替该区域，从而将RoI尺寸调整为H×W。</p>
<h1 id="两次坐标量化是指什么？"><a href="#两次坐标量化是指什么？" class="headerlink" title="两次坐标量化是指什么？"></a>两次坐标量化是指什么？</h1><ol>
<li>第一次量化时将候选区域映射到特征图上时，需要将候选区域坐标除以16并取整。</li>
<li>第二次量化是指RoI pooling时，需要将RoI划分为H×W个部分，对左上角坐标采用向下取整，对右下角坐标采用向上取整。两次量化操作会引入误差，Mask RCNN中会解决这一问题。</li>
</ol>
<h1 id="Fast-RCNN是如何训练的？"><a href="#Fast-RCNN是如何训练的？" class="headerlink" title="Fast RCNN是如何训练的？"></a>Fast RCNN是如何训练的？</h1><ol>
<li>以VGG16为例，先在ImageNet上训练一个1000类的分类网络。</li>
<li>修改预训练后的网络结构，将最后一个池化层替换为RoI pooling层；将最后一个全连接层替换为并行的分类器和回归器；网络输入替换为图像+候选区域集合。</li>
<li>将修改后的网络在Pascal VOC上进行fine-tuning，定义IoU大于0.5的为正样本，IoU为0.1-0.5之间的为负样本，每次迭代时包括2张图像，每张图像随机采样16个正样本和48个负样本用于训练；采样0.5概率的水平翻转进行数据增强。</li>
<li>采用分类损失和回归损失的联合组成的多任务损失函数进行训练。</li>
</ol>
<h1 id="Fast-RCNN的损失函数是如何构成的？"><a href="#Fast-RCNN的损失函数是如何构成的？" class="headerlink" title="Fast RCNN的损失函数是如何构成的？"></a>Fast RCNN的损失函数是如何构成的？</h1><h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><p>Fast RCNN采用多任务损失函数，由分类损失和回归损失联合组成。分类采用交叉熵损失函数，回归采用Smooth L1损失函数。</p>
<h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><p>Fast RCNN的多任务损失函数如下：<br>$$L(p,u,t^u,v)&#x3D;L_{cls}(p,u)+\lambda [u\geq 1]L_{loc}(t^u,v)$$<br>其中，$L_{cls}(p,u)&#x3D;-logp_u$表示真实分类u的概率$p_u$的对数损失。$\lambda$用于平衡分类损失和回归损失，通常取1。$[u\geq 1]$为指示函数，$u\geq 1$时取1否则取0，即当p为负样本时忽略回归损失。$L_{loc}(t^u,v)$为四个Smooth L1损失的和，分别是两个平移量和两个缩放值（具体参考上一篇关于RCNN的博客）。Smooth L1损失函数如下所示：<br>$$Smooth_{L1}(x)&#x3D;\begin{cases} 0.5x^2 &amp; if&amp;#124;x&amp;#124;&lt;1 \\ &amp;#124;x&amp;#124;-0.5 &amp; otherwise \end{cases}$$<br>Smooth L1损失函数在x较大时（训练初期）采取L1损失函数形式，避免了L2损失在训练初期导数大的问题；在x较小（训练后期）时采取L2损失函数形式，避免了L1损失函数在训练后期导数大的问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>优点：Fast RCNN解决了RCNN的两大问题：①一次性提取特征然后对候选区域进行特征映射，实现特征共享，极大地节约了时间和空间消耗；②将RCNN的三个模型整合为一个模型，一次性进行分类和回归。</li>
<li>缺点：仍然存在与RCNN一样的问题，即使用Selective Search进行候选框提取。</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>目标检测</tag>
        <tag>经典网络</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟面试问答之经典网络模型八：CornerNet</title>
    <url>/2020/07/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CornerNet/</url>
    <content><![CDATA[<p>本文总结了面试过程中可能问到的关于CornerNet模型的一些问题。</p>
<p><img src="/./images/CornerNet/1.png" alt="1"></p>
<a id="more"></a>

<h1 id="介绍一下CornerNet的网络结构？"><a href="#介绍一下CornerNet的网络结构？" class="headerlink" title="介绍一下CornerNet的网络结构？"></a>介绍一下CornerNet的网络结构？</h1><ol>
<li><p>首先采用一个7×7卷积将输入图像尺寸缩小为原来的1&#x2F;4。</p>
</li>
<li><p>采用两个hourglass模块组成的Hourglass-104作为主干网络提取特征。</p>
</li>
<li><p>每个hourglass模块先通过一系列卷积下采样输入尺寸，然后逐步上采样恢复到输入尺寸大小。</p>
</li>
<li><p>主干网络后面有两个输出分支，分别是左上角关键点预测分支和右下角关键点预测分支。</p>
</li>
<li><p>每个分支通过corner pooling和一系列卷积产生3个输出</p>
<ul>
<li><p>Heatmaps：输出维度为H×W×C，表示C个类别下H×W个特征点是左上角（右下角）关键点的概率。</p>
</li>
<li><p>Embeddings：输出维度为H×W×1，每个特征点的embedding是一个一维标量，用于计算两个关键点之间的距离。</p>
</li>
<li><p>Offsets：输出维度为H×W×2，每个点输出两个坐标偏移量：</p>
<p><img src="/./images/CornerNet/2.png" alt="2"></p>
<p>其中$x_k$，$y_k$表示关键点k的坐标。设在heatmap上点$(x,y)$预测为corner，对应的offset为$\hat o&#x3D;(\Delta x, \Delta y)$，那么在原图上corner的坐标为</p>
<p>$$x_0&#x3D;\lfloor (x+\Delta x)n \rfloor,y_0&#x3D;\lfloor (y+\Delta y)n\rfloor$$</p>
</li>
</ul>
</li>
</ol>
<h1 id="CornerNet有什么特点？"><a href="#CornerNet有什么特点？" class="headerlink" title="CornerNet有什么特点？"></a>CornerNet有什么特点？</h1><p>CornerNet是一种Anchor-free的目标检测方法，它通过预测物体框的左上角和右下角两个关键点来定位物体。</p>
<h1 id="CornerNet的损失函数是如何计算的？"><a href="#CornerNet的损失函数是如何计算的？" class="headerlink" title="CornerNet的损失函数是如何计算的？"></a>CornerNet的损失函数是如何计算的？</h1><p>CornerNet的损失函数由四部分组成，论文中设置$\alpha&#x3D;\beta&#x3D;\gamma&#x3D;1$：</p>
<p>$$L&#x3D;L_{det}+\alpha L_{pull}+\beta L_{push}+\gamma L_{off}$$</p>
<p>$L_{det}$为分类损失，采用focal loss。训练时，当坐标(i,j)处是gt点且类别相同，则该坐标为正样本，其他均为负样本。损失函数中设置距离gt越近的负样本会贡献更小的loss：</p>
<p><img src="/./images/CornerNet/3.png" alt="3"></p>
<p>$L_{pull}$损失是为了将属于同一个目标的两个关键点的embedding拉的更近，$L_{push}$损失是为了将属于不同目标的两个关键点的embedding距离尽可能推开。</p>
<p><img src="/./images/CornerNet/4.png" alt="4"></p>
<p>$L_{off}$为坐标偏移损失，采用Smooth L1损失：</p>
<p><img src="/./images/CornerNet/5.png" alt="5"></p>
<h1 id="介绍一下corner-pooling？"><a href="#介绍一下corner-pooling？" class="headerlink" title="介绍一下corner pooling？"></a>介绍一下corner pooling？</h1><p><img src="/./images/CornerNet/6.png" alt="6"></p>
<p>考虑到左上角角点的右边有目标顶端的特征信息，左上角角点的下边有目标左侧的特征信息，因此如果左上角角点经过池化操作后能有这两个信息，那么就有利于该点的预测，这就有了corner pooling。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>目标检测</tag>
        <tag>经典网络</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟面试问答之经典网络模型三：Faster RCNN</title>
    <url>/2020/07/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/FasterRCNN/</url>
    <content><![CDATA[<p>本文总结了面试过程中可能问到的关于Faster RCNN模型的一些问题。</p>
<p><a href="https://arxiv.org/abs/1506.01497" target="_blank" rel="noopener">论文地址：Faster R-CNN</a><br><img src="/./images/FasterRCNN/1.png" alt="1"></p>
<center><b>图1 Faster RCNN网络结构图</b></center>

<a id="more"></a>

<h1 id="简述一下Faster-RCNN测试时的检测流程？"><a href="#简述一下Faster-RCNN测试时的检测流程？" class="headerlink" title="简述一下Faster RCNN测试时的检测流程？"></a>简述一下Faster RCNN测试时的检测流程？</h1><ol>
<li>调整输入图像尺寸为16的倍数。</li>
<li>使用CNN（以VGG16为例）提取特征图。</li>
<li>RPN（Region Proposal Network）在特征图上生成一系列anchor box，并通过两个分支分别判断anchor box是否包含物体以及粗略位置修正。</li>
<li>将特征图和anchor boxes一起输入到RoI pooling层，与Fast RCNN一样，对于每个anchor boxes，RoI pooling层将候选区域定位到特征图中的对应区域产生RoI，然后将每个RoI转化为相同尺寸（7×7）。</li>
<li>经过两个全连接+ReLU层将RoI转化为一维向量，分别输入并行的分类器和回归器。分类器由一个全连接层和Softmax组成，对每一个RoI输出80+1个类别概率。回归器输出通过一个全连接层对每一个RoI输出80×4维向量，即所有类别下回归RoI的位置和大小。</li>
</ol>
<h1 id="Faster-RCNN相对于Fast-RCNN的主要改进在什么地方？"><a href="#Faster-RCNN相对于Fast-RCNN的主要改进在什么地方？" class="headerlink" title="Faster RCNN相对于Fast RCNN的主要改进在什么地方？"></a>Faster RCNN相对于Fast RCNN的主要改进在什么地方？</h1><ol>
<li>Faster RCNN不再使用Selective Search提取候选区域，而是采用卷积网络（RPN）产生候选框。</li>
<li>RPN网络在生成候选框后会对候选框进行筛选，只保留可能包含物体的候选框（～300个），为后续计算节约计算成本。</li>
</ol>
<h1 id="介绍一下RPN网络？"><a href="#介绍一下RPN网络？" class="headerlink" title="介绍一下RPN网络？"></a>介绍一下RPN网络？</h1><p><img src="/./images/FasterRCNN/3.png" alt="3"></p>
<center><b>图2 RPN网络结构图</b></center>

<ol>
<li>首先通过一个3×3的卷积进一步集中特征信息，然后在特征图上的每个特征点生成9个anchor box（三个尺度，三个比例），把生成的anchor boxes分别送入分类分支和回归分支。</li>
<li>对于分类分支，通过一个1×1卷积+Softmax输出每个anchor box存在物体的概率。</li>
<li>对于回归分支，通过一个1×1卷积输出每个anchor box的粗略位置估计，包括2个平移量（$\Delta x$，$\Delta y$）和两个缩放量($S_h$，$S_w$)，具体参考前面关RCNN的博客。</li>
<li>最后Proposal层根据分类和回归分支结果筛选候选框。首先根据回归结果修正候选框位置，然后根据分类结果筛选出前k（6000）个存在物体概率最高的候选框，并去除尺寸较小的和超出边界的候选框，再使用NMS剔除重叠候选框（0.7阈值），最后将筛选结果（约300个）送入RoI pooling层。</li>
</ol>
<h1 id="Faster-RCNN是如何训练的？"><a href="#Faster-RCNN是如何训练的？" class="headerlink" title="Faster RCNN是如何训练的？"></a>Faster RCNN是如何训练的？</h1><ol>
<li>交替训练（论文采用）：Faster RCNN可以看做时Fast RCNN + RPN，可以将Fast RCNN和RPN单独进行训练，但这两部分共享VGG16部分。<br>① 首先在ImageNet上面预训练VGG16；<br>② 使用①中的VGG16参数结合RPN进行训练；<br>③ 使用①中的VGG16参数组成Fast RCNN，并利用训练后的RPN网络生成候选框来训练Fast RCNN；<br>④ 使用③中的VGG16参数并结合RPN进行训练，VGG16参数不更新。<br>⑤ 使用③中的VGG16参数Fast RCNN，并利用④中的RPN网络生成候选框来训练Fast RCNN，VGG16参数不更新。</li>
<li>近似联合训练：将Faster RCNN整体进行训练，包括四个损失函数，RPN二分类损失，RPN回归损失，最后的多分类损失和回归损失。</li>
</ol>
<h1 id="Faster-RCNN的损失函数是如何构成的？"><a href="#Faster-RCNN的损失函数是如何构成的？" class="headerlink" title="Faster RCNN的损失函数是如何构成的？"></a>Faster RCNN的损失函数是如何构成的？</h1><ol>
<li>对于RPN训练，定义IoU最大或者IoU大于0.7的候选框为正样本，IoU小于0.3的候选框为负样本，其余候选框舍弃，每张图片随机采样128个正样本和128个负样本用于训练，若正样本过少，则增加负样本，保持样本总数为256。RPN的多任务损失函数为：<br>$$L({p_i},{t_i})&#x3D;\frac {1}{N_{cls}}\sum_i L_{cls}(p_i,p_i^*)+\lambda \frac {1}{N_{reg}}\sum_i p_i^*L_{reg}(t_i,t_i^*)$$<br>其中，对于正样本$p_i^*&#x3D;1$，否则为0。$L({p_i},{t_i})&#x3D;-logp_i$表示第i个候选框含有物体的概率$p_i$的对数损失。$L_{loc}(t^u,v)$为四个Smooth L1损失的和，分别是两个平移量和两个缩放值（关于Smooth L1损失可参考上一篇关于Fast RCNN的博客）。</li>
<li>对于网络末端的分类器和回归器的训练，采用与Fast RCNN相同的损失函数。</li>
<li>实际上RPN的损失函数与Fast RCNN唯一的区别就在于一个是二分类，一个是多分类。此外，两者对于正负样本的划分有所区别。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>优点：Faster RCNN利用RPN生成候选框，舍弃了耗时的Selective Search方法，无论是检测速度和精度都得到了提升。</li>
<li>缺点：Faster RCNN的两阶段方法无法达到实时检测的效果。</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>目标检测</tag>
        <tag>经典网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础——Python 2.x与Python 3.x的主要区别</title>
    <url>/2020/07/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Python%EF%BC%9A2-x%E4%B8%8E3-x%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>本文总结了Python 2.x与Python 3.x的主要区别。</p>
<a id="more"></a>

<h1 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h1><p>print()函数取代print语句。</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>Python 2.x默认使用ASCII编码，不能直接输出中文，变量命名只能用英文。</p>
<p>Python 3.x默认使用UTF-8编码，可以直接输出中文，可以使用中文变量名。</p>
<h1 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算/"></a>除法运算<code>/</code></h1><p>Python 2.x，整数相除结果为整数，浮点数相除为浮点数。</p>
<p>Python 3.x，结果始终是浮点数。</p>
<h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><p>Python 2.x可以使用file(…)或者open(…)。</p>
<p>Python 3.x只能使用open(…)。</p>
<h1 id="xrange函数"><a href="#xrange函数" class="headerlink" title="xrange函数"></a>xrange函数</h1><p>Python 3.x取消了xrange函数，使用range函数完全代替。</p>
<h1 id="八进制字面量表示"><a href="#八进制字面量表示" class="headerlink" title="八进制字面量表示"></a>八进制字面量表示</h1><p>Python 2.x可以用01000或0o1000表示八进制512。</p>
<p>Python 3.x只可以使用0o1000。</p>
<h1 id="不等运算符"><a href="#不等运算符" class="headerlink" title="不等运算符"></a>不等运算符</h1><p>Python 2.x可以用<code>!=</code>或<code>&lt;&gt;</code>。</p>
<p>Python 3.x只能使用<code>!=</code>。</p>
<h1 id="Python-3-x使用更加严格的缩进"><a href="#Python-3-x使用更加严格的缩进" class="headerlink" title="Python 3.x使用更加严格的缩进"></a>Python 3.x使用更加严格的缩进</h1><p>Python 2.x中允许tab和space共存。</p>
<p>Python 3.x只能单独使用tab或者space。</p>
<h1 id="去掉了repr表达式"><a href="#去掉了repr表达式" class="headerlink" title="去掉了repr表达式"></a>去掉了repr表达式</h1><p>Python 2.x中反引号&#96;&#96;相当于repr函数的作用。</p>
<p>Python 3.x中去掉了&#96;&#96;的写法，只允许使用repr函数。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Python 3.x去掉了long类型，只有一种整形——int。新增了bytes类型。</p>
<h1 id="input和raw-input函数"><a href="#input和raw-input函数" class="headerlink" title="input和raw_input函数"></a>input和raw_input函数</h1><p>Python 2.x中raw_input会将所有输入数据当做字符串，返回值为字符串；而input输入时必须是一个合法的Python表达式。</p>
<p>Python 3.x只能使用input。</p>
<h1 id="map、filter和reduce"><a href="#map、filter和reduce" class="headerlink" title="map、filter和reduce"></a>map、filter和reduce</h1><p>Python 2.x中map，filter和reduce是内置函数，返回结果为列表。</p>
<p>Python 3.x中map和filter变成了类，返回结果为可迭代对象。reduce从全局挪到了functool模块中。</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>捕获异常的语法由<code>except exc, var</code>改为<code>except exc as var</code>。</p>
<p>Python 2.x中所有类型的对象都可以被抛出；Python 3.x中只有继承自BaseException的对象才可以被抛出。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟面试问答之经典网络模型七：SSD</title>
    <url>/2020/07/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/SSD/</url>
    <content><![CDATA[<p>本文总结了面试过程中可能问到的关于SSD模型的一些问题。</p>
<p><a href="https://arxiv.org/abs/1512.02325" target="_blank" rel="noopener">论文地址：Single Shot MultiBox Detector</a></p>
<p><img src="/./images/SSD/1.png"></p>
<center><b>图1 SSD与YOLOv1网络结构对比图</b></center>

<a id="more"></a>

<h1 id="SSD有哪些主要特点？"><a href="#SSD有哪些主要特点？" class="headerlink" title="SSD有哪些主要特点？"></a>SSD有哪些主要特点？</h1><ol>
<li><p>类似YOLO，将检测转化为回归，一次性完成定位与回归。</p>
</li>
<li><p>类似Faster RCNN，使用了先验框。</p>
<p><img src="/./images/SSD/2.png" alt="2"></p>
<center><b>图2 SSD详细网络结构图</b></center>
</li>
<li><p>利用了多尺度特征进行检测（300–&gt;38,19,10,5,3,1）。</p>
</li>
</ol>
<h1 id="SSD网络的输出是什么含义？"><a href="#SSD网络的输出是什么含义？" class="headerlink" title="SSD网络的输出是什么含义？"></a>SSD网络的输出是什么含义？</h1><p>SSD包括6个输出，分别是38×38×4×(4+21)，19×19×4×(4+21)，10×10×6×(4+21)，5×5×6×(4+21)，3×3×6×(4+21)，1×1×4×(4+21)，其中(4,4,6,6,6,4)表示该尺度下，每个格子预测的先验框数量，4表示预测的位置信息，21表示20个类别+背景的置信度。</p>
<h1 id="SSD的先验框是如何设置的？"><a href="#SSD的先验框是如何设置的？" class="headerlink" title="SSD的先验框是如何设置的？"></a>SSD的先验框是如何设置的？</h1><ol>
<li>以特征图每个格子的中心坐标为中心，生成一系列的同心先验框。</li>
<li>设置了m&#x3D;6个尺度的先验框，最底层特征图上的尺度为$S_{min}&#x3D;0.2$，最高层的为$S_{max}&#x3D;0.9$，其余层在0.2到0.9之间均等取值。$S_K$表示先验框与输入图像的比例。</li>
<li>每个尺度设置了4或6种（4,6,6,6,4,4）不同的长宽比$a_r\in{1,2,3,1&#x2F;2,1&#x2F;3}$，可以计算第k层的先验框的宽为$w_k^a&#x3D;s_k\sqrt{a_r}$，高为$h_k^a&#x3D;s_k&#x2F;\sqrt{a_r}$，此外还有一个边长为$\sqrt{S_kS_{k+1}}$的正方形框，因此每个格子产生6种框。</li>
</ol>
<h1 id="SSD中正负样本如何设定的？"><a href="#SSD中正负样本如何设定的？" class="headerlink" title="SSD中正负样本如何设定的？"></a>SSD中正负样本如何设定的？</h1><ol>
<li>对于每个ground-truth，找到与其IoU最大的先验框设为正样本，这样可以保证每个ground-truth都有一个先验框相匹配。</li>
<li>对于剩余未匹配的先验框，若与某个ground-truth的IoU大于阈值（0.5），则先验框为正样本，其余为负样本。这意味着某个ground-truth可能与多个先验框相匹配（YOLO中，一个ground-truth只有一个对应的先验框）。</li>
<li>训练时，将负样本按背景置信度（预测背景的置信度越小，误差越大）进行排序，选取最低的k个，保证正负样本比例为1:3。</li>
</ol>
<h1 id="SSD的是如何训练的？"><a href="#SSD的是如何训练的？" class="headerlink" title="SSD的是如何训练的？"></a>SSD的是如何训练的？</h1><ol>
<li><p>在ILSVRC上预训练VGG16。</p>
</li>
<li><p>类似于DeepLabv1，将VGG16的前两个全连接层替换为卷积层，并加入了空洞卷积。</p>
</li>
<li><p>采用0.9的Momentum。</p>
</li>
<li><p>采用水平翻转，随机裁剪，颜色扭曲，随机采取区域等数据增强方法。</p>
</li>
<li><p>损失函数由位置误差和分类置信度误差组成：</p>
<p><img src="/./images/SSD/3.png" alt="3"></p>
<p>位置误差采用Smooth L1损失，预测的$(\Delta x, \Delta y,S_w,S_h)$与RCNN系列中的定义一致。分类置信度误差采用softmax损失（交叉熵损失）。</p>
</li>
</ol>
<h1 id="测试时是SSD如何进行预测的？"><a href="#测试时是SSD如何进行预测的？" class="headerlink" title="测试时是SSD如何进行预测的？"></a>测试时是SSD如何进行预测的？</h1><ol>
<li>对于每个预测框，首先根据类别置信度确定其类别，并过滤掉置信度小于阈值或属于背景的预测框。</li>
<li>按置信度进行排序，保留top-k个预测框。</li>
<li>根据预测框的位置信息对预测框进行修正。</li>
<li>使用NMS过滤掉重叠较大的预测框。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/thisiszdy/article/details/89576389" target="_blank" rel="noopener">https://blog.csdn.net/thisiszdy/article/details/89576389</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>目标检测</tag>
        <tag>经典网络</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟面试问答之经典网络模型一：RCNN</title>
    <url>/2020/06/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/RCNN/</url>
    <content><![CDATA[<p>本文总结了面试过程中可能问到的关于RCNN模型的一些问题。</p>
<p><a href="https://arxiv.org/abs/1311.2524" target="_blank" rel="noopener">论文地址：Rich Feature Hierarchies for Accurate Object Detection and Semantic Segmentation</a><br><img src="/./images/RCNN/1.png" alt="1"></p>
<center><b>图1 RCNN网络结构图</b></center>

<a id="more"></a>

<h1 id="简述一下RCNN测试时的检测流程？"><a href="#简述一下RCNN测试时的检测流程？" class="headerlink" title="简述一下RCNN测试时的检测流程？"></a>简述一下RCNN测试时的检测流程？</h1><ol>
<li>使用Selective Search在输入图像上提取约2000个候选区域。</li>
<li>缩放每个候选区域到固定尺寸大小，227×227。</li>
<li>将每个候选区域分别输入CNN网络提取特征。</li>
<li>使用二分类SVM分别对每个候选区域进行分类。</li>
<li>对每个类别进行NMS（非极大抑制）。</li>
<li>使用线性回归器分别修正每个候选区域的位置。</li>
</ol>
<h1 id="RCNN是如何对候选区域进行缩放的？"><a href="#RCNN是如何对候选区域进行缩放的？" class="headerlink" title="RCNN是如何对候选区域进行缩放的？"></a>RCNN是如何对候选区域进行缩放的？</h1><p>各向异性缩放且padding&#x3D;16。</p>
<h1 id="分别介绍一下各向异性和各项同性的缩放？"><a href="#分别介绍一下各向异性和各项同性的缩放？" class="headerlink" title="分别介绍一下各向异性和各项同性的缩放？"></a>分别介绍一下各向异性和各项同性的缩放？</h1><ol>
<li>各向异性直接把图像的宽高拉伸到目标尺寸。</li>
<li>各项同性先按原图像比例进行缩放，然后在再填充到目标尺寸。</li>
</ol>
<h1 id="RCNN的CNN网络是如何训练的？"><a href="#RCNN的CNN网络是如何训练的？" class="headerlink" title="RCNN的CNN网络是如何训练的？"></a>RCNN的CNN网络是如何训练的？</h1><p><img src="/./images/RCNN/2.jpg" alt="2"></p>
<center><b>图2 AlexNet网络结构图</b></center>

<ol>
<li>使用AlexNet(网络结构如<strong>图2</strong>所示)或其他主干网络（如VGG16），先在ILSVRC2012的图像分类数据集上进行预训练，最后一层输出维度为1000。</li>
<li>将AlexNet最后的1000维Softmax层替换为随机初始化的20+1维Softmax层，其余层使用预训练得到的参数进行初始化，在PASCAL VOC数据集上对预训练后的AlexNet进行fine-tuning（微调）。</li>
<li>Fine-tuning时，定义与ground-truth的IoU大于0.5的候选区域为正样本，否则为负样本（即背景样本），在每次迭代时，采样32个正样本和96个负样本组成一个128的mini-batch。</li>
</ol>
<h1 id="RCNN的SVM分类器是如何训练的？"><a href="#RCNN的SVM分类器是如何训练的？" class="headerlink" title="RCNN的SVM分类器是如何训练的？"></a>RCNN的SVM分类器是如何训练的？</h1><ol>
<li>共训练20个二分类SVM。</li>
<li>使用fine-tuning训练后且去掉最后softmax层的AlexNet提取候选区域的特征作为SVM的输入。</li>
<li>定义IoU小于0.3的候选区域为负样本，并进行难负样本挖掘，完整包含物体（IoU&#x3D;1）的候选区域为正样本，其余样本舍弃。</li>
</ol>
<h1 id="RCNN的线性回归器是如何训练的？"><a href="#RCNN的线性回归器是如何训练的？" class="headerlink" title="RCNN的线性回归器是如何训练的？"></a>RCNN的线性回归器是如何训练的？</h1><ol>
<li>共训练20×4个回归器，正则项系数$\lambda$&#x3D;10000。</li>
<li>输入为AlexNet的第一个全连接层的4096维输出（这里有点问题，论文里面说的是Pool 5，而我理解的Pool 5的输出时6×6×256的），输出为中心点坐标的平移量和宽高的缩放值。</li>
<li>定义IoU大于0.6的样本作为正样本用于训练。</li>
</ol>
<h1 id="Fine-tuning后的AlexNet的输出为21维，已经对各个候选区域进行了分类，为什么还要使用SVM进行分类呢？（或为什么不在AlexNet最后使用Softmax进行分类？）"><a href="#Fine-tuning后的AlexNet的输出为21维，已经对各个候选区域进行了分类，为什么还要使用SVM进行分类呢？（或为什么不在AlexNet最后使用Softmax进行分类？）" class="headerlink" title="Fine-tuning后的AlexNet的输出为21维，已经对各个候选区域进行了分类，为什么还要使用SVM进行分类呢？（或为什么不在AlexNet最后使用Softmax进行分类？）"></a>Fine-tuning后的AlexNet的输出为21维，已经对各个候选区域进行了分类，为什么还要使用SVM进行分类呢？（或为什么不在AlexNet最后使用Softmax进行分类？）</h1><ol>
<li>对AlexNet进行fine-tuning时采用的IoU阈值较小，被分为正样本的候选区域可能只包含部分物体，分类精度较低。</li>
<li>SVM训练时定义完全包含物体的候选区域才是正样本，分类精度较高。因此，使用SVM能够提高分类精度。</li>
</ol>
<h1 id="为什么fine-tuning训练时和SVM训练时的IoU阈值不一样？"><a href="#为什么fine-tuning训练时和SVM训练时的IoU阈值不一样？" class="headerlink" title="为什么fine-tuning训练时和SVM训练时的IoU阈值不一样？"></a>为什么fine-tuning训练时和SVM训练时的IoU阈值不一样？</h1><ol>
<li>Fine-tuning训练时，若IoU阈值设置过高，则可用于的训练样本较少（正样本减少，负样本为正样本的三倍），并且此时AlexNet已进行预训练，易由于样本过少而产生过拟合。因此，设置0.5的IoU阈值只是为了增加可用于训练的样本数量，避免过拟合。  </li>
<li>SVM训练时，为了达到进一步提高分类精度的目的，需要设置更为严格的正负样本分类规则。</li>
</ol>
<h1 id="回归器是如何进行边界框回归的？"><a href="#回归器是如何进行边界框回归的？" class="headerlink" title="回归器是如何进行边界框回归的？"></a>回归器是如何进行边界框回归的？</h1><h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><p>通过预测候选区域中心点坐标的平移量$\Delta x$，$\Delta y$和宽高的缩放值$S_w$，$S_h$来回归边界框。因此对于每个类别，需要4个回归器分别回归$\Delta x$，$\Delta y$，$S_w$，$S_h$，整个模型就包括20×4个回归器。</p>
<h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><p>定义$P&#x3D;(P_x,P_y,P_w,P_h)$表示候选区域的中心坐标和宽高，$G&#x3D;(G_x,G_y,G_w,G_h)$表示ground-truth的中心坐标和宽高。预测$d_*(P)$（$*$表示$x$，$y$，$w$，$h$，下同）得到平移量$\Delta x&#x3D;P_wd_x(P)$，$\Delta y&#x3D;P_hd_y(P)$和缩放值$S_w&#x3D;exp(d_w(P))$，$S_h&#x3D;exp(d_h(P))$，目标是使变换后的P与G更接近。<br>定义$\widehat{G}&#x3D;(\widehat{G}_x,\widehat{G}_y,\widehat{G}<em>w,\widehat{G}<em>h)$表示变换后的$P$，其中：<br>$$\widehat{G}<em>x&#x3D;P_wd_x(P)+P_x$$<br>$$\widehat{G}<em>y&#x3D;P_hd_y(P)+P_y$$<br>$$\widehat{G}<em>w&#x3D;P_wexp(d_w(P))$$<br>$$\widehat{G}<em>h&#x3D;P_hexp(d_h(P))$$<br>回归器的输入是AlexNet提取的候选区域特征，表示为$\phi(P)$，令$d</em>*(P)&#x3D;w^T</em>*\Phi(P)$，$w</em>*$就是需要学习的线性变换参数了，可以得到：<br>$$w^T_x\Phi(P)&#x3D;d_x(P)&#x3D;(\widehat{G}<em>x-P_x)&#x2F;P_w$$<br>$$w^T_y\Phi(P)&#x3D;d_y(P)&#x3D;(\widehat{G}<em>y-P_y)&#x2F;P_h$$<br>$$w^T_w\Phi(P)&#x3D;d_w(P)&#x3D;log(\widehat{G}<em>w&#x2F;P_w)$$<br>$$w^T_h\Phi(P)&#x3D;d_h(P)&#x3D;log(\widehat{G}<em>h&#x2F;P_h)$$<br>定义$t</em>*$为：<br>$$t_x&#x3D;(G_x-P_x)&#x2F;P_w$$<br>$$t_y&#x3D;(G_y-P_y)&#x2F;P_h$$<br>$$t_w&#x3D;log(G_w&#x2F;P_w)$$<br>$$t_h&#x3D;log(G_h&#x2F;P_h)$$<br>目标是使P的映射$\widehat{G}$尽量接近$G$，通过以下优化损失函数求解$w</em>*$：<br>$$w</em>*&#x3D;\underset{\widehat{w}</em>*}{argmin}\sum(t</em>*^i-\widehat{w}</em>*^T\phi(P^i))^2+\lambda&amp;#124;&amp;#124;\widehat{w}</em>*&amp;#124;&amp;#124;^2$$<br>可通过最小二乘法或梯度下降求解该问题。由此也可以看出，对于每个类别，需要4个回归器分别回归$\Delta x$，$\Delta y$，$S_w$，$S_h$，整个模型就包括20×4个回归器。</p>
<h1 id="回归器为什么不直接预测平移量-Delta-x-和-Delta-y-的值，而是先预测-d-x-P-和-d-y-P-，然后分别乘以-P-w-和-P-h-，间接求出-Delta-x-和-Delta-y-？"><a href="#回归器为什么不直接预测平移量-Delta-x-和-Delta-y-的值，而是先预测-d-x-P-和-d-y-P-，然后分别乘以-P-w-和-P-h-，间接求出-Delta-x-和-Delta-y-？" class="headerlink" title="回归器为什么不直接预测平移量$\Delta x$和$\Delta y$的值，而是先预测$d_x(P)$和$d_y(P)$，然后分别乘以$P_w$和$P_h$，间接求出$\Delta x$和$\Delta y$？"></a>回归器为什么不直接预测平移量$\Delta x$和$\Delta y$的值，而是先预测$d_x(P)$和$d_y(P)$，然后分别乘以$P_w$和$P_h$，间接求出$\Delta x$和$\Delta y$？</h1><p>回归器的输入是候选区域的特征，而每个候选区域在提取特征后的大小时相同的，若是直接预测平移量$\Delta x$和$\Delta y$的值，那么对于两个内容相差无几，但是尺寸不一样的图像，会得到相同平移量，这显然是有问题的。而分别乘候选区域的宽高$P_w$和$P_h$相当于进行归一化，即尺寸大的候选区域预测的平移量大，尺寸小的候选区域的平移量小。</p>
<h1 id="回归器预测宽高的缩放值为什么要采用exp？"><a href="#回归器预测宽高的缩放值为什么要采用exp？" class="headerlink" title="回归器预测宽高的缩放值为什么要采用exp？"></a>回归器预测宽高的缩放值为什么要采用exp？</h1><p>保证预测值大于0.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>优点：RCNN引入CNN提取特征，取代手工设计特征，并提升了检测速度；采用了迁移学习的思想，先在大数据集上对模型进行预训练，然后在目标数据集上面进行fine-tuning。</li>
<li>缺点：RCNN使用Selection Search提取2000个候选区域，不够精确；需要对每个候选区域单独提取特征，无法共享特征，且内存占用和耗时较大；训练过程分为三个阶段，繁琐且耗时较大。</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>目标检测</tag>
        <tag>经典网络</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟面试问答之经典网络模型四：YOLOv1</title>
    <url>/2020/07/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/yolov1/</url>
    <content><![CDATA[<p>本文总结了面试过程中可能问到的关于YOLOv1模型的一些问题。</p>
<p><a href="https://arxiv.org/abs/1506.02640" target="_blank" rel="noopener">论文地址：You Only Look Once: Unified, Real-Time Object Detection</a></p>
<p><img src="/./images/yolov1/1-1598799595413.png" alt="1"></p>
<center><b>图1 YOLOv1网络结构图</b></center>

<a id="more"></a>

<h1 id="简述一下YOLOv1测试时的检测流程？"><a href="#简述一下YOLOv1测试时的检测流程？" class="headerlink" title="简述一下YOLOv1测试时的检测流程？"></a>简述一下YOLOv1测试时的检测流程？</h1><ol>
<li>调整输入图像尺寸为448×448×3。</li>
<li>经过24层卷积输出7×7×1024特征图（64×下采样），再通过一个全连接层输出4096维特征，最后经过一个全连接层输出S×S×30的特征图。（Fast YOLO包括9个卷积）</li>
<li>通过NMS筛选最终结果，NMS的<code>score=某个类别的概率×置信度</code>。</li>
</ol>
<h1 id="YOLOv1的创新点有哪些？"><a href="#YOLOv1的创新点有哪些？" class="headerlink" title="YOLOv1的创新点有哪些？"></a>YOLOv1的创新点有哪些？</h1><ol>
<li>将检测问题转化为回归问题，同时输出预测框的坐标信息和类别概率。</li>
<li>没有提取候选区域的过程。</li>
</ol>
<h1 id="网络最后输出7×7×30特征图的含义？"><a href="#网络最后输出7×7×30特征图的含义？" class="headerlink" title="网络最后输出7×7×30特征图的含义？"></a>网络最后输出7×7×30特征图的含义？</h1><p>YOLOv1将图片划分为7×7个格子，每个格子负责预测中心点落在该格子区域的物体，每个格子预测两个矩形框。每个格子最后输出30个预测值，包括两个矩形框的位置信息<code>(x, y, w, h)</code>和置信度，以及20个类别的概率。</p>
<h1 id="YOLOv1是如何训练的？"><a href="#YOLOv1是如何训练的？" class="headerlink" title="YOLOv1是如何训练的？"></a>YOLOv1是如何训练的？</h1><ol>
<li><p>在ImageNet上对前20个卷积层进行预训练，具体地，训练时输入尺寸为224×224，网络结构为前20个卷积层+平均池化层+1000全连接层。</p>
</li>
<li><p>添加4个卷积层和两个全连接层，第一个全连接层后添加一个0.5的dropout层。输入尺寸为448×448，激活函数采用Leaky-ReLU（最后一层使用线性激活函数），优化方法采用0.9的Momentum，数据增强采用随机缩放，随机截取，随机调整曝光度和饱和度。</p>
</li>
<li><p>Loss函数由五个平方和误差（L2损失）组成：</p>
<p><img src="/./images/yolov1/2-1598799622298.png" alt="2"></p>
<p>其中$\lambda_{coord}&#x3D;5$，$\lambda_{noobj}&#x3D;0.5$，由于含有物体的格子较少，因此加大含有物体的格子的损失贡献。</p>
<ul>
<li>第一行为与ground-truth的IoU较大的预测框的中心点坐标损失；</li>
<li>第二行为与ground-truth的IoU较大的预测框的宽高损失，取根号是为了消除大尺寸框与小尺寸框之间的差异；</li>
<li>第三行和第四行是两个预测框的置信度损失，若格子不含物体则置信度为0，否则为IoU；</li>
<li>第五行为格子的类别损失。</li>
</ul>
<p>对于有物体的格子，需要计算分类损失，两个框的置信度损失，IoU较大的框的位置损失。</p>
<p>对于没物体的格子，只需要计算两个框的置信度损失。</p>
</li>
</ol>
<h1 id="YOLOv1回归的坐标值是什么含义？"><a href="#YOLOv1回归的坐标值是什么含义？" class="headerlink" title="YOLOv1回归的坐标值是什么含义？"></a>YOLOv1回归的坐标值是什么含义？</h1><p>$(x,y)$是格子左上角坐标的偏移值（0-1），$(w,h)$预测的是预测框的宽高与原始图像宽高的比值（0-1）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>YOLOv1具有运行速度快，背景误检率等优点，但由于其设置，每个格子最多只能检测一个物体，导致易漏检中心距离近的物体，召回率低，位置准确性较差。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>目标检测</tag>
        <tag>经典网络</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟面试问答之经典网络模型五：YOLOv2</title>
    <url>/2020/07/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/yolov2/</url>
    <content><![CDATA[<p>本文总结了面试过程中可能问到的关于YOLOv2模型的一些问题。</p>
<p><a href="https://arxiv.org/abs/1612.08242" target="_blank" rel="noopener">论文地址：YOLO9000: Better, Faster, Stronger</a><br><img src="/./images/yolov2/1.png"></p>
<center><b>图1 YOLOv2与YOLOv1技巧对比图</b></center>

<a id="more"></a>

<h1 id="YOLOv2采用了哪些技巧？"><a href="#YOLOv2采用了哪些技巧？" class="headerlink" title="YOLOv2采用了哪些技巧？"></a>YOLOv2采用了哪些技巧？</h1><ol>
<li>BN层代替Dropout层。</li>
<li>高分辨率的预训练：预训练时，先使用224×224的输入尺寸训练160个epochs，再使用448×448的输入尺寸训练10个epochs。</li>
<li>使用anchor boxes预测边界框：输入尺寸调整为416×416，输出特征图尺寸为13×13(32倍下采样），准确率下降但是召回率提高。</li>
<li>K-means聚类生成anchor box尺寸：聚类的距离函数为$d(box,centroid)&#x3D;1-IoU(box,centroid)$，若采用欧氏距离会使得尺寸大的框误差也大。实验表明k&#x3D;5时，在召回率和模型复杂的直接平衡性较好。</li>
<li>直接位置预测：预测相对锚框所属格子左上角坐标的偏移量$(b_x,b_y)$，以及与anchor box宽高的e的指数比例$(b_w,b_h)$，比RCNN系列采用的位置预测方法更易学习。</li>
<li>细粒度特征：类似ResNet，将最后一个26×26的特征图连接到最后一个13×13的特征图上。具体地，首先通过1×1卷积将26×26×512减低通道数为26×26×64，再拆分成4个13×13×64并拼接为13×13×256，然后与13×13×1024进行连接生成13×13×(256+1024)的特征图。</li>
<li>多尺度训练：每隔10个batch随机从{320,352,384,…,608}中选择一个尺度作为输入图像的尺寸。</li>
</ol>
<h1 id="YOLOv2的网络结构有哪些改进？"><a href="#YOLOv2的网络结构有哪些改进？" class="headerlink" title="YOLOv2的网络结构有哪些改进？"></a>YOLOv2的网络结构有哪些改进？</h1><p><img src="/./images/yolov2/2.png" alt="2"></p>
<center><b>图2 Darknet19网络结构图</b></center>

<ol>
<li><p>预训练时，如图2所示，Darknet 19包含19个卷积层（YOLOv1网络包含24个卷积层和2个全连接层）。</p>
<p><img src="/./images/yolov2/3.png" alt="3"></p>
<center><b>图2 YOLOv2网络结构图</b></center>
</li>
<li><p>用于检测时，如图3所示，首先添加三个3×3的卷积，然后输出特征图与细粒度特征中提到的跳跃连接进行拼接，再通过一个3×3卷积调整通道数，最后通过一个1×1卷积输出13×13×125的检测结果，对于13×13个格子，每个格子输出5×25维向量，其中5表示每个格子有五个anchor boxes，25包括20个类别概率，4个位置预测和1个置信度。</p>
</li>
<li><p>预训练时，先使用224×224的输入尺寸训练160个epochs，再使用448×448的输入尺寸训练10个epochs。</p>
</li>
</ol>
<h1 id="YOLOv2的样本是如何设置的？"><a href="#YOLOv2的样本是如何设置的？" class="headerlink" title="YOLOv2的样本是如何设置的？"></a>YOLOv2的样本是如何设置的？</h1><p>类似于YOLOv1，对于一个ground-truth，包含其中心点的格子的5个anchor boxes负责预测该物体框，只有与ground-truth的IoU最大的anchor box会用于计算loss。YOLOv2不再对宽高取根号。与ground-truth的IoU最大或大于0.6的anchor box为正样本。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/zijin0802034/article/details/77097894" target="_blank" rel="noopener">https://blog.csdn.net/zijin0802034/article/details/77097894</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35325884" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35325884</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>目标检测</tag>
        <tag>经典网络</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟面试问答之经典网络模型六：YOLOv3</title>
    <url>/2020/07/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/yolov3/</url>
    <content><![CDATA[<p>本文总结了面试过程中可能问到的关于YOLOv3模型的一些问题。</p>
<p><a href="https://arxiv.org/abs/1804.02767" target="_blank" rel="noopener">论文地址：YOLOv3: An Incremental Improvement</a><br><img src="/./images/yolov3/1.png" alt="1"></p>
<center><b>图1 Darknet-53网络结构图</b></center>

<a id="more"></a>

<h1 id="YOLOv3在有哪些主要改进？"><a href="#YOLOv3在有哪些主要改进？" class="headerlink" title="YOLOv3在有哪些主要改进？"></a>YOLOv3在有哪些主要改进？</h1><ol>
<li><p>Darknet-53代替Darknet-19，使用了残差模块，步长为2的卷积层代替池化层进行下采样。</p>
<p><img src="/./images/yolov3/3.jpg" alt="3"></p>
<center><b>图2 YOLOv3网络结构图</b></center>
</li>
<li><p>采用了多尺度结构，在获得32倍下采样特征图后，又开始对特征图进行上采样，并与前面的16倍下采样特征图连接，然后继续对特征图进行上采样，并与前面的8倍下采样特征图连接。分别在三个尺度（8,16,32）的特征图上进行检测，输出分别为13×13×3×(4+1+80)，26×26×3×(4+1+80)，52×52×3×(4+1+80)。</p>
</li>
<li><p>使用独立的logistic分类器（sigmoid）代替softmax分类器进行分类。</p>
</li>
</ol>
<h1 id="YOLOv3在anchor-boxes方面有什么改进？"><a href="#YOLOv3在anchor-boxes方面有什么改进？" class="headerlink" title="YOLOv3在anchor boxes方面有什么改进？"></a>YOLOv3在anchor boxes方面有什么改进？</h1><p>由于YOLOv3采用了多尺度预测，anchor boxes的设计也做了相应改进。同样是使用k-means进行聚类，YOLOv3聚类了3个尺度，每个尺度聚类了3种尺寸的anchor boxes。</p>
<h1 id="YOLOv3的损失函数有哪些改进？"><a href="#YOLOv3的损失函数有哪些改进？" class="headerlink" title="YOLOv3的损失函数有哪些改进？"></a>YOLOv3的损失函数有哪些改进？</h1><p>置信度和类别用交叉熵损失替换了平方和损失。为了提高小物体的损失贡献，位置回归损失会乘以系数(2-w×h)。</p>
<p><img src="/./images/yolov3/2-1596723997996.png" alt="2"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/leonardohaig/article/details/90346325" target="_blank" rel="noopener">https://blog.csdn.net/leonardohaig/article/details/90346325</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>目标检测</tag>
        <tag>经典网络</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer</title>
    <url>/2020/09/11/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/</url>
    <content><![CDATA[<p>《剑指Offer》关键算法题思路总结。</p>
<a id="more"></a>

<h1 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03 数组中重复的数字"></a>03 数组中重复的数字</h1><p><img src="/./images/%E5%89%91%E6%8C%87Offer/image-20200911201834565.png" alt="image-20200911201834565"></p>
<p><strong>思路：</strong>将数字归位到对应位置，出现重复数字时返回。</p>
<h1 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04 二维数组中的查找"></a>04 二维数组中的查找</h1><p><img src="/./images/%E5%89%91%E6%8C%87Offer/image-20200911202033610.png" alt="image-20200911202033610"></p>
<p><strong>思路：</strong>从右上角开始查找，大于目标值则左移，小于目标值则下移。</p>
<h1 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06 从尾到头打印链表"></a>06 从尾到头打印链表</h1><p><img src="/./images/%E5%89%91%E6%8C%87Offer/image-20200911202545515.png" alt="image-20200911202545515"></p>
<p><strong>思路：</strong></p>
<ul>
<li>使用栈保存元素。</li>
<li>递归打印。</li>
</ul>
<h1 id="09-两个栈实现队列"><a href="#09-两个栈实现队列" class="headerlink" title="09 两个栈实现队列"></a>09 两个栈实现队列</h1><p><img src="/./images/%E5%89%91%E6%8C%87Offer/image-20200911202826857.png" alt="image-20200911202826857"></p>
<p><strong>思路：</strong>添加元素时直接添加到第一个栈；弹出元素时，若第二个栈为空，则将第一个栈中的元素全部加入到第二个元素，然后弹出第二个栈的元素。</p>
<h1 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11 旋转数组的最小数字"></a>11 旋转数组的最小数字</h1><p><img src="/./images/%E5%89%91%E6%8C%87Offer/image-20200911213115815.png" alt="image-20200911213115815"></p>
<p><strong>思路：</strong>二分查找。nums[mid] &gt; nums[r]时，l &#x3D; mid + 1；nums[mid] &lt;&#x3D; nums[r]时，r–。</p>
<h1 id="14-剪绳子Ⅰ"><a href="#14-剪绳子Ⅰ" class="headerlink" title="14 剪绳子Ⅰ"></a>14 剪绳子Ⅰ</h1><p><img src="/./images/%E5%89%91%E6%8C%87Offer/image-20200911223248798.png" alt="image-20200911223248798"></p>
<p><strong>思路：</strong>找规律。当n &lt;&#x3D; 6时，结果分别为0,0,1,2,4,6,9；当n &gt; 6时，结果为dp[n - 3] * 3。 </p>
<h1 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15 二进制中1的个数"></a>15 二进制中1的个数</h1><p><img src="/./images/%E5%89%91%E6%8C%87Offer/image-20200912001326318.png" alt="image-20200912001326318"></p>
<p><strong>思路：</strong></p>
<ul>
<li><p>使用n &amp; 1 &#x3D;&#x3D; 1判断末尾是否为1，然后无符号右移n &gt;&gt;&#x3D; 1。</p>
</li>
<li><pre><code class="java">while(n != 0) {
    res++;
    n = n &amp; (n - 1);
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 16 数值的整数次方</span><br><span class="line"></span><br><span class="line">![image-20200912001638939](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912001638939.png)</span><br><span class="line"></span><br><span class="line">**思路：**首先处理exponent为负数时，然后递归计算，注意exponent为奇数时，需要多乘一个base。</span><br><span class="line"></span><br><span class="line"># 21 调整数组顺序使奇数位于偶数前面</span><br><span class="line"></span><br><span class="line">![image-20200912002749192](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912002749192.png)</span><br><span class="line"></span><br><span class="line">**思路：**双指针。左指针遍历到第一个偶数，右指针遍历到第一个奇数，然后交换两个元素。</span><br><span class="line"></span><br><span class="line"># 22 链表中倒数第k个节点</span><br><span class="line"></span><br><span class="line">![image-20200912003248992](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912003248992.png)</span><br><span class="line"></span><br><span class="line">**思路：**双指针。第一个指针先走k步，然后两个指针一起走，直到第一个指针到达尾部。</span><br><span class="line"></span><br><span class="line"># 23 反转链表</span><br><span class="line"></span><br><span class="line">![image-20200912003545917](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912003545917.png)</span><br><span class="line"></span><br><span class="line">**思路：**</span><br><span class="line"></span><br><span class="line">![image-20200912003529299](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912003529299.png)</span><br><span class="line"></span><br><span class="line"># 30 包含min函数的栈</span><br><span class="line"></span><br><span class="line">![image-20200912004226484](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912004226484.png)</span><br><span class="line"></span><br><span class="line">**思路：**辅助单调栈。使用一个辅助单调栈维护最小值。</span><br><span class="line"></span><br><span class="line"># 33 二叉搜索树的后序遍历序列</span><br><span class="line"></span><br><span class="line">![image-20200912005040034](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912005040034.png)</span><br><span class="line"></span><br><span class="line">**思路：**单调栈。倒序遍历数组（左右根 -&gt; 根右左）。</span><br><span class="line"></span><br><span class="line"># 38 字符串的排列</span><br><span class="line"></span><br><span class="line">![image-20200912010408938](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912010408938.png)</span><br><span class="line"></span><br><span class="line">**思路：**回溯+剪枝。每轮递归中固定没有遍历过的元素中的一位。</span><br><span class="line"></span><br><span class="line"># 39 数组中出现次数超过一半的数字</span><br><span class="line"></span><br><span class="line">![image-20200912010739651](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912010739651.png)</span><br><span class="line"></span><br><span class="line">**思路：**摩尔投票法。遍历数组，当保存的数与当前遍历到的数相同时，计数器+1，否则计数器-1，并修改保存的数为当前数。</span><br><span class="line"></span><br><span class="line"># 42 连续子数组的最大和</span><br><span class="line"></span><br><span class="line">![image-20200912011131473](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912011131473.png)</span><br><span class="line"></span><br><span class="line">**思路：**维护一个sum变量，遍历数组，保存最大的sum为结果，当sum小于0时，将sum置0。</span><br><span class="line"></span><br><span class="line"># 45 把数组排成最小的数</span><br><span class="line"></span><br><span class="line">![image-20200912011422867](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912011422867.png)</span><br><span class="line"></span><br><span class="line">**思路：**将数字看做字符串，按照字符串大小进行排序。</span><br><span class="line"></span><br><span class="line"># 48 最长不含重复字符的子字符串</span><br><span class="line"></span><br><span class="line">![image-20200912011759855](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912011759855.png)</span><br><span class="line"></span><br><span class="line">**思路：**双指针+Hash表。Hash表存储每个字符最后一次出现的位置，当右指针遇到已出现过的字符时，更新左指针到该字符上一次出现的位置，保证左右指针之间没有重复字符。</span><br><span class="line"></span><br><span class="line"># 50 第一个只出现一次的字符</span><br><span class="line"></span><br><span class="line">![image-20200912012642907](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912012642907.png)</span><br><span class="line"></span><br><span class="line">**思路：**</span><br><span class="line"></span><br><span class="line">- Hash。两次遍历字符串，第一次遍历保存重复状态，第二次遍历获得第一个不重复字符。</span><br><span class="line"></span><br><span class="line"># 51 数组中的逆序对</span><br><span class="line"></span><br><span class="line">![image-20200912012904699](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912012904699.png)</span><br><span class="line"></span><br><span class="line">**思路：**在归并排序的合并过程中，每当遇到右边数组当前元素大于坐标数组当前元素时，右边数组当前元素之前的值都比左边数组当前元素小。</span><br><span class="line"></span><br><span class="line"># 52 两个链表的第一个公共结点</span><br><span class="line"></span><br><span class="line">![image-20200912082933950](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912082933950.png)</span><br><span class="line"></span><br><span class="line">**思路：**双指针。ptr1和ptr2分别遍历A、B链表，当ptr1遍历到A链表结尾时，重新指向B的开头，当ptr2遍历到B链表结尾时，重新指向A的开头，直到ptr1 &#x3D;&#x3D; ptr2。</span><br><span class="line"></span><br><span class="line"># 53-Ⅰ  在排序数组中查找数字出现的次数</span><br><span class="line"></span><br><span class="line">![image-20200912083335403](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912083335403.png)</span><br><span class="line"></span><br><span class="line">**思路：**二分查找。分别查找target和target - 1的右边界，将两结果相减即可。</span><br><span class="line"></span><br><span class="line"># 53-Ⅱ 0~n-1中缺失的数字</span><br><span class="line"></span><br><span class="line">![image-20200912083614626](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912083614626.png)</span><br><span class="line"></span><br><span class="line">**思路：**二分查找。判断数组下标与值是否相等。</span><br><span class="line"></span><br><span class="line"># 54 二叉搜索树的第k大结点</span><br><span class="line"></span><br><span class="line">![image-20200912084211003](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912084211003.png)</span><br><span class="line"></span><br><span class="line">**思路：**递归中序遍历。</span><br><span class="line"></span><br><span class="line"># 57-Ⅱ 和为s的连续正数序列</span><br><span class="line"></span><br><span class="line">![image-20200912085639305](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912085639305.png)</span><br><span class="line"></span><br><span class="line">**思路：**双指针滑动窗口。窗口和小于target时，右指针移动，窗口和大于target时，左指针移动。</span><br><span class="line"></span><br><span class="line"># 59-Ⅰ 滑动窗口的最大值</span><br><span class="line"></span><br><span class="line">![image-20200912090249801](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912090249801.png)</span><br><span class="line"></span><br><span class="line">**思路：**双向**单调队列**。队列头为最大值，每次滑动时，将若滑动窗口的最左值等于队列头，说明该队列头需要被移除了，然后将滑动窗口新加入的最右值加入到队尾并保证单调。</span><br><span class="line"></span><br><span class="line"># 59-Ⅱ 队列的最大值</span><br><span class="line"></span><br><span class="line">![image-20200912092941507](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912092941507.png)</span><br><span class="line"></span><br><span class="line">**思路：**辅助**单调**双向队列。添加元素时，分别向队列和单调队列中添加元素。弹出元素时，若弹出的元素恰好与单调队列头元素相等，则单调队列也弹出头元素。</span><br><span class="line"></span><br><span class="line"># 61 扑克牌中的顺子</span><br><span class="line"></span><br><span class="line">![image-20200912093753366](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912093753366.png)</span><br><span class="line"></span><br><span class="line">**思路：**遍历数组set记录数组中元素是否重复，同时记录数组中的最大值和最小值，若遍历过程中没有出现重复，则判断最大值与最小值的差值。</span><br><span class="line"></span><br><span class="line"># 62 圆圈中最后剩下的数字</span><br><span class="line"></span><br><span class="line">![image-20200912102707865](.&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912102707865.png)</span><br><span class="line"></span><br><span class="line">**思路：**</span><br><span class="line"></span><br><span class="line">- 通过list保存序列，依次求出需要删除的下标进行删除。</span><br><span class="line"></span><br><span class="line">- 数学推导</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public int lastRemaining(int n, int m) &#123;</span><br><span class="line">          int ans &#x3D; 0;</span><br><span class="line">          &#x2F;&#x2F; 最后一轮剩下2个人，所以从2开始反推</span><br><span class="line">          for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">              ans &#x3D; (ans + m) % i;</span><br><span class="line">          &#125;</span><br><span class="line">          return ans;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h1 id="68-Ⅰ-二叉搜索树的最近公共祖先"><a href="#68-Ⅰ-二叉搜索树的最近公共祖先" class="headerlink" title="68-Ⅰ 二叉搜索树的最近公共祖先"></a>68-Ⅰ 二叉搜索树的最近公共祖先</h1><p><img src="/./images/%E5%89%91%E6%8C%87Offer/image-20200912112355980.png" alt="image-20200912112355980"></p>
<p><strong>思路：</strong>若pq的值都小于当前结点，则遍历至左结点，若pq的值都大于当前结点，则遍历至右结点，否则返回当前结点。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客算法课程笔记</title>
    <url>/2022/01/01/%E7%AE%97%E6%B3%95/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>牛客算法课程笔记</p>
<a id="more"></a>
<h3 id="异或运算可以理解为无进位加法"><a href="#异或运算可以理解为无进位加法" class="headerlink" title="异或运算可以理解为无进位加法"></a>异或运算可以理解为无进位加法</h3><ul>
<li><code>a ^ a = 0</code>, <code>a ^ 0 = 0</code></li>
<li>交换两个数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="1-快排改进步骤"><a href="#1-快排改进步骤" class="headerlink" title="1. 快排改进步骤"></a>1. 快排改进步骤</h4><ul>
<li><p>改进一：每次递归的时候，将与划分值相等的值放在一起（荷兰国旗问题），不需要再参与递归。</p>
<ul>
<li>左右两端分别保存小于和大于划分值的元素</li>
</ul>
</li>
<li><p>改进二：每次随机选取划分值，使得平均复杂度为O(nlogn)。</p>
</li>
</ul>
<h4 id="2-桶排序"><a href="#2-桶排序" class="headerlink" title="2. 桶排序"></a>2. 桶排序</h4><ul>
<li>计数排序：统计数组中每种数字的频率，适用于最小值和最大值相差不大的情况。</li>
<li>基数排序：从个位到最高位（权重从低到高），每次按元素的对应位排序。</li>
</ul>
<h4 id="3-排序算法总结"><a href="#3-排序算法总结" class="headerlink" title="3. 排序算法总结"></a>3. 排序算法总结</h4><ul>
<li>不稳定：选择排序、快速排序、堆排序。</li>
<li>稳定：冒泡排序（相邻相等时不交换）、插入排序（插入到相等值的后面）、归并排序（合并遇到相等时先合入左边数组）。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">x</td>
<td style="text-align:center">空间小</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(logn)</td>
<td style="text-align:center">x</td>
<td style="text-align:center">最快（常数时间小）</td>
</tr>
<tr>
<td style="text-align:center">桶排序</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">✓</td>
</tr>
</tbody>
</table>
</div>
<p>​    综合排序：快排的时候，当传入的子数组元素小于60时，采用插入排序。</p>
<p><img src="./images/牛客算法课程笔记/image-20220106080043599.png" alt="image-20220106080043599"> </p>
<h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><ul>
<li>返回负数：第一个参数排在前面。</li>
<li>返回正数：第二个参数排在前面。</li>
<li>返回0：默认第一个排在前面。</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="1-判断单链表是否有环"><a href="#1-判断单链表是否有环" class="headerlink" title="1. 判断单链表是否有环"></a>1. 判断单链表是否有环</h4><p>(1) 快慢指针从表头出发，快指针每次移动两个节点，慢指针每次移动一个节点。</p>
<p>(2) 若快指针为空，链表无环。</p>
<p>(3) 若快慢指针相交，链表有环。</p>
<h4 id="2-求单链表入环节点"><a href="#2-求单链表入环节点" class="headerlink" title="2. 求单链表入环节点"></a>2. 求单链表入环节点</h4><p>(1) 判断单链表是否有环。</p>
<p>(2) 若单链表有环，快慢指针相交点为环内某个节点。</p>
<p>(3) 快指针重新从表头出发，快慢指针每次移动一个节点。</p>
<p>(4) 返回快慢指针再次相交的节点。</p>
<h4 id="3-求两个链表的第一个交点（是否有环→是否有交点→求第一个交点）"><a href="#3-求两个链表的第一个交点（是否有环→是否有交点→求第一个交点）" class="headerlink" title="3. 求两个链表的第一个交点（是否有环→是否有交点→求第一个交点）"></a>3. 求两个链表的第一个交点（是否有环→是否有交点→求第一个交点）</h4><p>(1) 分别判断两个链表是否有环。</p>
<p>(2) 若一个存在环，一个不存在环，则两个链表<strong>无交点</strong>。</p>
<p>(3) 若两个链表<strong>都不存在环</strong>：</p>
<p>​    ① 分别遍历两个链表并记录链表长度。</p>
<p>​    ② 若表尾不相交，则两个链表<strong>无交点</strong>，否则有交点。</p>
<p>​    ③ 长链表指针从表头先移动$长度差$个节点，然后两个指针同时移动。</p>
<p>​    ④ 返回两个指针第一次相交的节点。</p>
<p>(4) 若两个链表都存在环：</p>
<p>​    ① 分别求两个链表入环节点。</p>
<p>​    ② 若入环节点相同：</p>
<p>​        Ⅰ 分别遍历两个链表到入环节点并记录长度。</p>
<p>​        Ⅱ 长链表指针从表头先移动$长度差$个节点，然后两个指针同时移动。</p>
<p>​        Ⅲ 返回两个指针第一次相交的节点。</p>
<p>​    ③ 若入环节点不同：</p>
<p>​        Ⅰ 链表1从入环节点出发遍历，若再次遇到链表1的入环节点，则两个链表<strong>无交点</strong>。</p>
<p>​        Ⅱ 若遇到链表2的入环节点，则两个链表有交点，且两个入环节点均可以看做第一个相交节点。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="1-非递归遍历"><a href="#1-非递归遍历" class="headerlink" title="1. 非递归遍历"></a>1. 非递归遍历</h4><p>(1) 先序遍历（中左右）</p>
<p>​    ① 根节点入栈。</p>
<p>​    ② while 栈不为空：</p>
<p>​        Ⅰ 弹出栈顶元素并打印。</p>
<p>​        Ⅱ 压入弹出元素的右子树。</p>
<p>​        Ⅲ 压入弹出元素的左子树。</p>
<p>(2) 后序遍历（左右中）</p>
<p>​    ① 根节点入栈。</p>
<p>​    ② while 栈不为空：</p>
<p>​        Ⅰ 弹出栈顶元素并记录。</p>
<p>​        Ⅱ 压入弹出元素的左子树。</p>
<p>​        Ⅲ 压入弹出元素的右子树。</p>
<p>​    ③ 记录到的节点顺序为中右左，将记录反转输出（用栈记录）即为左右中。</p>
<p>(3) 中序遍历（左中右）</p>
<p>​    ① 以根节点为cur节点。</p>
<p>​    ② while 栈不为空 || cur不为空：</p>
<p>​        Ⅰ 从cur节点开始向左遍历到叶子节点，并依次入栈。</p>
<p>​        Ⅱ 弹出栈顶节点并打印。</p>
<p>​        Ⅲ 以弹出节点的右节点为cur节点。</p>
<h4 id="2-后继节点（对应还有前驱节点）"><a href="#2-后继节点（对应还有前驱节点）" class="headerlink" title="2. 后继节点（对应还有前驱节点）"></a>2. 后继节点（对应还有前驱节点）</h4><p>​    定义：<strong>中序遍历序列</strong>中，每个节点的下一个节点为该节点的后继节点。</p>
<p>​    (1) 若节点有右子树，其后继节点为右子树的最左节点。</p>
<p>​    (2) 若节点无右子树，则向上遍历直到找到一个父节点，满足节点属于该父节点的子树。该父节点为节点的后继节点。</p>
<h4 id="3-判断二叉树是否为另一个二叉树的子树"><a href="#3-判断二叉树是否为另一个二叉树的子树" class="headerlink" title="3. 判断二叉树是否为另一个二叉树的子树"></a>3. 判断二叉树是否为另一个二叉树的子树</h4><p>递归方法复杂度较高。</p>
<p>可以将两个二叉树序列化为两个字符串，判断一个字符串是否为另一个字符串的子串。</p>
<h1 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h1><p>节点结构：</p>
<ul>
<li>pass：节点通过次数。</li>
<li>end：以结点为结尾的次数。</li>
<li>map：key为字符（根节点为空字符’’），value为下一个节点。</li>
</ul>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h4 id="1-拓扑排序（有向无环图，有至少一个入度为0的点）"><a href="#1-拓扑排序（有向无环图，有至少一个入度为0的点）" class="headerlink" title="1. 拓扑排序（有向无环图，有至少一个入度为0的点）"></a>1. 拓扑排序（有向无环图，有至少一个入度为0的点）</h4><p>(1) 使用一个map记录节点的入度，queue记录入度为0的节点。</p>
<p>(2) while queue不为空：</p>
<p>​    ① 弹出queue尾节点，并添加到result列表。</p>
<p>​    ② 遍历弹出节点的下一个节点，所有节点入度-1，若入度为0，则入queue。</p>
<h4 id="2-最小生成树—Prim算法"><a href="#2-最小生成树—Prim算法" class="headerlink" title="2. 最小生成树—Prim算法"></a>2. 最小生成树—Prim算法</h4><p>(1) 从任意节点node开始遍历所有节点：</p>
<p>​    ① 若set中不包含node：</p>
<p>​        Ⅰ 将与node相连的边放入优先队列priorityQueue。</p>
<p>​        Ⅱ while priorityQueue不为空：</p>
<p>​            弹出一条边（最小边），若边的另一个节点不在set中，将边放入result，将节点加入set，并将节点的所有边加入priorityQueue。</p>
<h4 id="3-最小生成树—Kruskal算法（集合查询合并可以使用并查集）"><a href="#3-最小生成树—Kruskal算法（集合查询合并可以使用并查集）" class="headerlink" title="3. 最小生成树—Kruskal算法（集合查询合并可以使用并查集）"></a>3. 最小生成树—Kruskal算法（集合查询合并可以使用并查集）</h4><p>(1) 将每个节点各自单独存放在一个set中。</p>
<p>(2) 将所有边放在一个优先队列priorityQueue中。</p>
<p>(3) while priorityQueue不为空：</p>
<p>​    ① 弹出一条边，若边的两个节点不属于同一个set：</p>
<p>​        Ⅰ 将边存入result。</p>
<p>​        Ⅱ 将两个节点所在的集合合并在一起。</p>
<h4 id="4-Dijkstra算法—单源最短路径算法"><a href="#4-Dijkstra算法—单源最短路径算法" class="headerlink" title="4. Dijkstra算法—单源最短路径算法"></a>4. Dijkstra算法—单源最短路径算法</h4><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h4 id="1-拼接最小字典序字符串"><a href="#1-拼接最小字典序字符串" class="headerlink" title="1. 拼接最小字典序字符串"></a>1. 拼接最小字典序字符串</h4><p>若str1 + str2 &lt;= str2 + str1，则认为str1 &lt; str2。按照这种排序方式对字符串数组进行排序后，拼接而成的即为最小字典序字符串。</p>
<h1 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h1><h4 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h4><p>​    存在左中右三个杆，需要将左杆上的n个圆盘移动到右杆上，并保持圆盘顺序不变，每次可以将任意杆上的第一个圆盘移动到其他杆上。</p>
<p>​    循环以下步骤：</p>
<p>(1) 将n - 1个圆盘从左移动到中。</p>
<p>(2) 将第n个圆盘从左移动到右。</p>
<p>(3) 将n - 1个圆盘从中移动到右。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode经典算法</title>
    <url>/2020/09/13/%E7%AE%97%E6%B3%95/Leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>记录Leetcode中经典的算法思路。</p>
<a id="more"></a>

<h1 id="两数之和1"><a href="#两数之和1" class="headerlink" title="两数之和1"></a>两数之和1</h1><p><img src="/./images/Leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/image-20200913175716328.png" alt="image-20200913175716328"></p>
<p><strong>思路：</strong></p>
<ul>
<li>排序+双指针，时间O(nlogn)，空间O(1)。</li>
<li>HashMap，一次遍历检查HashMap是否已有target - nums[i]，否则添加当前元素到HashMap中。</li>
</ul>
<h1 id="三数之和15"><a href="#三数之和15" class="headerlink" title="三数之和15"></a>三数之和15</h1><p><img src="/./images/Leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/image-20200913180029903.png" alt="image-20200913180029903"></p>
<p><strong>思路：</strong>排序+三指针，遍历排序后nums数组，对于每一个元素检查是否该元素后面是否存在l，r使得nums[i] + nums[l] + nums[r] &#x3D; 0。</p>
<h1 id="最长连续序列128"><a href="#最长连续序列128" class="headerlink" title="最长连续序列128"></a>最长连续序列128</h1><p><img src="/./images/Leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/image-20201021221252211.png" alt="image-20201021221252211"></p>
<p><strong>思路：</strong>将数组元素存入set，然后再次遍历数组，如果set中存在比当前值小的数，则跳过，否则循环检查是否连续值。</p>
<h1 id="和为k的子数组560（437）"><a href="#和为k的子数组560（437）" class="headerlink" title="和为k的子数组560（437）"></a>和为k的子数组560（437）</h1><p><img src="/./images/Leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/image-20201022155443181.png" alt="image-20201022155443181"></p>
<p><strong>思路：</strong>前缀和+哈希表。遍历数组，记录当前遍历过的元素的和，将其出现次数存放在HashMap中。对于每个元素检查HashMap中是否存在前缀和为sum-k，若存在则将结果加上该前缀和出现的次数。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2020/09/11/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>典型算法总结。</p>
<a id="more"></a>

<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="1-输入频率表：A-60、B-45、C-13、D-69、E-14、F-5、G-3"><a href="#1-输入频率表：A-60、B-45、C-13、D-69、E-14、F-5、G-3" class="headerlink" title="1. 输入频率表：A-60、B-45、C-13、D-69、E-14、F-5、G-3"></a>1. 输入频率表：A-60、B-45、C-13、D-69、E-14、F-5、G-3</h2><h2 id="2-依次找出两个最小的，小的在左边，大的在右边。"><a href="#2-依次找出两个最小的，小的在左边，大的在右边。" class="headerlink" title="2. 依次找出两个最小的，小的在左边，大的在右边。"></a>2. 依次找出两个最小的，小的在左边，大的在右边。</h2><h3 id="A-60、B-45、C-13、D-69、E-14、F-5、G-3"><a href="#A-60、B-45、C-13、D-69、E-14、F-5、G-3" class="headerlink" title="A-60、B-45、C-13、D-69、E-14、F-5、G-3"></a>A-60、B-45、C-13、D-69、E-14、F-5、G-3</h3><p><img src="/./images/%E7%AE%97%E6%B3%95/image-20200911160739925.png" alt="image-20200911160739925"></p>
<h3 id="A-60、B-45、C-13、D-69、E-14、FG-8"><a href="#A-60、B-45、C-13、D-69、E-14、FG-8" class="headerlink" title="A-60、B-45、C-13、D-69、E-14、FG-8"></a>A-60、B-45、C-13、D-69、E-14、FG-8</h3><p><img src="/./images/%E7%AE%97%E6%B3%95/image-20200911160856599.png" alt="image-20200911160856599"></p>
<h3 id="……省略"><a href="#……省略" class="headerlink" title="……省略"></a>……省略</h3><h3 id="AD：129、FGCEB：80"><a href="#AD：129、FGCEB：80" class="headerlink" title="AD：129、FGCEB：80"></a>AD：129、FGCEB：80</h3><p><img src="/./images/%E7%AE%97%E6%B3%95/image-20200911161304549.png" alt="image-20200911161304549"></p>
<h3 id="左路径为0，右路径为1"><a href="#左路径为0，右路径为1" class="headerlink" title="左路径为0，右路径为1"></a>左路径为0，右路径为1</h3><p><img src="/./images/%E7%AE%97%E6%B3%95/image-20200911161551630.png" alt="image-20200911161551630"></p>
<h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>496</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《金字塔原理》学习笔记</title>
    <url>/2023/05/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Linux常用命令。</p>
<a id="more"></a>

<h1 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h1><h2 id="目录相关"><a href="#目录相关" class="headerlink" title="目录相关"></a>目录相关</h2><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><p>绝对路径以<code>/</code>开头，相对路径没有<code>/</code>。</p>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p><code>-p</code>会创建级联路径。</p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>用于删除文件。<code>-r</code>用于删除目录，<code>-f</code>用于强制删除，<code>-rf</code>用于强制删除目录。</p>
<ul>
<li><code>rmdir</code>命令用于删除空目录。</li>
</ul>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p><code>cp [-r] 源 目标</code>，<code>-r</code>用于复制目录。</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p><code>mv [选项] 源 目标</code>，当目标存在时，若目标是目录，则将源<strong>移动</strong>到该目录下，若目标是文件，则询问是否<strong>覆盖</strong>；当目标不存在时，将源<strong>重命名</strong>为目标。</p>
<h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><h3 id="cat和tac"><a href="#cat和tac" class="headerlink" title="cat和tac"></a>cat和tac</h3><p>cat从第一行显示文件，<code>-n</code>会显示行号。tac从最后一行显示文件。</p>
<h3 id="more和less"><a href="#more和less" class="headerlink" title="more和less"></a>more和less</h3><p>文件内容较多时，可以使用more和less翻页或按行查看。</p>
<h3 id="head和tail"><a href="#head和tail" class="headerlink" title="head和tail"></a>head和tail</h3><p>head显示文件的前10行，tail显示文件的末10行，<code>head -数量 文件名</code>可以指定行数，tail类似。</p>
<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p><code>ls -l</code>可以查看当前路径下的所有文件的属性。</p>
<p><img src="/images/Linux%E5%91%BD%E4%BB%A4/image-20201010233616918.png" alt="image-20201010233616918"></p>
<ul>
<li>第1列：第1位表示文件类型（**-文件，d目录，l链接文件等**），后面9位每3位一组，分别表示所有者（user）的权限、所属组（group）的权限、其他非本组用户（others）的权限。</li>
<li>第2列：该文件占用的节点。</li>
<li>第3，4，5列：所有者，所属组，文件大小。</li>
<li>第6，7，8列：最后一次修改时间的月、日、年。</li>
<li>第9列：文件名。</li>
</ul>
<h2 id="更改文件权限"><a href="#更改文件权限" class="headerlink" title="更改文件权限"></a>更改文件权限</h2><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p><code>chgrp [-R] 组名 文件名</code>，更改文件的所属组，<code>-R</code>用于级联更改。</p>
<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p><code>chown [-R] 用户名 文件名</code>，更改文件的所有者，<code>-R</code>用于级联更改。</p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p><code>chmod [-R] xyz 文件名</code>，其中xyz为三个数字分别文件名表示所有者、所属组、其他用户的权限。</p>
<p><strong>r&#x3D;4，w&#x3D;2，x&#x3D;1，-&#x3D;0。</strong>rw-&#x3D;4+2+0&#x3D;6。</p>
<p>目录的默认权限是755，文件的默认权限是644。</p>
<h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>可用于查找PATH环境变量下的路径下的可执行文件。如<code>which vi</code>会输出<code>/usr/bin/vi</code>。</p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>find 路径 [参数]</code>，查找路径下的文件。</p>
<ul>
<li><code>-atime +天数/-天数</code>：查找访问或执行时间大于&#x2F;小于n天的文件。</li>
<li><code>-mtime +天数/-天数</code>：查找写入时间大于或小于n填的文件。</li>
<li><code>-name 文件名</code>：查找路径下指定文件名。</li>
</ul>
<h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>查看已挂载磁盘的总容量、使用容量、剩余容量等信息，默认KB为单位。<code>-h</code>表示使用合适的单位。</p>
<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p><code>du [参数] 文件或路径名</code>，查看某个目录或文件的大小。<code>-a</code>表示列出路径下所有目录和文件的大小，默认只显示所有目录。<code>-h</code>表示使用合适的单位。</p>
<h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h3><p>分区工具，只能划分小于2TB的分区。<code>fdisk -l</code>可以查看所有磁盘设备信息。<code>fdisk 设备名称</code>进入分区操作模式。</p>
<h3 id="mount和umount"><a href="#mount和umount" class="headerlink" title="mount和umount"></a>mount和umount</h3><p><code>mount 设备名称 路径</code>，将设备挂载到该路径上。</p>
<p><code>umount 路径</code>，卸载路径上的设备。</p>
<h3 id="x2F-etc-x2F-fstab配置文件"><a href="#x2F-etc-x2F-fstab配置文件" class="headerlink" title="&#x2F;etc&#x2F;fstab配置文件"></a>&#x2F;etc&#x2F;fstab配置文件</h3><p>该文件中记录了系统启动时需要挂载的分区。</p>
<h1 id="压缩与打包"><a href="#压缩与打包" class="headerlink" title="压缩与打包"></a>压缩与打包</h1><h3 id="tar打包"><a href="#tar打包" class="headerlink" title="tar打包"></a>tar打包</h3><p>打包<code>tar [zjxcvfpP] 输出文件名 需要打包文件</code>，<code>-z -j -J</code>表示分别同时使用gzip、bzip2、xz压缩。<code>-v</code>表示可视化，<code>-x</code>表示解包或解压缩，<code>-c</code>表示建立一个tar包，<code>-f</code>后接压缩后的文件名或解压文件名。</p>
<p><code>tar -cvf test.tar test1 test2 test3</code>，将test1 test2 test3打包为test.tar。</p>
<p><code>tar -xvf test.tar</code>，解压缩文件。</p>
<h3 id="zip压缩"><a href="#zip压缩" class="headerlink" title="zip压缩"></a>zip压缩</h3><p><code>zip test.zip test/*</code>，将test路径下所有文件压缩为test.zip。</p>
<p><code>unzip test.zip</code>，解压缩，需要安装unzip工具。</p>
<h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><ul>
<li><p>-a：–all，显示所有。</p>
</li>
<li><p>-r：–route，显示路由表。</p>
</li>
<li><p>-t：–tcp，显示tcp连接。</p>
</li>
<li><p>-u：–udp，显示UDP连接。</p>
</li>
<li><p>-p：–programs，显示进程名。</p>
</li>
<li><p>-n：–numeric，禁用域名解析功能，加快查询速度。</p>
</li>
<li><p>-l：–listening，显示正在监听的socket。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习2：死锁</title>
    <url>/2020/07/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A02%EF%BC%9A%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<p>本文总结了死锁的基础知识。</p>
<a id="more"></a>

<h1 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h1><p>死锁是指两个或两个以上的进程在执行过程中，由于互相竞争资源而造成的一种阻塞现象，若无外力作用，它们将无法执行下去。</p>
<h1 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h1><ul>
<li>互斥：每个资源要么以及分配给了一个进程，要么可用。</li>
<li>占有和等待：已经得到某个资源的进程可以请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不可被抢占，只能被占用它的进程释放。</li>
<li>环路等待：有两个或两个以上的进程组成环路，其中每个进程都在等待下一个进程占有的资源。</li>
</ul>
<h1 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h1><ul>
<li>进程执行顺序不当。</li>
<li>PV操作使用不当。</li>
<li>同类资源分配不均。</li>
<li>对某些资源的使用未加限制等。</li>
</ul>
<h1 id="死锁解决的方法"><a href="#死锁解决的方法" class="headerlink" title="死锁解决的方法"></a>死锁解决的方法</h1><h2 id="鸵鸟政策"><a href="#鸵鸟政策" class="headerlink" title="鸵鸟政策"></a>鸵鸟政策</h2><p>解决死锁问题的代价很高，一种解决方法是忽略死锁。</p>
<h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>在进程执行之前防止发生死锁，至少破坏四个必要条件之一。</p>
<ul>
<li>破坏互斥条件：只读文件可以采用非互斥访问。</li>
<li>破坏占有和等待条件：所有进程在开始执行前请求所需要的全部资源。</li>
<li>破坏不可抢占条件：若进程所需资源不足，则释放该进程的占有资源，进入等待状态。</li>
<li>破坏环路等待条件：给资源统一编号，进程只能按编号顺序来请求资源。</li>
</ul>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>使用银行家算法分析系统剩余资源量，进程占有资源量和进程申请资源量之间的关系，若存在一种调度顺序使得所有进程能够正常执行，则为安全状态，否则不是安全状态，应当拒绝进入这种状态。</p>
<h2 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h2><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<ul>
<li>每种类型一个资源时：检测有向图是否存在环。</li>
<li>每种类型多个资源时：根据系统剩余资源量，进程占有资源量和进程申请资源量，标记出无法正常执行的死锁进程。</li>
</ul>
<p>死锁恢复：</p>
<ul>
<li>利用抢占恢复：释放死锁状态的进程占有的资源，但并不杀死进程，直到死锁解除。</li>
<li>利用回滚恢复：根据系统保存的检查点让所有进程回退，直到死锁解除。</li>
<li>通过杀死进程恢复：杀死死锁状态的所有进程或逐个杀死死锁状态的进程，直到死锁解除。</li>
<li>系统重启：结束所有进程并重启操作系统。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习1：进程线程</title>
    <url>/2020/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A01%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>本文总结了进程与线程的基础知识。</p>
<a id="more"></a>

<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><p>并发是指一段时间内在单核CPU上交替运行多个程序。</p>
<p>并行是指同一时刻在多核CPU上同时运行多个程序。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程是<strong>资源分配</strong>的基本单位。</p>
<p>进程间数据不共享，创建和销毁的开销较大。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程时<strong>独立调度</strong>的基本单位。</p>
<p>一个进程至少有一个线程，称为主线程，其他为子线程。</p>
<p>一个进程中可以有多个线程，它们共享进程资源。</p>
<h1 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h1><ol>
<li>操作系统中能同时运行多个进程，而进程中能同时运行多个线程。</li>
<li>进程是资源分配的基本单位，线程是任务调度和执行的基本单位。</li>
<li>每个进程有独立的地址空间和资源，进程之间的切换会有较大开销；同一进程的线程共享所属进程的地址空间和资源，每个线程有独立的堆栈和程序计数器，线程之间切换的开销小。</li>
<li>一个进程崩溃后，在保护模式下不会影响其他进程，而一个线程崩溃则整个进程死掉。所以多进程比多线程健壮。</li>
</ol>
<h1 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h1><p>一个父进程退出，而它的子进程还在运行，这些子进程称为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并由init进程对它们完成状态收集工作。孤儿进程不会对系统造成伤害。</p>
<h1 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h1><p>如果子进程退出，而父进程没有调用wait()或waitpid()，那么子进程的进程描述符仍然存在系统中，这些子进程称为僵尸进程。系统能使用的进程号是有限的，若僵尸进程过多，可能导致系统无法产生新的进程。通过杀死父进程可以将僵尸进程变成孤儿进程，从而被init进程收养，只有init进程就会释放所有僵尸进程占有的资源，从而结束僵尸进程。</p>
<h1 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h1><p>进程有三个状态：</p>
<ul>
<li>就绪（ready）：等待被调度（等待CPU时间）</li>
<li>运行（running）</li>
<li>阻塞（waiting）：等待资源（除CPU时间外的资源）</li>
</ul>
<p>就绪和运行可以相互切换，其他都是单向切换。</p>
<h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><ol>
<li><p><strong>先来先服务：</strong>非抢占式，有利于长作业，不利于短作业。</p>
</li>
<li><p><strong>短作业优先：</strong>非抢占式，长作业可能永远得不到调度。</p>
</li>
<li><p><strong>最短剩余时间优先：</strong>抢占式，按剩余运行时间的顺序进行调度。</p>
</li>
</ol>
<h2 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h2><ol>
<li><strong>时间片轮转：</strong>所有进程按先来先服务的原则排成队列，每次调度时把一个时间片分配给队首进程，队首进程时间片结束后被送到队尾。</li>
<li><strong>优先级调度：</strong>每个进程分配一个优先级，按优先级进行调度，为了避免低优先级进程永远得不到调度，可以随时间增加等待进程的优先级。</li>
<li><strong>多级反馈队列：</strong>设置多个时间片大小不同的队列，进程若在第一个队列结束时间片后未执行完毕，则被送到下一个队列末尾。</li>
</ol>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>对多线程串行化访问公共资源，任意时刻只允许一个线程对公共资源进行访问。同步速度快，但是只能用于同步本进程内的线程，而不可用于同步多个进程中的线程。</p>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>采用互斥对象机制，只有拥有互斥对象的线程才能访问公共资源的权限。互斥量可以命名，因此可以实现跨进程的线程同步，创建互斥量需要的资源也更多。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量允许多个线程同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</p>
<p>信号量用于累计进程的唤醒次数，可以取0或正值，有两种操作：</p>
<ul>
<li>down：若信号量大于0，则执行-1；若信号量为0，则将进程睡眠，等待信号量大于1，此时down操作未完成。</li>
<li>up：将信号量+1，唤醒睡眠的进程让其完成down操作。</li>
</ul>
<p>若信号量取值只能为0或1，则为互斥量（Mutex）。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>通过通知操作的方式来保持线程同步，还可以实现多个线程优先级的比较。</p>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="互斥量-1"><a href="#互斥量-1" class="headerlink" title="互斥量"></a>互斥量</h2><h2 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h2><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程是由过程、变量及数据结构等组成的一个集合，是一个特殊的模块或软件包。任一时刻只能有一个进程调用管程中的过程。</p>
<h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>使用两条原语send和receive，类似信号量而不是管程，是系统调用而不是语言成分。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cyc2018.github.io/CS-Notes/#/" target="_blank" rel="noopener">CS-Notes</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统</title>
    <url>/2022/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>《深入理解计算机系统》</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h4 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h4><p><img src="/./images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20220126230603179.png" alt="image-20220126230603179"></p>
<ul>
<li><strong>总线：</strong>贯穿整个系统的一组电子管道，传送定长的字节块，也就是字。32位系统中1字&#x3D;4字节&#x3D;32位，64位系统中1字&#x3D;8字节&#x3D;64位。</li>
<li><strong>I&#x2F;O设备：</strong>图中有鼠标、键盘、显示器、磁盘。通过控制器或者适配器与<strong>I&#x2F;O总线</strong>相连。</li>
<li><strong>主存：</strong>临时存储设备，在处理执行程序时，存放程序和程序处理的数据。由一组<strong>动态随机存储器（DRAM）</strong>芯片组成。</li>
<li><strong>CPU（处理器）：</strong>中央处理单元，是执行存储在主存中指令的引擎。核心是一个大小为<strong>一个字</strong>的<strong>寄存器</strong>（<strong>程序计数器，PC</strong>），PC始终指向主存中的某条机器语言指令，CPU负责执行PC指向的指令，并更新PC。CPU在指令的要求下可能执行的操作包括：<ul>
<li><strong>加载：</strong>从主存复制一个字节或一个字到寄存器。</li>
<li><strong>存储：</strong>从寄存器复制一个字节或一个字到主存中。</li>
<li><strong>操作：</strong>将两个寄存器的内容复制到ALU，ALU对这两个字做算术运算并将结果存放到一个寄存器中。</li>
<li><strong>跳转：</strong>从指令本身中抽取一个字复制到PC中。</li>
</ul>
</li>
<li><strong>寄存器文件：</strong>由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。</li>
<li><strong>ALU（算术&#x2F;逻辑单元）：</strong>负责计算新的数据和地址值。</li>
</ul>
<h4 id="运行可执行文件"><a href="#运行可执行文件" class="headerlink" title="运行可执行文件"></a>运行可执行文件</h4><ol>
<li>在shell程序中输入可执行文件名，shell程序会将文件名做为一个指令读入到寄存器，再存放到内存中。</li>
<li>运行可执行文件时，shell首先执行一系列指令来加载可执行文件，会将目标文件中的代码通过<strong>DMA（直接存储器存取）</strong>技术直接从磁盘复制到主存。</li>
<li>处理器开始运行可执行文件，需要将文件中的机器语言指令从主存中复制到寄存器，执行结果再复制到显示设备。</li>
</ol>
<h4 id="高速缓存的重要性"><a href="#高速缓存的重要性" class="headerlink" title="高速缓存的重要性"></a>高速缓存的重要性</h4><p><img src="/../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20220127175645947.png" alt="image-20220127175645947"></p>
<p>​	主存和寄存器直接的读写速度相差大约100倍，因此添加高速缓存存储器来存放处理器近期可能需要的信息（<strong>局部性原理</strong>）。典型的高速缓存存储器可能由多级高速缓存组成（L1、L2），这些高速缓存是用<strong>SRAM（静态随机访问存储器）</strong>的硬件技术实现的。</p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>​	进程是对运行的程序的一种抽象，进程切换是由<strong>操作系统内核</strong>管理的，内核是操作系统代码常驻主存的部分。</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p><img src="/./images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20220128084821826.png" alt="image-20220128084821826"></p>
<ul>
<li>程序代码和数据：所有进程的代码都是从同一固定地址开始的，代码和数据区就是根据可执行文件内容初始化的。</li>
<li>堆：堆区用于代码运行时内存分配，可以通过malloc和free等方法动态分配。</li>
<li>共享库：存放类似C标准卡和数学库的区域。</li>
<li>栈：栈区用于调用方法时分配，可以在执行程序时动态分配。</li>
<li>内核虚拟内存：为内核保留的。</li>
</ul>
<h1 id="程序结构和执行"><a href="#程序结构和执行" class="headerlink" title="程序结构和执行"></a>程序结构和执行</h1><h2 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h2><h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h3><p>​	字长决定了虚拟地址空间的大小，例如对于一个32位机器来说，字长为4字节，虚拟地址的最大为$2^{32}-1$，通常一个地址表示一个字节。</p>
<h3 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h3><ul>
<li>无符号整数：00000000-11111111，范围为0~255。</li>
<li>有符号整数：10000000-01111111，<strong>补码</strong>形式，最高位为负权，10000000&#x3D;$-2^8$&#x3D;-128，01111111&#x3D;127。再比如10001111&#x3D;-10000000+00001111&#x3D;-128+15&#x3D;-113。因此，补码表示的正负范围是不对称的。当运算结果溢出时，会对结果进行截断，仅保留类型支持的位数。</li>
</ul>
<h3 id="小数表示"><a href="#小数表示" class="headerlink" title="小数表示"></a>小数表示</h3><h4 id="普通浮点表示"><a href="#普通浮点表示" class="headerlink" title="普通浮点表示"></a>普通浮点表示</h4><p>​	0.0&#x3D;0&#x2F;2&#x3D;0		0.01&#x3D;1&#x2F;4&#x3D;0.25		0.11&#x3D;1&#x2F;2 + 1&#x2F;4 &#x3D; 0.75</p>
<p>​	从上面的表示方法可以看出，普通的小数的二进制表示法只能表示那些小数位为2的次幂的小数，而像1&#x2F;5这样的小数无法准确表示。</p>
<h4 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h4><p><a href="https://zhuanlan.zhihu.com/p/358417700" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/358417700</a></p>
<p><img src="/./images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20220207153702578.png" alt="image-20220207153702578"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络一：网络层</title>
    <url>/2020/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<p>本文整理计算机网络中运输层的主要知识点。</p>
<a id="more"></a>

<p><img src="/6.png"></p>
<p>网络层向上只提供尽最大努力交付的数据报服务，不提供服务质量的承诺。</p>
<p>路由器是网络层的中间设备。</p>
<h1 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h1><p><img src="/2.png"></p>
<h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><p>从网络层使用的IP地址解析出数据链路层使用的硬件地址。每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>若主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其ARP高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/8.png" alt="8"></p>
<p>更有效地转发IP数据报和提高交付成功的机会。ICMP报文封装在IP数据报的数据部分。不是高层协议，而是IP层的协议。ICMP报文分为差错报告报文和询问报文。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/9.png" alt="9"></p>
<h3 id="PING-Packet-InterNet-Groper"><a href="#PING-Packet-InterNet-Groper" class="headerlink" title="PING(Packet InterNet Groper)"></a>PING(Packet InterNet Groper)</h3><p>PING是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>原理是向目的主机发送 ICMP回送请求报文，目的主机收到之后会发送回送回答报文。PING会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<h2 id="网际组管理协议IGMP"><a href="#网际组管理协议IGMP" class="headerlink" title="网际组管理协议IGMP"></a>网际组管理协议IGMP</h2><p>用于IP多播。</p>
<h1 id="IP编址方式"><a href="#IP编址方式" class="headerlink" title="IP编址方式"></a>IP编址方式</h1><h2 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/3.png" alt="3"></p>
<p>将IP地址划分为若干个固定类，每一类地址由留个固定长度的字段组成：</p>
<p>$$ IP地址::&#x3D;{&lt;网络号&gt;,&lt;主机号&gt;} $$</p>
<ul>
<li>网络号：标志主机（或路由器）所连接到的网络。</li>
<li>主机号：标志主机（或路由器）。</li>
</ul>
<p>A、B、C类地址为单播地址（一对一通信），D类地址为多播地址（一对多通信），E类地址保留。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/4.png" alt="4"></p>
<h2 id="划分子网编址"><a href="#划分子网编址" class="headerlink" title="划分子网编址"></a>划分子网编址</h2><p>在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址：<br>$$<br>IP地址::&#x3D;{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}<br>$$<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/5.png" alt="5"></p>
<p>从IP数据报的首部无法看出源主机或目的主机是否进行了子网划分，因此需要用到子网掩码。B类IP地址的子网掩码是255.255.0.0，假定子网号占8位，则B类IP地址下的子网掩码为255.255.255.0。路由器通过将目的IP地址145.13.3.10和其相连的各网络子网掩码逐相“与”，得到要找的子网的网络地址145.13.3.0。</p>
<h2 id="无分类编址CIDR（构造超网）"><a href="#无分类编址CIDR（构造超网）" class="headerlink" title="无分类编址CIDR（构造超网）"></a>无分类编址CIDR（构造超网）</h2><p>使用网络前缀号和主机号来对 32位的IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<p>$$IP地址::&#x3D;{&lt;网络前缀号&gt;,&lt;主机号&gt;}$$</p>
<p>CIDR记法在IP地址后面加上斜线，然后写上网络前缀所占的位数。网络前缀相同的连续IP地址组成一个CIDR地址块。CIDR的地址掩码可以继续称为子网掩码，子网掩码首1长度为网络前缀的长度。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/7.png" alt="7"></p>
<p>如图这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为构造超网 。</p>
<p>在查找时可能会在路由表中得到不止一个网络前缀的匹配结果，应当采用最长前缀匹配来确定应该匹配那一个。</p>
<p>为了进行更有效的查找，通常把无分类编址的网络前缀路由表存放在二叉搜索树中。</p>
<h2 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/1.png" alt="1"></p>
<p>20字节固定长度：</p>
<ul>
<li>版本：占4位，指IP协议的版本，通信双方版本必须一致。IPv4或IPv6。</li>
<li>首部长度：占4位，单位是4字节，表示首部最大长度为60字节，当首部长度不是4字节的整数倍时，必须利用填充字段加以填充。</li>
<li>区分服务：占1字节，用来获得更好的服务，一般不用。</li>
<li>总长度：占2字节，单位为字节，指首部和数据的总长度。</li>
<li>标识：占2字节，在数据报过长而发生分片时，相同数据报的不同分片具有相同标识符。</li>
<li>标志：占3位，第一位为1表示后面还有分片否则表示最后一个分片；第二位为1表示可以分片否则表示不能分片；第三位无意义。</li>
<li>片偏移：占13位，单位为8字节，表示分片在原数据报中的相对位置。每个分片的尺度一定是8字节的整数倍。</li>
<li>生存时间：占1字节，单位是跳数，数据报在网络中的寿命。</li>
<li>协议：占1字节，指出此数据报携带的数据是使用何种协议。</li>
<li>首部检验和：占2字节，检验数据报的首部，不包括数据部分。</li>
<li>原地址：占4字节。</li>
<li>目的地址：占4字节。</li>
</ul>
<h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><h2 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h2><p>路由信息协议RIP自洽系统内部进行路由选择，是一种分布式的基于距离向量的路由选择协议，距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<h2 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h2><p>开放最短路径优先协议OSPF在自洽系统内部进行路由选择，是公开发表的，使用了 Dijkstra 提出的最短路径算法 SPF。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻所有路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量。度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。OSPF 的更新过程比RIP收敛得更快。</p>
<h2 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h2><p>边界网关协议BGP在自洽系统之间进行路由选择，只能力求寻找一条能够到达目的网络并且比较好的路径，而非寻找最佳路由。</p>
<p>每个自洽系统都必须选择一个路由器作为BGP发言人，通过在两个相邻BGP发言人之间建立TCP连接来交换路由信息。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《计算机网络 第七版》谢希仁</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络二：运输层</title>
    <url>/2020/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2%EF%BC%9A%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p>本文整理计算机网络中运输层的主要知识点。</p>
<a id="more"></a>

<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%BF%90%E8%BE%93%E5%B1%82/6.png" alt="6"></p>
<p>TCP和UDP是TCP&#x2F;IP运输层的两个主要协议。</p>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%BF%90%E8%BE%93%E5%B1%82/7.png" alt="7"></p>
<center><b>使用UDP和TCP协议的各种应用和应用层协议</b></center>

<h1 id="用户数据报协议UDP（User-Datagram-Protocol）"><a href="#用户数据报协议UDP（User-Datagram-Protocol）" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol）"></a>用户数据报协议UDP（User Datagram Protocol）</h1><ol>
<li><p>尽最大努力交付，传送数据前不需要建立连接。</p>
</li>
<li><p>没有拥塞控制。</p>
</li>
<li><p>支持一对一、一对多、多对一、多对多通信。</p>
</li>
<li><p>8字节首部，开销小：</p>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%BF%90%E8%BE%93%E5%B1%82/1-1597984821765.png" alt="1"></p>
</li>
</ol>
<h1 id="传输控制协议TCP（Transmission-Control-Protocol）"><a href="#传输控制协议TCP（Transmission-Control-Protocol）" class="headerlink" title="传输控制协议TCP（Transmission Control Protocol）"></a>传输控制协议TCP（Transmission Control Protocol）</h1><ol>
<li><p>可靠交付，传送数据前必须建立TCP连接。</p>
</li>
<li><p>有拥塞控制。</p>
</li>
<li><p>每一条TCP连接只能是点对点（一对一），全双工通信（双向同时通信）。</p>
</li>
<li><p>最小20字节首部，开销较大：</p>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%BF%90%E8%BE%93%E5%B1%82/2.png" alt="2"></p>
<ul>
<li>源端口和目标端口：各占2字节。</li>
<li>序号：占4字节，对字节流进行编号，如序号为301，表示第一个字节的编号为301，若携带数据长度为100字节，则下一个报文段的序号应该为401。4字节&#x3D;32位，可对4GB数据进行编号。</li>
<li>确认号：占4字节，期望收到下一个报文段的序号。如服务器正确收到客户的一个序号为501的报文段，携带数据长度为200字节，因此服务器期望下一个报文段的序号为701，即发给客户的确认报文段中确认号为701。</li>
<li>数据偏移：占4位，指TCP首部的长度。单位是4字节，也就是说TCP首部最大长度为60字节。</li>
<li>保留：占6位，保留，目前置0。</li>
<li>紧急URG：占1位，为1时表示此报文段中有紧急数据，发送方应优先传送。</li>
<li>确认ACK：占1位，为1时确认号字段有效，TCP连接建立后所有报文段必须把ACK置1。</li>
<li>推送PSH：占1位，为1时接收方会尽快交付给接收进程。</li>
<li>复位RST：占1位，RST&#x3D;1表示连接中存在严重差错，必须重新建立连接，或用于拒绝非法报文，或拒绝打开一个连接。</li>
<li>同步SYN：占1位，建立连接时用于同步序号。SYN&#x3D;1，ACK&#x3D;0表示连接请求报文段，若对方同意，则响应报文中SYN&#x3D;1，ACK&#x3D;1。</li>
<li>终止FIN：占1位，用于释放一个连接。FIN&#x3D;1表示此报文段的发送方要求释放连接。</li>
<li>窗口：占2字节，告诉对方自己能接收的数据流字节长度。</li>
</ul>
</li>
</ol>
<h2 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h2><ul>
<li>序号和确认号机制。</li>
<li>超时重传。</li>
<li>拥塞控制。</li>
</ul>
<h2 id="TCP的滑动窗口协议"><a href="#TCP的滑动窗口协议" class="headerlink" title="TCP的滑动窗口协议"></a>TCP的滑动窗口协议</h2><p>发送方和接收方各有一个窗口用于缓存数据。发送缓存用于暂时存放准备发送的数据和已发送而尚未确认的数据。接收缓存用于暂时存放按序到达但尚未被接收进程读取的数据和未按序到达的数据。</p>
<h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方可以通过确认报文中的窗口字段来控制发送方的窗口大小，从而影响发送方的发送速率。</p>
<h2 id="TCP的拥塞控制方法"><a href="#TCP的拥塞控制方法" class="headerlink" title="TCP的拥塞控制方法"></a>TCP的拥塞控制方法</h2><p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%BF%90%E8%BE%93%E5%B1%82/3.png" alt="3"></p>
<ol>
<li>慢开始：由小到大逐渐增大发送窗口（拥塞窗口），每收到一个确认，窗口长度（cwnd）×2，cwnd超过阈值ssthresh时，停止使用慢开始算法而改用拥塞避免算法（图中点①）。若出现超时，则设置ssthresh&#x3D;cwnd&#x2F;2，并重新执行慢开始算法（图中点②）。</li>
<li>拥塞避免：让发送窗口缓慢地增大，每收到一个确认，把cwnd加1。</li>
<li>快重传：接受方如果收到失序的报文段，要立即发出前一个报文段的重复确认，发送方只要一连收到3个重复确认，应立即执行快重传（图中点④），重新发送失序报文段。</li>
<li>快恢复：若发送方一连收到3个重复确认，知道只是丢失了个别字段而不是堵塞，于是不重新启动慢开始算法，而是执行快恢复算法，调整ssthresh&#x3D;cwnd&#x2F;2，同时设置cwnd&#x3D;cwnd&#x2F;2，并开始执行拥塞避免算法（图中点⑤）。</li>
</ol>
<h2 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h2><p>TCP连接的端点为套接字（socket）或插口：</p>
<p>$$ 套接字socket&#x3D;（IP地址：端口号） $$</p>
<p>每一条TCP连接由两个套接字确定。发起连接的进程称为客户（client），被动等待连接的进程称为服务器（server）。</p>
<h3 id="TCP的连接建立（三次握手，三报文握手）"><a href="#TCP的连接建立（三次握手，三报文握手）" class="headerlink" title="TCP的连接建立（三次握手，三报文握手）"></a>TCP的连接建立（三次握手，三报文握手）</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%BF%90%E8%BE%93%E5%B1%82/4.png" alt="4"></p>
<p>如图所示，TCP建立连接时需要在客户和服务器之间交换三个TCP报文段（客户请求连接，服务器确认，客户确认）。</p>
<ol>
<li>首先服务器端处于监听状态，等待客户的连接请求。</li>
<li>客户向服务器端发送连接请求SYN报文，序列号为x。</li>
<li>服务器收到连接请求报文，向客户发送连接确认SYN，ACK报文，序列号为y，确认号为x+1。</li>
<li>客户收到服务器的连接确认报文后，向服务器发出确认ACK报文，序列号为x+1确认号为，y+1。</li>
<li>服务器收到确认后，建立连接。</li>
</ol>
<p>第三次握手的原因：防止失效的连接请求到达服务器，让服务器错误打开连接。若客户的某个连接请求在网络中滞留时间过长，客户会重新请求连接，但滞留的连接请求还是会到达服务器，如果不进行第三次握手，那么服务器会打开两个连接。进行第三次握手使得最终连接权在客户。</p>
<h3 id="TCP的连接释放（四次挥手，四报文握手）"><a href="#TCP的连接释放（四次挥手，四报文握手）" class="headerlink" title="TCP的连接释放（四次挥手，四报文握手）"></a>TCP的连接释放（四次挥手，四报文握手）</h3><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%BF%90%E8%BE%93%E5%B1%82/5.png" alt="5"></p>
<p>TCP连接释放过程如图所示（客户请求释放，服务器确认，服务器请求释放，客户确认）。</p>
<ol>
<li>客户的进程向其TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接。</li>
<li>客户把连接释放报文段的FIN置1并发送给服务器，客户进入终止等待1状态，等待服务器的确认。</li>
<li>服务器收到连接释放报文段后发出确认，然后进入关闭等待状态。服务器通知进程，此时客户到服务器的连接释放了，但是服务器到客户的连接还未关闭。</li>
<li>客户收到服务器的确认后，进入终止等待2状态，继续等待服务器的连接释放报文。</li>
<li>若服务器没有要向客户端发送的数据，则向客户发出连接释放报文，必须使FIN&#x3D;1，进入最后确认状态。</li>
<li>客户收到服务器的连接释放报文后，对此发出确认，进入时间等待状态，等待2MSL（最长报文寿命，4min）后释放连接。</li>
<li>服务器收到确认报文后释放连接。</li>
</ol>
<p>客户等待2MSL的原因：</p>
<ol>
<li>为了保证客户的最后一个确认报文到达服务器，如果服务器没收到客户的确认报文，则会再次发送连接释放报文。</li>
<li>为了保证本次连接的所有报文已经从网络中消失。</li>
</ol>
<p>为什么不能三次挥手：第三次挥手时可能数据包丢失，那么客户端将一直处于FIN-WAIT-2状态。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《计算机网络 第七版》谢希仁</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>运输层</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络三：应用层</title>
    <url>/2020/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<p>本文整理计算机网络中应用层的主要知识点。</p>
<a id="more"></a>

<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/6.png" alt="6"></p>
<h1 id="DNS——域名系统"><a href="#DNS——域名系统" class="headerlink" title="DNS——域名系统"></a>DNS——域名系统</h1><p>主机不仅有IP地址，还有便于用户记忆的主机名字。DNS能够将互联网上的主机名字转换为IP地址。</p>
<ul>
<li>域名具有层次结构：</li>
</ul>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/2.png" alt="2"></p>
<ul>
<li>级别最低的域名写在最左边，级别最高的域名写在最右边：</li>
</ul>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/1.png" alt="1"></p>
<ul>
<li><p>域名到IP的解析过程：</p>
<ol>
<li><p>应用进程调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器。</p>
</li>
<li><p>若本地域名服务器能解析该域名，把对应的IP地址放在回答报文中返回。</p>
</li>
<li><p>若本地域名服务器不能回答该请求，则此域名服务器就暂时成为DNS中的另一个客户，并向其他域名服务器发出查询请求：</p>
<ul>
<li>迭代查询（常用）：其他域名服务器收到域名服务器的查询请求报文时，返回IP或告诉本地域名服务器下一步应该向哪一个域名服务器查询。</li>
<li>递归查询：其他域名服务器收到域名服务器的查询请求报文时，返回IP或成为DNS客户继续向其他域名服务器查询。</li>
</ul>
<p>其他域名服务器采用哪种查询方式取决于最初的查询报文的设置。</p>
</li>
</ol>
</li>
<li><p>域名服务器和主机中广泛地使用了高速缓存来存放最近查询的域名以及从何处获得域名映射信息的记录。</p>
</li>
</ul>
<h1 id="FTP——文件传送协议"><a href="#FTP——文件传送协议" class="headerlink" title="FTP——文件传送协议"></a>FTP——文件传送协议</h1><ul>
<li>FTP使用客户服务器方式。FTP服务器进程包括两大部分：<ul>
<li>一个进程：负责接受新的请求。</li>
<li>若干个从属进程：负责处理单个请求。</li>
</ul>
</li>
<li>FTP使用TCP进行连接，需要两个TCP连接（控制连接和文件传送连接）来传送一个文件。</li>
<li>主进程工作步骤如下：<ol>
<li>打开端口熟知端口21，等待客户发出连接请求。</li>
<li>启动从属进程处理客户的请求。<ul>
<li>控制进程：接收到客户通过“控制连接”发送的文件传送请求后，利用自己的熟知端口20与客户提供的端口号建立“数据连接”，并打开“数据传送进程”。</li>
<li>数据传送进程：用于传送文件数据，传送完毕后关闭。</li>
</ul>
</li>
<li>回到等待状态。</li>
</ol>
</li>
<li>简单文件传送协议TFTP使用UDP连接。</li>
</ul>
<h1 id="TELNET——远程终端协议"><a href="#TELNET——远程终端协议" class="headerlink" title="TELNET——远程终端协议"></a>TELNET——远程终端协议</h1><p>TELNET通过TCP连接登录，能将客户的击键传送到服务器，同时也能将服务器的输出返回到客户屏幕，可以适应许多计算机和操作系统的差异。和FTP情况类似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。</p>
<h1 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h1><ul>
<li><p>一个电子邮件系统由三部分组成：</p>
<ul>
<li>用户代理：用户与电子邮件系统的接口，即客户端软件。</li>
<li>邮件服务器：发送和接收邮件等。</li>
<li>邮件协议：发送协议SMTP，读取协议POP3或IMAP，都是使用TCP连接。</li>
</ul>
</li>
<li><p>电子邮件发送和接收步骤：</p>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/3.png" alt="3"></p>
<ol>
<li><p>用户代理用SMTP协议将邮件发给邮件服务器。</p>
</li>
<li><p>邮件服务器将邮件临时存放在邮件缓存队列中，等待发送到邮件服务器。</p>
</li>
<li><p>发送方邮件服务器的SMTP客户与接收方邮件服务器的SMTP服务器建立TCP连接，然后把邮件缓存队里中的邮件依次发出去。</p>
</li>
<li><p>接收方的SMTP服务器把邮件放入收件人的用户邮箱。</p>
</li>
<li><p>收件人使用POP3（或IMAP）协议读取邮件。</p>
</li>
</ol>
</li>
</ul>
<h2 id="SMTP——简单邮件传送协议"><a href="#SMTP——简单邮件传送协议" class="headerlink" title="SMTP——简单邮件传送协议"></a>SMTP——简单邮件传送协议</h2><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>
<h2 id="POP3——邮局协议"><a href="#POP3——邮局协议" class="headerlink" title="POP3——邮局协议"></a>POP3——邮局协议</h2><p>POP3 的特点是只要用户从POP3服务器上读取了邮件，POP3就把该邮件删除。功能扩充的 POP3 可以设置读取后的存放时间。</p>
<h2 id="IMAP——网际报文存取协议"><a href="#IMAP——网际报文存取协议" class="headerlink" title="IMAP——网际报文存取协议"></a>IMAP——网际报文存取协议</h2><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>
<h1 id="DHCP——动态主机配置协议"><a href="#DHCP——动态主机配置协议" class="headerlink" title="DHCP——动态主机配置协议"></a>DHCP——动态主机配置协议</h1><p>DHCP提供了一种即插即用连网的机制，自动配置IP地址、子网掩码和网关IP地址。</p>
<p>工作过程：</p>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/4.png" alt="4"></p>
<ol>
<li>需要IP地址的主机以广播方式发送发现报文，该报文目的地址为255.255.255.255:67，源地址为0.0.0.0:68，被放入UDP中。</li>
<li>DHCP中继代理（通常是一台路由器）收到发现报文后，以单播方式向DHCP服务器转发此报文。</li>
<li>收到DHCP服务器回答的提供报文后，DHCP中继代理再把此提供报文发回给主机。</li>
</ol>
<h1 id="HTTP——超文本传送协议"><a href="#HTTP——超文本传送协议" class="headerlink" title="HTTP——超文本传送协议"></a>HTTP——超文本传送协议</h1><p>HTTP协议是客户和服务器之间进行请求和应答的格式和规范。</p>
<p>HTTP使用了TCP作为运输层协议，但是HTTP本身是<strong>无连接的</strong>，也就是说通信双方在交换HTTP报文之前不需要先建立HTTP连接。</p>
<p>HTTP协议是<strong>无状态的</strong>，也就是说同一个客户第二次访问同一个服务器的页面时，服务器的响应与第一次访问相同。</p>
<p><strong>在浏览器地址栏键入URL，按下回车之后会经历以下流程：</strong></p>
<ol>
<li>浏览器向本地DNS服务器请求解析该URL中的域名对应的IP地址。</li>
<li>根据该IP地址和默认端口80，与服务器建立TCP连接，HTTP请求报文会被放入TCP连接三次握手的第三个报文数据中发给服务器。</li>
<li>服务器对浏览器请求做出响应，并把所请求的文档作为响应报文返回给浏览器。</li>
<li>HTTP&#x2F;1.0立即释放TCP连接，HTTP&#x2F;1.1在一段时间内保持该连接。</li>
<li>浏览器显示文档内容。</li>
</ol>
<h2 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h2><p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/5.png" alt="5"></p>
<p>HTTP有两类报文：</p>
<ul>
<li><p>请求报文：从客户向服务器发送请求报文。</p>
<ul>
<li>请求报文常用的方法：</li>
</ul>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/7.png" alt="7"></p>
</li>
<li><p>响应报文：从服务器到客户的回答。</p>
<ul>
<li>响应报文状态码包括：<ul>
<li>1xx表示通知信息，如100表示客户应继续请求，101表示服务器切换高版本协议。</li>
<li>2xx表示成功，如200表示请求成功，202表示已接受请求但还未处理完成。</li>
<li>3xx表示重定向，如301表示永久转移并重定向到新的url。</li>
<li>4xx表示客户错误，如400表示语法错误，404表示找不到资源 。</li>
<li>5xx表示服务器错误，如500表示服务器内部错误，501当前无法处理请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h2><ol>
<li><p>Get将参数放在URL中，POST将参数放在RequestBody，所以Get的参数是直接暴露的。</p>
</li>
<li><p>Post在浏览器回退时会重新请求，Get不会。</p>
</li>
<li><p>Get可传递的参数有长度限制，Post没有。</p>
</li>
<li><p>Get会将header和data一起发送出去，服务器响应状态码200；</p>
<p>而Post先发送header，服务器响应状态码100，然后再发送data，服务器响应状态码200。</p>
</li>
</ol>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>当浏览器首次访问使用Cookie的网站时，服务器为浏览器生成一个唯一识别码通过Set-cookie字段返回给浏览器，然后浏览器将Cookie保存在本地，此后浏览器再次访问该网站时，都会将该Cookie放在HTTP请求报文的Cookie字段中。</p>
<p>Cookie可携带的信息有限（4k），并且是存在本地浏览器，任何人都可以查看。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session通过Cookie传递SessionID，服务器可以通过SessionID找到对应的浏览器信息。</p>
<h2 id="Cookie被禁用了怎么办"><a href="#Cookie被禁用了怎么办" class="headerlink" title="Cookie被禁用了怎么办"></a>Cookie被禁用了怎么办</h2><p>直接把SessionID附加在URL路径后面。</p>
<h2 id="HTTP-2-0的主要新特性"><a href="#HTTP-2-0的主要新特性" class="headerlink" title="HTTP 2.0的主要新特性"></a>HTTP 2.0的主要新特性</h2><ol>
<li>新的二进制格式：HTTP 1.x基于文本解析，HTTP 2.0采用二进制格式。</li>
<li>多路复用：一个TCP连接中会存在多个请求流，每个<strong>帧</strong>会标识出该帧属于哪个流，接收方根据流标识符重新组装请求流。</li>
<li>header压缩</li>
<li>服务器推送</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《计算机网络 第七版》谢希仁</p>
<p><a href="https://www.jianshu.com/p/14cd2c9d2cd2" target="_blank" rel="noopener">https://www.jianshu.com/p/14cd2c9d2cd2</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>应用层</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络四：网络安全</title>
    <url>/2020/07/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>本文整理计算机网络中网络安全的主要知识点。</p>
<a id="more"></a>

<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>加密秘钥&#x3D;解密秘钥，常用加密算法DES等</p>
<h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><ul>
<li>公钥加密，私钥解密。</li>
<li>公钥是向公众公开的，私钥是保密的。</li>
<li>无法从公钥推到出私钥。</li>
</ul>
<p>常用加密算法RSA等。</p>
<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>数字签名必须保证实现三个功能：</p>
<ul>
<li>报文鉴别：接收者能够确信该报文的确是发送者发送的，其他人无法伪造签名。</li>
<li>报文完整性：接收者能够确信收到的数据没有被篡改过。</li>
<li>不可否认：发送者事后无法对报文的签名抵赖。</li>
</ul>
<p>A使用非对称加密的<strong>私钥</strong>对报文进行加密，B使用A的<strong>公钥</strong>获得明文核实签名。由于私钥只有A知道，因此若B能从密文中解出可读的明文，则能确定A的身份。</p>
<p>但是由于A的公钥是公开的，任何人获得私钥加密后的报文都能解出报文的内容，因此上述过程仅对报文进行了签名，而报文本身无法保密。</p>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/1.png" alt="1"></p>
<p>使用如上图所示的过程可以同时实现加密通信和数字签名：</p>
<ol>
<li>签名：发送方使用A的<strong>私钥</strong>对报文进行加密，实现签名。</li>
<li>加密：发送方使用B的<strong>公钥</strong>进一步进行加密，实现报文加密。</li>
<li>解密：接收方使用B的<strong>私钥</strong>进行解密，实现报文解密。</li>
<li>核实签名：接收方使用A的<strong>公钥</strong>进行解密，实现核实签名。</li>
</ol>
<h1 id="鉴别"><a href="#鉴别" class="headerlink" title="鉴别"></a>鉴别</h1><p>鉴别是为了验证通信的对方是自己要通信的对象，并且所传送的报文是完整的，没被他人篡改的。</p>
<h2 id="报文鉴别"><a href="#报文鉴别" class="headerlink" title="报文鉴别"></a>报文鉴别</h2><p>理论上，数字签名可以实现报文鉴别，但是对较长的报文进行数字签名十分耗时。因此采用一种相对简单的方法来对报文进行鉴别——密码散列函数。</p>
<p>密码散列函数的特点是要找到一种密码散列函数使得两个不同的报文X$\neq$Y对应的输出H(X)&#x3D;H(Y)在计算上时不可行的。这就是说，如果我们固定长度的H(X)被他人截获了，那么截获者也无法伪造出另一个明文Y使得H(X)&#x3D;H(Y)。换言之，散列H(X)可以保护明文的完整性。</p>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/2.png" alt="2"></p>
<p>但是密码散列函数是单向函数，只能单向变换，不能逆向变换。因此，发送方需要同时发送明文及其散列(X,H(X))。</p>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/3.png" alt="3"></p>
<p><strong>报文鉴别流程（数字签名及验证）：</strong></p>
<ol>
<li>A从报文导出散列，使用<strong>私钥</strong>并对散列进行加密，得到报文鉴别码MAC（Message Authentication Code），然后把报文鉴别码拼接在报文后面，发送给B。</li>
<li>B收到扩展的报文后，先把报文鉴别码与报文分离出来，然后使用<strong>公钥</strong>对报文鉴别码进行解密，得到散列，再把报文进行散列函数运算并与解密得到的散列进行比较。若一致，则可以相信报文确实是A发送，完成报文鉴别。</li>
</ol>
<p>可以看出，A使用保密的私钥进行加密，使得这样得到的报文不仅是不可伪造的，也是不可否认的。</p>
<p>常用的密码散列函数有：</p>
<ul>
<li>MD5:128位。</li>
<li>SHA-1:160位，比MD5更安全，但计算也更慢。</li>
</ul>
<h2 id="实体鉴别"><a href="#实体鉴别" class="headerlink" title="实体鉴别"></a>实体鉴别</h2><p>报文鉴别需要对每一个收到的报文鉴别其发送者，而实体鉴别在系统接入的全部持续时间内和自己通信的对方实体只需要验证一次。</p>
<p>最简单的实体鉴别：</p>
<ol>
<li>A向B发送带有自己身份的报文，并用对称密钥进行加密。</li>
<li>B收到报文后，对其进行解密鉴别A的身份。</li>
</ol>
<p>然而这种方法易被<strong>重放攻击</strong>，入侵者可以截获加密的报文并直接发送给B，然后截获A的IP地址冒充为自己的IP地址，B就会向入侵者发送许多本应发给A的报文。</p>
<p>为了对付重放攻击，可以使用<strong>不重数</strong>，不重数就是一个不重复的大随机数，即“一次一数”。</p>
<p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/4.png" alt="4"></p>
<p>不重数实体鉴别：</p>
<ol>
<li>A向B发送明文身份信息和一个不重数$R_A$。</li>
<li>B用对称秘钥（或B的私钥）对$R_A$加密，并附加一个不重数$R_B$，发回给A。</li>
<li>A用对称秘钥对加密后的$R_A$进行解密并与$R_A$进行比较，鉴别B的身份；A再用对称秘钥（或A的私钥）对$R_B$进行加密后发回给B。</li>
<li>B用对称密钥（或A的私钥）对加密后的$R_B$进行解密并与$R_B$进行比较，鉴别A的身份。</li>
</ol>
<p>但不重数实体鉴别仍有被<strong>中间人攻击</strong>的可能，如图所示：</p>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/5.png" alt="5"></p>
<ol>
<li>A向B发送身份明文，被中间人截获并原封不动发给B。</li>
<li>B发送一个不重数$R_B$给A，被中间人截获并原封不动发给A。</li>
<li>A收到$R_B$后，用A的私钥对其进行加密并发送给B，被中间人截获并丢弃，然后中间人使用自己的私钥对$R_B$进行加密并发给B。</li>
<li>B向A索要A的公钥，被中间人截获并原封不动发给A。</li>
<li>A向B发送A的公钥，被中间人截获并保留，然后中间人把自己的公钥发给B。</li>
<li>B收到公钥后发现一切正常，即使用中间人的公钥对数据进行加密并发送给A，被中间人截获，中间人用自己的私钥解密数据并复制一份，然后再用A的公钥对数据进行加密并发送给A。</li>
</ol>
<p>这样B发给A的数据已经被中间人截获，而A和B却不知道。</p>
<p>由此可见，公钥的分配和认证公钥的真实性也是一个重要问题。</p>
<h1 id="密钥分配"><a href="#密钥分配" class="headerlink" title="密钥分配"></a>密钥分配</h1><p>密钥分配是密钥管理中最大的问题。</p>
<h2 id="对称密钥的分配"><a href="#对称密钥的分配" class="headerlink" title="对称密钥的分配"></a>对称密钥的分配</h2><p>常用的密钥分配方式是设立密钥分配中心KDC（Key Distribution Center）。</p>
<h2 id="公钥的分配"><a href="#公钥的分配" class="headerlink" title="公钥的分配"></a>公钥的分配</h2><p>每个实体都有认证中心CA（Certification Authority）发的证书，里面有公钥及其拥有者的标识信息（人名或IP地址），此证书被CA进行了数字签名（即CA使用私钥对其进行了加密），用户可以从可信的地方获得CA的公钥来解密证书验证实体及其公钥。</p>
<h1 id="运输层安全协议SSL-x2F-TLS"><a href="#运输层安全协议SSL-x2F-TLS" class="headerlink" title="运输层安全协议SSL&#x2F;TLS"></a>运输层安全协议SSL&#x2F;TLS</h1><p>应用层使用SSL最多的是HTTP，但也可用于IMAP邮件存取的鉴别和数据加密等。</p>
<p>当HTTP调用SSL对网页进行加密时，网址栏原本显示http的地方就变成了https。在发送方，SSL对HTTP报文进行加密然后向下发送给TCP套接字；在接收方，SSL从TCP套接字读取数据并解密。</p>
<p>SSL提供的安全服务有三种：SSL服务器鉴别、SSL客户鉴别、加密的SSL会话。</p>
<p><img src="/./images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/6.png" alt="6"></p>
<p>https流程（SSL握手）：</p>
<ol>
<li>协商加密算法：浏览器向服务器发送其SSL版本号和可用的加密算法；服务器从中选定主机支持的算法并发回给浏览器。</li>
<li>服务器鉴别：服务器向浏览器发送包含公钥和服务器信息的数字证书；浏览器使用认证中心的公钥对证书进行验证。</li>
<li>会话密钥计算：浏览器产生一个随机数并使用服务器的公钥加密后发给服务器；服务器使用私钥解密出随机数。浏览器和服务器用随机数产生对称密钥。</li>
<li>浏览器将所有握手信息的MAC值发送给服务器，服务器将所有握手信息的MAC值发送给浏览器。</li>
<li>安全数据传输：浏览器和服务器通过对称密钥加密和解密它们之间传送的数据并验证其完整性。</li>
</ol>
<h2 id="为什么数据传输时采用对称加密？"><a href="#为什么数据传输时采用对称加密？" class="headerlink" title="为什么数据传输时采用对称加密？"></a>为什么数据传输时采用对称加密？</h2><ol>
<li>非对称加密解密效率低，在https场景中，采用对称加密可以用更快的响应速度。</li>
<li>只有服务器端保存了私钥，一对公私钥只能实现单向的加解密。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《计算机网络 第七版》谢希仁</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
</search>
