<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clover</title>
  
  <subtitle>学无止境</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://djsFFF.github.io/"/>
  <updated>2023-05-01T01:42:48.887Z</updated>
  <id>http://djsFFF.github.io/</id>
  
  <author>
    <name>Clover</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《金字塔原理》学习笔记</title>
    <link href="http://djsFFF.github.io/2023/05/01/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://djsFFF.github.io/2023/05/01/金字塔原理学习笔记/</id>
    <published>2023-05-01T01:40:08.000Z</published>
    <updated>2023-05-01T01:42:48.887Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="学习笔记" scheme="http://djsFFF.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://djsFFF.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统</title>
    <link href="http://djsFFF.github.io/2022/01/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://djsFFF.github.io/2022/01/26/深入理解计算机系统/</id>
    <published>2022-01-26T14:34:47.000Z</published>
    <updated>2023-05-01T01:37:16.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h4 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h4><p><img src="/../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20220126230603179.png" alt="image-20220126230603179"></p><ul><li><strong>总线：</strong>贯穿整个系统的一组电子管道，传送定长的字节块，也就是字。32位系统中1字&#x3D;4字节&#x3D;32位，64位系统中1字&#x3D;8字节&#x3D;64位。</li><li><strong>I&#x2F;O设备：</strong>图中有鼠标、键盘、显示器、磁盘。通过控制器或者适配器与<strong>I&#x2F;O总线</strong>相连。</li><li><strong>主存：</strong>临时存储设备，在处理执行程序时，存放程序和程序处理的数据。由一组<strong>动态随机存储器（DRAM）</strong>芯片组成。</li><li><strong>CPU（处理器）：</strong>中央处理单元，是执行存储在主存中指令的引擎。核心是一个大小为<strong>一个字</strong>的<strong>寄存器</strong>（<strong>程序计数器，PC</strong>），PC始终指向主存中的某条机器语言指令，CPU负责执行PC指向的指令，并更新PC。CPU在指令的要求下可能执行的操作包括：<ul><li><strong>加载：</strong>从主存复制一个字节或一个字到寄存器。</li><li><strong>存储：</strong>从寄存器复制一个字节或一个字到主存中。</li><li><strong>操作：</strong>将两个寄存器的内容复制到ALU，ALU对这两个字做算术运算并将结果存放到一个寄存器中。</li><li><strong>跳转：</strong>从指令本身中抽取一个字复制到PC中。</li></ul></li><li><strong>寄存器文件：</strong>由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。</li><li><strong>ALU（算术&#x2F;逻辑单元）：</strong>负责计算新的数据和地址值。</li></ul><h4 id="运行可执行文件"><a href="#运行可执行文件" class="headerlink" title="运行可执行文件"></a>运行可执行文件</h4><ol><li>在shell程序中输入可执行文件名，shell程序会将文件名做为一个指令读入到寄存器，再存放到内存中。</li><li>运行可执行文件时，shell首先执行一系列指令来加载可执行文件，会将目标文件中的代码通过<strong>DMA（直接存储器存取）</strong>技术直接从磁盘复制到主存。</li><li>处理器开始运行可执行文件，需要将文件中的机器语言指令从主存中复制到寄存器，执行结果再复制到显示设备。</li></ol><h4 id="高速缓存的重要性"><a href="#高速缓存的重要性" class="headerlink" title="高速缓存的重要性"></a>高速缓存的重要性</h4><p><img src="/../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20220127175645947.png" alt="image-20220127175645947"></p><p>​主存和寄存器直接的读写速度相差大约100倍，因此添加高速缓存存储器来存放处理器近期可能需要的信息（<strong>局部性原理</strong>）。典型的高速缓存存储器可能由多级高速缓存组成（L1、L2），这些高速缓存是用<strong>SRAM（静态随机访问存储器）</strong>的硬件技术实现的。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>​进程是对运行的程序的一种抽象，进程切换是由<strong>操作系统内核</strong>管理的，内核是操作系统代码常驻主存的部分。</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p><img src="/../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20220128084821826.png" alt="image-20220128084821826"></p><ul><li>程序代码和数据：所有进程的代码都是从同一固定地址开始的，代码和数据区就是根据可执行文件内容初始化的。</li><li>堆：堆区用于代码运行时内存分配，可以通过malloc和free等方法动态分配。</li><li>共享库：存放类似C标准卡和数学库的区域。</li><li>栈：栈区用于调用方法时分配，可以在执行程序时动态分配。</li><li>内核虚拟内存：为内核保留的。</li></ul><h1 id="程序结构和执行"><a href="#程序结构和执行" class="headerlink" title="程序结构和执行"></a>程序结构和执行</h1><h2 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h2><h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h3><p>​字长决定了虚拟地址空间的大小，例如对于一个32位机器来说，字长为4字节，虚拟地址的最大为$2^{32}-1$，通常一个地址表示一个字节。</p><h3 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h3><ul><li>无符号整数：00000000-11111111，范围为0~255。</li><li>有符号整数：10000000-01111111，<strong>补码</strong>形式，最高位为负权，10000000&#x3D;$-2^8$&#x3D;-128，01111111&#x3D;127。再比如10001111&#x3D;-10000000+00001111&#x3D;-128+15&#x3D;-113。因此，补码表示的正负范围是不对称的。当运算结果溢出时，会对结果进行截断，仅保留类型支持的位数。</li></ul><h3 id="小数表示"><a href="#小数表示" class="headerlink" title="小数表示"></a>小数表示</h3><h4 id="普通浮点表示"><a href="#普通浮点表示" class="headerlink" title="普通浮点表示"></a>普通浮点表示</h4><p>​0.0&#x3D;0&#x2F;2&#x3D;00.01&#x3D;1&#x2F;4&#x3D;0.250.11&#x3D;1&#x2F;2 + 1&#x2F;4 &#x3D; 0.75</p><p>​从上面的表示方法可以看出，普通的小数的二进制表示法只能表示那些小数位为2的次幂的小数，而像1&#x2F;5这样的小数无法准确表示。</p><h4 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h4><p><a href="https://zhuanlan.zhihu.com/p/358417700" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/358417700</a></p><p><img src="/../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20220207153702578.png" alt="image-20220207153702578"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h4 id=&quot;系统的硬件组成&quot;&gt;&lt;a href=&quot;#系统的硬件组成&quot; class=&quot;headerlink&quot; title=&quot;系统的硬件组成&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="操作系统" scheme="http://djsFFF.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="笔记" scheme="http://djsFFF.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>牛客算法课程笔记</title>
    <link href="http://djsFFF.github.io/2022/01/01/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://djsFFF.github.io/2022/01/01/牛客算法课程笔记/</id>
    <published>2022-01-01T00:16:30.000Z</published>
    <updated>2023-05-01T01:37:16.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="异或运算可以理解为无进位加法"><a href="#异或运算可以理解为无进位加法" class="headerlink" title="异或运算可以理解为无进位加法"></a>异或运算可以理解为无进位加法</h3><ul><li><code>a ^ a = 0</code>, <code>a ^ 0 = 0</code></li><li>交换两个数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="1-快排改进步骤"><a href="#1-快排改进步骤" class="headerlink" title="1. 快排改进步骤"></a>1. 快排改进步骤</h4><ul><li><p>改进一：每次递归的时候，将与划分值相等的值放在一起（荷兰国旗问题），不需要再参与递归。</p><ul><li>左右两端分别保存小于和大于划分值的元素</li></ul></li><li><p>改进二：每次随机选取划分值，使得平均复杂度为O(nlogn)。</p></li></ul><h4 id="2-桶排序"><a href="#2-桶排序" class="headerlink" title="2. 桶排序"></a>2. 桶排序</h4><ul><li>计数排序：统计数组中每种数字的频率，适用于最小值和最大值相差不大的情况。</li><li>基数排序：从个位到最高位（权重从低到高），每次按元素的对应位排序。</li></ul><h4 id="3-排序算法总结"><a href="#3-排序算法总结" class="headerlink" title="3. 排序算法总结"></a>3. 排序算法总结</h4><ul><li>不稳定：选择排序、快速排序、堆排序。</li><li>稳定：冒泡排序（相邻相等时不交换）、插入排序（插入到相等值的后面）、归并排序（合并遇到相等时先合入左边数组）。</li></ul><table><thead><tr><th align="center">排序算法</th><th align="center">时间复杂度</th><th align="center">空间复杂度</th><th align="center">稳定性</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">选择排序</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">x</td><td align="center"></td></tr><tr><td align="center">冒泡排序</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">✓</td><td align="center"></td></tr><tr><td align="center">插入排序</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">✓</td><td align="center"></td></tr><tr><td align="center">归并排序</td><td align="center">O(nlogn)</td><td align="center">O(n)</td><td align="center">✓</td><td align="center">稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(nlogn)</td><td align="center">O(1)</td><td align="center">x</td><td align="center">空间小</td></tr><tr><td align="center">快速排序</td><td align="center">O(nlogn)</td><td align="center">O(logn)</td><td align="center">x</td><td align="center">最快（常数时间小）</td></tr><tr><td align="center">桶排序</td><td align="center">O(n)</td><td align="center">O(n)</td><td align="center">✓</td><td align="center"></td></tr></tbody></table><p>​综合排序：快排的时候，当传入的子数组元素小于60时，采用插入排序。</p><p><img src="/../images/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220106080043599.png" alt="image-20220106080043599"> </p><h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><ul><li>返回负数：第一个参数排在前面。</li><li>返回正数：第二个参数排在前面。</li><li>返回0：默认第一个排在前面。</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="1-判断单链表是否有环"><a href="#1-判断单链表是否有环" class="headerlink" title="1. 判断单链表是否有环"></a>1. 判断单链表是否有环</h4><p>(1) 快慢指针从表头出发，快指针每次移动两个节点，慢指针每次移动一个节点。</p><p>(2) 若快指针为空，链表无环。</p><p>(3) 若快慢指针相交，链表有环。</p><h4 id="2-求单链表入环节点"><a href="#2-求单链表入环节点" class="headerlink" title="2. 求单链表入环节点"></a>2. 求单链表入环节点</h4><p>(1) 判断单链表是否有环。</p><p>(2) 若单链表有环，快慢指针相交点为环内某个节点。</p><p>(3) 快指针重新从表头出发，快慢指针每次移动一个节点。</p><p>(4) 返回快慢指针再次相交的节点。</p><h4 id="3-求两个链表的第一个交点（是否有环→是否有交点→求第一个交点）"><a href="#3-求两个链表的第一个交点（是否有环→是否有交点→求第一个交点）" class="headerlink" title="3. 求两个链表的第一个交点（是否有环→是否有交点→求第一个交点）"></a>3. 求两个链表的第一个交点（是否有环→是否有交点→求第一个交点）</h4><p>(1) 分别判断两个链表是否有环。</p><p>(2) 若一个存在环，一个不存在环，则两个链表<strong>无交点</strong>。</p><p>(3) 若两个链表<strong>都不存在环</strong>：</p><p>​① 分别遍历两个链表并记录链表长度。</p><p>​② 若表尾不相交，则两个链表<strong>无交点</strong>，否则有交点。</p><p>​③ 长链表指针从表头先移动$长度差$个节点，然后两个指针同时移动。</p><p>​④ 返回两个指针第一次相交的节点。</p><p>(4) 若两个链表都存在环：</p><p>​① 分别求两个链表入环节点。</p><p>​② 若入环节点相同：</p><p>​Ⅰ 分别遍历两个链表到入环节点并记录长度。</p><p>​Ⅱ 长链表指针从表头先移动$长度差$个节点，然后两个指针同时移动。</p><p>​Ⅲ 返回两个指针第一次相交的节点。</p><p>​③ 若入环节点不同：</p><p>​Ⅰ 链表1从入环节点出发遍历，若再次遇到链表1的入环节点，则两个链表<strong>无交点</strong>。</p><p>​Ⅱ 若遇到链表2的入环节点，则两个链表有交点，且两个入环节点均可以看做第一个相交节点。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="1-非递归遍历"><a href="#1-非递归遍历" class="headerlink" title="1. 非递归遍历"></a>1. 非递归遍历</h4><p>(1) 先序遍历（中左右）</p><p>​① 根节点入栈。</p><p>​② while 栈不为空：</p><p>​Ⅰ 弹出栈顶元素并打印。</p><p>​Ⅱ 压入弹出元素的右子树。</p><p>​Ⅲ 压入弹出元素的左子树。</p><p>(2) 后序遍历（左右中）</p><p>​① 根节点入栈。</p><p>​② while 栈不为空：</p><p>​Ⅰ 弹出栈顶元素并记录。</p><p>​Ⅱ 压入弹出元素的左子树。</p><p>​Ⅲ 压入弹出元素的右子树。</p><p>​③ 记录到的节点顺序为中右左，将记录反转输出（用栈记录）即为左右中。</p><p>(3) 中序遍历（左中右）</p><p>​① 以根节点为cur节点。</p><p>​② while 栈不为空 || cur不为空：</p><p>​Ⅰ 从cur节点开始向左遍历到叶子节点，并依次入栈。</p><p>​Ⅱ 弹出栈顶节点并打印。</p><p>​Ⅲ 以弹出节点的右节点为cur节点。</p><h4 id="2-后继节点（对应还有前驱节点）"><a href="#2-后继节点（对应还有前驱节点）" class="headerlink" title="2. 后继节点（对应还有前驱节点）"></a>2. 后继节点（对应还有前驱节点）</h4><p>​定义：<strong>中序遍历序列</strong>中，每个节点的下一个节点为该节点的后继节点。</p><p>​(1) 若节点有右子树，其后继节点为右子树的最左节点。</p><p>​(2) 若节点无右子树，则向上遍历直到找到一个父节点，满足节点属于该父节点的子树。该父节点为节点的后继节点。</p><h4 id="3-判断二叉树是否为另一个二叉树的子树"><a href="#3-判断二叉树是否为另一个二叉树的子树" class="headerlink" title="3. 判断二叉树是否为另一个二叉树的子树"></a>3. 判断二叉树是否为另一个二叉树的子树</h4><p>递归方法复杂度较高。</p><p>可以将两个二叉树序列化为两个字符串，判断一个字符串是否为另一个字符串的子串。</p><h1 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h1><p>节点结构：</p><ul><li>pass：节点通过次数。</li><li>end：以结点为结尾的次数。</li><li>map：key为字符（根节点为空字符’’），value为下一个节点。</li></ul><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h4 id="1-拓扑排序（有向无环图，有至少一个入度为0的点）"><a href="#1-拓扑排序（有向无环图，有至少一个入度为0的点）" class="headerlink" title="1. 拓扑排序（有向无环图，有至少一个入度为0的点）"></a>1. 拓扑排序（有向无环图，有至少一个入度为0的点）</h4><p>(1) 使用一个map记录节点的入度，queue记录入度为0的节点。</p><p>(2) while queue不为空：</p><p>​① 弹出queue尾节点，并添加到result列表。</p><p>​② 遍历弹出节点的下一个节点，所有节点入度-1，若入度为0，则入queue。</p><h4 id="2-最小生成树—Prim算法"><a href="#2-最小生成树—Prim算法" class="headerlink" title="2. 最小生成树—Prim算法"></a>2. 最小生成树—Prim算法</h4><p>(1) 从任意节点node开始遍历所有节点：</p><p>​① 若set中不包含node：</p><p>​Ⅰ 将与node相连的边放入优先队列priorityQueue。</p><p>​Ⅱ while priorityQueue不为空：</p><p>​弹出一条边（最小边），若边的另一个节点不在set中，将边放入result，将节点加入set，并将节点的所有边加入priorityQueue。</p><h4 id="3-最小生成树—Kruskal算法（集合查询合并可以使用并查集）"><a href="#3-最小生成树—Kruskal算法（集合查询合并可以使用并查集）" class="headerlink" title="3. 最小生成树—Kruskal算法（集合查询合并可以使用并查集）"></a>3. 最小生成树—Kruskal算法（集合查询合并可以使用并查集）</h4><p>(1) 将每个节点各自单独存放在一个set中。</p><p>(2) 将所有边放在一个优先队列priorityQueue中。</p><p>(3) while priorityQueue不为空：</p><p>​① 弹出一条边，若边的两个节点不属于同一个set：</p><p>​Ⅰ 将边存入result。</p><p>​Ⅱ 将两个节点所在的集合合并在一起。</p><h4 id="4-Dijkstra算法—单源最短路径算法"><a href="#4-Dijkstra算法—单源最短路径算法" class="headerlink" title="4. Dijkstra算法—单源最短路径算法"></a>4. Dijkstra算法—单源最短路径算法</h4><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h4 id="1-拼接最小字典序字符串"><a href="#1-拼接最小字典序字符串" class="headerlink" title="1. 拼接最小字典序字符串"></a>1. 拼接最小字典序字符串</h4><p>若str1 + str2 &lt;&#x3D; str2 + str1，则认为str1 &lt; str2。按照这种排序方式对字符串数组进行排序后，拼接而成的即为最小字典序字符串。</p><h1 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h1><h4 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h4><p>​存在左中右三个杆，需要将左杆上的n个圆盘移动到右杆上，并保持圆盘顺序不变，每次可以将任意杆上的第一个圆盘移动到其他杆上。</p><p>​循环以下步骤：</p><p>(1) 将n - 1个圆盘从左移动到中。</p><p>(2) 将第n个圆盘从左移动到右。</p><p>(3) 将n - 1个圆盘从中移动到右。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;异或运算可以理解为无进位加法&quot;&gt;&lt;a href=&quot;#异或运算可以理解为无进位加法&quot; class=&quot;headerlink&quot; title=&quot;异或运算可以理解为无进位加法&quot;&gt;&lt;/a&gt;异或运算可以理解为无进位加法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a ^ a = 0&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://djsFFF.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔记" scheme="http://djsFFF.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>更换电脑时Hexo博客迁移流程</title>
    <link href="http://djsFFF.github.io/2021/12/31/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E6%97%B6Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E6%B5%81%E7%A8%8B/"/>
    <id>http://djsFFF.github.io/2021/12/31/更换电脑时Hexo博客迁移流程/</id>
    <published>2021-12-31T15:10:15.000Z</published>
    <updated>2023-05-01T01:37:16.615Z</updated>
    
    <content type="html"><![CDATA[<ol><li>配置环境</li></ol><p>​Mac环境下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ol start="2"><li>拉取代码</li><li>进入代码根目录，安装模块</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><ol start="4"><li>配置typora</li></ol><p><img src="/../images/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E6%97%B6Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E6%B5%81%E7%A8%8B/image-20211231232809498.png" alt="image-20211231232809498"></p><ol start="5"><li>创建新文章</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n <span class="string">"title"</span></span><br></pre></td></tr></table></figure><ol start="6"><li>提交部署</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"some descrption"</span></span><br><span class="line">git push origin hexo</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;配置环境&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	Mac环境下&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
      <category term="blog" scheme="http://djsFFF.github.io/categories/blog/"/>
    
    
      <category term="记录" scheme="http://djsFFF.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://djsFFF.github.io/2020/09/26/Kafka/"/>
    <id>http://djsFFF.github.io/2020/09/26/Kafka/</id>
    <published>2020-09-26T12:15:00.000Z</published>
    <updated>2023-05-01T01:37:16.613Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka相关知识点，主要参考《Apache Kafka实战》一书。</p><a id="more"></a><h1 id="消息队列模型与发布订阅模型"><a href="#消息队列模型与发布订阅模型" class="headerlink" title="消息队列模型与发布订阅模型"></a>消息队列模型与发布订阅模型</h1><ul><li><strong>消息队列：</strong>基于队列提供消息传输服务，点对点（p2p）的消息传递方式，也就是说一旦消息被一个消费者消费，就会从消息队列中移除该消息。</li><li><strong>发布&#x2F;订阅：</strong>有主题（topic）的概念，订阅了同一个topic的所有订阅者都能接受到该topic下的所有消息。</li></ul><h1 id="Kafka如何做到高吞吐量、低延时？"><a href="#Kafka如何做到高吞吐量、低延时？" class="headerlink" title="Kafka如何做到高吞吐量、低延时？"></a>Kafka如何做到高吞吐量、低延时？</h1><ul><li>大量使用操作系统<strong>页缓存</strong>，内存操作速度快且命中率高。</li><li>采用追加写入消息的方式，利用<strong>磁盘顺序读写</strong>的进行快速写入。</li><li>使用以sendfile为代表的<strong>零拷贝</strong>技术加强网络间的数据传输效率。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kafka相关知识点，主要参考《Apache Kafka实战》一书。&lt;/p&gt;
    
    </summary>
    
      <category term="中间件" scheme="http://djsFFF.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Kafka" scheme="http://djsFFF.github.io/tags/Kafka/"/>
    
      <category term="消息中间件" scheme="http://djsFFF.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>秒杀系统</title>
    <link href="http://djsFFF.github.io/2020/09/19/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    <id>http://djsFFF.github.io/2020/09/19/秒杀系统/</id>
    <published>2020-09-19T15:36:27.000Z</published>
    <updated>2023-05-01T01:37:16.615Z</updated>
    
    <content type="html"><![CDATA[<p>高并发秒杀系统实战。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><p><img src="/../images/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/image-20200919233729150.png" alt="image-20200919233729150"></p><h2 id="系统总览"><a href="#系统总览" class="headerlink" title="系统总览"></a>系统总览</h2><p><img src="/../images/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/image-20200919233712253.png" alt="image-20200919233712253"></p><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="两次MD5"><a href="#两次MD5" class="headerlink" title="两次MD5"></a>两次MD5</h2><p>用户端：MD5（明文+固定salt），防止明文密码在网络上传输。</p><p>服务端：MD5（前端+随机salt），防止数据库异常被他人破解密码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高并发秒杀系统实战。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="http://djsFFF.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="JAVA" scheme="http://djsFFF.github.io/tags/JAVA/"/>
    
      <category term="项目" scheme="http://djsFFF.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode经典算法</title>
    <link href="http://djsFFF.github.io/2020/09/13/Leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    <id>http://djsFFF.github.io/2020/09/13/Leetcode经典算法/</id>
    <published>2020-09-13T14:15:27.000Z</published>
    <updated>2023-05-01T01:37:16.613Z</updated>
    
    <content type="html"><![CDATA[<p>记录Leetcode中经典的算法思路。</p><a id="more"></a><h1 id="两数之和1"><a href="#两数之和1" class="headerlink" title="两数之和1"></a>两数之和1</h1><p><img src="/../images/Leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/image-20200913175716328.png" alt="image-20200913175716328"></p><p><strong>思路：</strong></p><ul><li>排序+双指针，时间O(nlogn)，空间O(1)。</li><li>HashMap，一次遍历检查HashMap是否已有target - nums[i]，否则添加当前元素到HashMap中。</li></ul><h1 id="三数之和15"><a href="#三数之和15" class="headerlink" title="三数之和15"></a>三数之和15</h1><p><img src="/../images/Leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/image-20200913180029903.png" alt="image-20200913180029903"></p><p><strong>思路：</strong>排序+三指针，遍历排序后nums数组，对于每一个元素检查是否该元素后面是否存在l，r使得nums[i] + nums[l] + nums[r] &#x3D; 0。</p><h1 id="最长连续序列128"><a href="#最长连续序列128" class="headerlink" title="最长连续序列128"></a>最长连续序列128</h1><p><img src="/../images/Leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/image-20201021221252211.png" alt="image-20201021221252211"></p><p><strong>思路：</strong>将数组元素存入set，然后再次遍历数组，如果set中存在比当前值小的数，则跳过，否则循环检查是否连续值。</p><h1 id="和为k的子数组560（437）"><a href="#和为k的子数组560（437）" class="headerlink" title="和为k的子数组560（437）"></a>和为k的子数组560（437）</h1><p><img src="/../images/Leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/image-20201022155443181.png" alt="image-20201022155443181"></p><p><strong>思路：</strong>前缀和+哈希表。遍历数组，记录当前遍历过的元素的和，将其出现次数存放在HashMap中。对于每个元素检查HashMap中是否存在前缀和为sum-k，若存在则将结果加上该前缀和出现的次数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录Leetcode中经典的算法思路。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://djsFFF.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://djsFFF.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试问题</title>
    <link href="http://djsFFF.github.io/2020/09/13/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>http://djsFFF.github.io/2020/09/13/面试问题/</id>
    <published>2020-09-13T14:00:00.000Z</published>
    <updated>2023-05-01T01:37:16.616Z</updated>
    
    <content type="html"><![CDATA[<p>记录面试问题。</p><a id="more"></a><h1 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h1><p><a href="https://www.jianshu.com/p/9fe2c140fa52" target="_blank" rel="noopener">https://www.jianshu.com/p/9fe2c140fa52</a></p><h2 id="TCP的KeepAlive"><a href="#TCP的KeepAlive" class="headerlink" title="TCP的KeepAlive"></a>TCP的KeepAlive</h2><p>在保持连接时，一方会不定期发送心跳包给另一方，判断连接是否还需要。</p><h2 id="HTTP的Keep-Alive"><a href="#HTTP的Keep-Alive" class="headerlink" title="HTTP的Keep-Alive"></a>HTTP的Keep-Alive</h2><p>该功能HTTP1.0及以前默认关闭，HTTP1.1中默认开启。开启该功能后，在完成一个HTTP请求后，不会立即关闭TCP连接，而是等待一段时间（几十秒）接收浏览器可能发来的其他请求。</p><h1 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h1><ul><li>-Xms：初始堆大小，默认物理内存的1&#x2F;64。</li><li>-Xmx：最大堆大小，默认物理内存的1&#x2F;4。</li><li>-Xmn：年轻代大小</li></ul><h1 id="Socket编程基本流程"><a href="#Socket编程基本流程" class="headerlink" title="Socket编程基本流程"></a>Socket编程基本流程</h1><p><a href="https://www.cnblogs.com/cy568searchx/p/3728586.html" target="_blank" rel="noopener">https://www.cnblogs.com/cy568searchx/p/3728586.html</a></p><p>三次握手：</p><p><img src="/../images/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20200914153512157.png" alt="image-20200914153512157"></p><p>四次挥手：</p><p><img src="/../images/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/image-20200914153544195.png" alt="image-20200914153544195"></p><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><ol><li>socket()创建socket。</li><li>bind()将socket与IP地址和端口绑定。</li><li>listen()将socket设置为监听模式等待连接请求。</li><li>accept()请求到来时，返回一个对应于此次请求的socket。</li><li>recv()&#x2F;send()，在socket上收发数据。</li><li>closesocked()，关闭套接字。</li></ol><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">55533</span>); <span class="comment">// 括号内为端口号</span></span><br><span class="line">Socket socket = server.accept(); <span class="comment">// 等待建立连接</span></span><br><span class="line"><span class="comment">// 数据传输省略</span></span><br><span class="line">socket.close();</span><br><span class="line">server.close();</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="c语言"><a href="#c语言" class="headerlink" title="c语言"></a>c语言</h3><ol><li>socket()创建socket。</li><li>connect()向服务器发起连接请求。</li><li>recv()&#x2F;send()，在套接字上收发数据。</li><li>closesocked()，关闭socket。</li></ol><h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">55533</span>); <span class="comment">// 建立连接</span></span><br><span class="line"><span class="comment">// 数据传输省略</span></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><p><a href="https://www.jianshu.com/p/735a3d4789fc" target="_blank" rel="noopener">https://www.jianshu.com/p/735a3d4789fc</a></p><p>首先对计算存储结点的哈希值，并将存储结点映射到在一个抽象的环（哈希值空间）上；然后对计算数据的哈希值并映射到环上，按顺时针方向将其配置到最近的存储结点上面。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录面试问题。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://djsFFF.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://djsFFF.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令</title>
    <link href="http://djsFFF.github.io/2020/09/13/Linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://djsFFF.github.io/2020/09/13/Linux命令/</id>
    <published>2020-09-13T13:37:04.000Z</published>
    <updated>2023-05-01T01:37:16.613Z</updated>
    
    <content type="html"><![CDATA[<p>Linux常用命令。</p><a id="more"></a><h1 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h1><h2 id="目录相关"><a href="#目录相关" class="headerlink" title="目录相关"></a>目录相关</h2><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><p>绝对路径以<code>/</code>开头，相对路径没有<code>/</code>。</p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p><code>-p</code>会创建级联路径。</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>用于删除文件。<code>-r</code>用于删除目录，<code>-f</code>用于强制删除，<code>-rf</code>用于强制删除目录。</p><ul><li><code>rmdir</code>命令用于删除空目录。</li></ul><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p><code>cp [-r] 源 目标</code>，<code>-r</code>用于复制目录。</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p><code>mv [选项] 源 目标</code>，当目标存在时，若目标是目录，则将源<strong>移动</strong>到该目录下，若目标是文件，则询问是否<strong>覆盖</strong>；当目标不存在时，将源<strong>重命名</strong>为目标。</p><h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><h3 id="cat和tac"><a href="#cat和tac" class="headerlink" title="cat和tac"></a>cat和tac</h3><p>cat从第一行显示文件，<code>-n</code>会显示行号。tac从最后一行显示文件。</p><h3 id="more和less"><a href="#more和less" class="headerlink" title="more和less"></a>more和less</h3><p>文件内容较多时，可以使用more和less翻页或按行查看。</p><h3 id="head和tail"><a href="#head和tail" class="headerlink" title="head和tail"></a>head和tail</h3><p>head显示文件的前10行，tail显示文件的末10行，<code>head -数量 文件名</code>可以指定行数，tail类似。</p><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p><code>ls -l</code>可以查看当前路径下的所有文件的属性。</p><p><img src="/images/Linux%E5%91%BD%E4%BB%A4/image-20201010233616918.png" alt="image-20201010233616918"></p><ul><li>第1列：第1位表示文件类型（**-文件，d目录，l链接文件等**），后面9位每3位一组，分别表示所有者（user）的权限、所属组（group）的权限、其他非本组用户（others）的权限。</li><li>第2列：该文件占用的节点。</li><li>第3，4，5列：所有者，所属组，文件大小。</li><li>第6，7，8列：最后一次修改时间的月、日、年。</li><li>第9列：文件名。</li></ul><h2 id="更改文件权限"><a href="#更改文件权限" class="headerlink" title="更改文件权限"></a>更改文件权限</h2><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p><code>chgrp [-R] 组名 文件名</code>，更改文件的所属组，<code>-R</code>用于级联更改。</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p><code>chown [-R] 用户名 文件名</code>，更改文件的所有者，<code>-R</code>用于级联更改。</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p><code>chmod [-R] xyz 文件名</code>，其中xyz为三个数字分别文件名表示所有者、所属组、其他用户的权限。</p><p><strong>r&#x3D;4，w&#x3D;2，x&#x3D;1，-&#x3D;0。</strong>rw-&#x3D;4+2+0&#x3D;6。</p><p>目录的默认权限是755，文件的默认权限是644。</p><h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>可用于查找PATH环境变量下的路径下的可执行文件。如<code>which vi</code>会输出<code>/usr/bin/vi</code>。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>find 路径 [参数]</code>，查找路径下的文件。</p><ul><li><code>-atime +天数/-天数</code>：查找访问或执行时间大于&#x2F;小于n天的文件。</li><li><code>-mtime +天数/-天数</code>：查找写入时间大于或小于n填的文件。</li><li><code>-name 文件名</code>：查找路径下指定文件名。</li></ul><h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>查看已挂载磁盘的总容量、使用容量、剩余容量等信息，默认KB为单位。<code>-h</code>表示使用合适的单位。</p><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p><code>du [参数] 文件或路径名</code>，查看某个目录或文件的大小。<code>-a</code>表示列出路径下所有目录和文件的大小，默认只显示所有目录。<code>-h</code>表示使用合适的单位。</p><h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h3><p>分区工具，只能划分小于2TB的分区。<code>fdisk -l</code>可以查看所有磁盘设备信息。<code>fdisk 设备名称</code>进入分区操作模式。</p><h3 id="mount和umount"><a href="#mount和umount" class="headerlink" title="mount和umount"></a>mount和umount</h3><p><code>mount 设备名称 路径</code>，将设备挂载到该路径上。</p><p><code>umount 路径</code>，卸载路径上的设备。</p><h3 id="x2F-etc-x2F-fstab配置文件"><a href="#x2F-etc-x2F-fstab配置文件" class="headerlink" title="&#x2F;etc&#x2F;fstab配置文件"></a>&#x2F;etc&#x2F;fstab配置文件</h3><p>该文件中记录了系统启动时需要挂载的分区。</p><h1 id="压缩与打包"><a href="#压缩与打包" class="headerlink" title="压缩与打包"></a>压缩与打包</h1><h3 id="tar打包"><a href="#tar打包" class="headerlink" title="tar打包"></a>tar打包</h3><p>打包<code>tar [zjxcvfpP] 输出文件名 需要打包文件</code>，<code>-z -j -J</code>表示分别同时使用gzip、bzip2、xz压缩。<code>-v</code>表示可视化，<code>-x</code>表示解包或解压缩，<code>-c</code>表示建立一个tar包，<code>-f</code>后接压缩后的文件名或解压文件名。</p><p><code>tar -cvf test.tar test1 test2 test3</code>，将test1 test2 test3打包为test.tar。</p><p><code>tar -xvf test.tar</code>，解压缩文件。</p><h3 id="zip压缩"><a href="#zip压缩" class="headerlink" title="zip压缩"></a>zip压缩</h3><p><code>zip test.zip test/*</code>，将test路径下所有文件压缩为test.zip。</p><p><code>unzip test.zip</code>，解压缩，需要安装unzip工具。</p><h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><ul><li><p>-a：–all，显示所有。</p></li><li><p>-r：–route，显示路由表。</p></li><li><p>-t：–tcp，显示tcp连接。</p></li><li><p>-u：–udp，显示UDP连接。</p></li><li><p>-p：–programs，显示进程名。</p></li><li><p>-n：–numeric，禁用域名解析功能，加快查询速度。</p></li><li><p>-l：–listening，显示正在监听的socket。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux常用命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://djsFFF.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://djsFFF.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer</title>
    <link href="http://djsFFF.github.io/2020/09/11/%E5%89%91%E6%8C%87Offer/"/>
    <id>http://djsFFF.github.io/2020/09/11/剑指Offer/</id>
    <published>2020-09-11T14:15:27.000Z</published>
    <updated>2023-05-01T01:37:16.615Z</updated>
    
    <content type="html"><![CDATA[<p>《剑指Offer》关键算法题思路总结。</p><a id="more"></a><h1 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03 数组中重复的数字"></a>03 数组中重复的数字</h1><p><img src="/../images/%E5%89%91%E6%8C%87Offer/image-20200911201834565.png" alt="image-20200911201834565"></p><p><strong>思路：</strong>将数字归位到对应位置，出现重复数字时返回。</p><h1 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04 二维数组中的查找"></a>04 二维数组中的查找</h1><p><img src="/../images/%E5%89%91%E6%8C%87Offer/image-20200911202033610.png" alt="image-20200911202033610"></p><p><strong>思路：</strong>从右上角开始查找，大于目标值则左移，小于目标值则下移。</p><h1 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06 从尾到头打印链表"></a>06 从尾到头打印链表</h1><p><img src="/../images/%E5%89%91%E6%8C%87Offer/image-20200911202545515.png" alt="image-20200911202545515"></p><p><strong>思路：</strong></p><ul><li>使用栈保存元素。</li><li>递归打印。</li></ul><h1 id="09-两个栈实现队列"><a href="#09-两个栈实现队列" class="headerlink" title="09 两个栈实现队列"></a>09 两个栈实现队列</h1><p><img src="/../images/%E5%89%91%E6%8C%87Offer/image-20200911202826857.png" alt="image-20200911202826857"></p><p><strong>思路：</strong>添加元素时直接添加到第一个栈；弹出元素时，若第二个栈为空，则将第一个栈中的元素全部加入到第二个元素，然后弹出第二个栈的元素。</p><h1 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11 旋转数组的最小数字"></a>11 旋转数组的最小数字</h1><p><img src="/../images/%E5%89%91%E6%8C%87Offer/image-20200911213115815.png" alt="image-20200911213115815"></p><p><strong>思路：</strong>二分查找。nums[mid] &gt; nums[r]时，l &#x3D; mid + 1；nums[mid] &lt;&#x3D; nums[r]时，r–。</p><h1 id="14-剪绳子Ⅰ"><a href="#14-剪绳子Ⅰ" class="headerlink" title="14 剪绳子Ⅰ"></a>14 剪绳子Ⅰ</h1><p><img src="/../images/%E5%89%91%E6%8C%87Offer/image-20200911223248798.png" alt="image-20200911223248798"></p><p><strong>思路：</strong>找规律。当n &lt;&#x3D; 6时，结果分别为0,0,1,2,4,6,9；当n &gt; 6时，结果为dp[n - 3] * 3。 </p><h1 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15 二进制中1的个数"></a>15 二进制中1的个数</h1><p><img src="/../images/%E5%89%91%E6%8C%87Offer/image-20200912001326318.png" alt="image-20200912001326318"></p><p><strong>思路：</strong></p><ul><li><p>使用n &amp; 1 &#x3D;&#x3D; 1判断末尾是否为1，然后无符号右移n &gt;&gt;&#x3D; 1。</p></li><li><pre><code class="java">while(n != 0) {    res++;    n = n &amp; (n - 1);}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 16 数值的整数次方</span><br><span class="line"></span><br><span class="line">![image-20200912001638939](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912001638939.png)</span><br><span class="line"></span><br><span class="line">**思路：**首先处理exponent为负数时，然后递归计算，注意exponent为奇数时，需要多乘一个base。</span><br><span class="line"></span><br><span class="line"># 21 调整数组顺序使奇数位于偶数前面</span><br><span class="line"></span><br><span class="line">![image-20200912002749192](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912002749192.png)</span><br><span class="line"></span><br><span class="line">**思路：**双指针。左指针遍历到第一个偶数，右指针遍历到第一个奇数，然后交换两个元素。</span><br><span class="line"></span><br><span class="line"># 22 链表中倒数第k个节点</span><br><span class="line"></span><br><span class="line">![image-20200912003248992](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912003248992.png)</span><br><span class="line"></span><br><span class="line">**思路：**双指针。第一个指针先走k步，然后两个指针一起走，直到第一个指针到达尾部。</span><br><span class="line"></span><br><span class="line"># 23 反转链表</span><br><span class="line"></span><br><span class="line">![image-20200912003545917](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912003545917.png)</span><br><span class="line"></span><br><span class="line">**思路：**</span><br><span class="line"></span><br><span class="line">![image-20200912003529299](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912003529299.png)</span><br><span class="line"></span><br><span class="line"># 30 包含min函数的栈</span><br><span class="line"></span><br><span class="line">![image-20200912004226484](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912004226484.png)</span><br><span class="line"></span><br><span class="line">**思路：**辅助单调栈。使用一个辅助单调栈维护最小值。</span><br><span class="line"></span><br><span class="line"># 33 二叉搜索树的后序遍历序列</span><br><span class="line"></span><br><span class="line">![image-20200912005040034](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912005040034.png)</span><br><span class="line"></span><br><span class="line">**思路：**单调栈。倒序遍历数组（左右根 -&gt; 根右左）。</span><br><span class="line"></span><br><span class="line"># 38 字符串的排列</span><br><span class="line"></span><br><span class="line">![image-20200912010408938](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912010408938.png)</span><br><span class="line"></span><br><span class="line">**思路：**回溯+剪枝。每轮递归中固定没有遍历过的元素中的一位。</span><br><span class="line"></span><br><span class="line"># 39 数组中出现次数超过一半的数字</span><br><span class="line"></span><br><span class="line">![image-20200912010739651](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912010739651.png)</span><br><span class="line"></span><br><span class="line">**思路：**摩尔投票法。遍历数组，当保存的数与当前遍历到的数相同时，计数器+1，否则计数器-1，并修改保存的数为当前数。</span><br><span class="line"></span><br><span class="line"># 42 连续子数组的最大和</span><br><span class="line"></span><br><span class="line">![image-20200912011131473](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912011131473.png)</span><br><span class="line"></span><br><span class="line">**思路：**维护一个sum变量，遍历数组，保存最大的sum为结果，当sum小于0时，将sum置0。</span><br><span class="line"></span><br><span class="line"># 45 把数组排成最小的数</span><br><span class="line"></span><br><span class="line">![image-20200912011422867](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912011422867.png)</span><br><span class="line"></span><br><span class="line">**思路：**将数字看做字符串，按照字符串大小进行排序。</span><br><span class="line"></span><br><span class="line"># 48 最长不含重复字符的子字符串</span><br><span class="line"></span><br><span class="line">![image-20200912011759855](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912011759855.png)</span><br><span class="line"></span><br><span class="line">**思路：**双指针+Hash表。Hash表存储每个字符最后一次出现的位置，当右指针遇到已出现过的字符时，更新左指针到该字符上一次出现的位置，保证左右指针之间没有重复字符。</span><br><span class="line"></span><br><span class="line"># 50 第一个只出现一次的字符</span><br><span class="line"></span><br><span class="line">![image-20200912012642907](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912012642907.png)</span><br><span class="line"></span><br><span class="line">**思路：**</span><br><span class="line"></span><br><span class="line">- Hash。两次遍历字符串，第一次遍历保存重复状态，第二次遍历获得第一个不重复字符。</span><br><span class="line"></span><br><span class="line"># 51 数组中的逆序对</span><br><span class="line"></span><br><span class="line">![image-20200912012904699](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912012904699.png)</span><br><span class="line"></span><br><span class="line">**思路：**在归并排序的合并过程中，每当遇到右边数组当前元素大于坐标数组当前元素时，右边数组当前元素之前的值都比左边数组当前元素小。</span><br><span class="line"></span><br><span class="line"># 52 两个链表的第一个公共结点</span><br><span class="line"></span><br><span class="line">![image-20200912082933950](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912082933950.png)</span><br><span class="line"></span><br><span class="line">**思路：**双指针。ptr1和ptr2分别遍历A、B链表，当ptr1遍历到A链表结尾时，重新指向B的开头，当ptr2遍历到B链表结尾时，重新指向A的开头，直到ptr1 &#x3D;&#x3D; ptr2。</span><br><span class="line"></span><br><span class="line"># 53-Ⅰ  在排序数组中查找数字出现的次数</span><br><span class="line"></span><br><span class="line">![image-20200912083335403](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912083335403.png)</span><br><span class="line"></span><br><span class="line">**思路：**二分查找。分别查找target和target - 1的右边界，将两结果相减即可。</span><br><span class="line"></span><br><span class="line"># 53-Ⅱ 0~n-1中缺失的数字</span><br><span class="line"></span><br><span class="line">![image-20200912083614626](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912083614626.png)</span><br><span class="line"></span><br><span class="line">**思路：**二分查找。判断数组下标与值是否相等。</span><br><span class="line"></span><br><span class="line"># 54 二叉搜索树的第k大结点</span><br><span class="line"></span><br><span class="line">![image-20200912084211003](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912084211003.png)</span><br><span class="line"></span><br><span class="line">**思路：**递归中序遍历。</span><br><span class="line"></span><br><span class="line"># 57-Ⅱ 和为s的连续正数序列</span><br><span class="line"></span><br><span class="line">![image-20200912085639305](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912085639305.png)</span><br><span class="line"></span><br><span class="line">**思路：**双指针滑动窗口。窗口和小于target时，右指针移动，窗口和大于target时，左指针移动。</span><br><span class="line"></span><br><span class="line"># 59-Ⅰ 滑动窗口的最大值</span><br><span class="line"></span><br><span class="line">![image-20200912090249801](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912090249801.png)</span><br><span class="line"></span><br><span class="line">**思路：**双向**单调队列**。队列头为最大值，每次滑动时，将若滑动窗口的最左值等于队列头，说明该队列头需要被移除了，然后将滑动窗口新加入的最右值加入到队尾并保证单调。</span><br><span class="line"></span><br><span class="line"># 59-Ⅱ 队列的最大值</span><br><span class="line"></span><br><span class="line">![image-20200912092941507](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912092941507.png)</span><br><span class="line"></span><br><span class="line">**思路：**辅助**单调**双向队列。添加元素时，分别向队列和单调队列中添加元素。弹出元素时，若弹出的元素恰好与单调队列头元素相等，则单调队列也弹出头元素。</span><br><span class="line"></span><br><span class="line"># 61 扑克牌中的顺子</span><br><span class="line"></span><br><span class="line">![image-20200912093753366](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912093753366.png)</span><br><span class="line"></span><br><span class="line">**思路：**遍历数组set记录数组中元素是否重复，同时记录数组中的最大值和最小值，若遍历过程中没有出现重复，则判断最大值与最小值的差值。</span><br><span class="line"></span><br><span class="line"># 62 圆圈中最后剩下的数字</span><br><span class="line"></span><br><span class="line">![image-20200912102707865](..&#x2F;images&#x2F;%E5%89%91%E6%8C%87Offer&#x2F;image-20200912102707865.png)</span><br><span class="line"></span><br><span class="line">**思路：**</span><br><span class="line"></span><br><span class="line">- 通过list保存序列，依次求出需要删除的下标进行删除。</span><br><span class="line"></span><br><span class="line">- 数学推导</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public int lastRemaining(int n, int m) &#123;</span><br><span class="line">          int ans &#x3D; 0;</span><br><span class="line">          &#x2F;&#x2F; 最后一轮剩下2个人，所以从2开始反推</span><br><span class="line">          for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">              ans &#x3D; (ans + m) % i;</span><br><span class="line">          &#125;</span><br><span class="line">          return ans;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h1 id="68-Ⅰ-二叉搜索树的最近公共祖先"><a href="#68-Ⅰ-二叉搜索树的最近公共祖先" class="headerlink" title="68-Ⅰ 二叉搜索树的最近公共祖先"></a>68-Ⅰ 二叉搜索树的最近公共祖先</h1><p><img src="/../images/%E5%89%91%E6%8C%87Offer/image-20200912112355980.png" alt="image-20200912112355980"></p><p><strong>思路：</strong>若pq的值都小于当前结点，则遍历至左结点，若pq的值都大于当前结点，则遍历至右结点，否则返回当前结点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《剑指Offer》关键算法题思路总结。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://djsFFF.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://djsFFF.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://djsFFF.github.io/2020/09/11/%E7%AE%97%E6%B3%95/"/>
    <id>http://djsFFF.github.io/2020/09/11/算法/</id>
    <published>2020-09-10T16:00:00.000Z</published>
    <updated>2023-05-01T01:37:16.615Z</updated>
    
    <content type="html"><![CDATA[<p>典型算法总结。</p><a id="more"></a><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="1-输入频率表：A-60、B-45、C-13、D-69、E-14、F-5、G-3"><a href="#1-输入频率表：A-60、B-45、C-13、D-69、E-14、F-5、G-3" class="headerlink" title="1. 输入频率表：A-60、B-45、C-13、D-69、E-14、F-5、G-3"></a>1. 输入频率表：A-60、B-45、C-13、D-69、E-14、F-5、G-3</h2><h2 id="2-依次找出两个最小的，小的在左边，大的在右边。"><a href="#2-依次找出两个最小的，小的在左边，大的在右边。" class="headerlink" title="2. 依次找出两个最小的，小的在左边，大的在右边。"></a>2. 依次找出两个最小的，小的在左边，大的在右边。</h2><h3 id="A-60、B-45、C-13、D-69、E-14、F-5、G-3"><a href="#A-60、B-45、C-13、D-69、E-14、F-5、G-3" class="headerlink" title="A-60、B-45、C-13、D-69、E-14、F-5、G-3"></a>A-60、B-45、C-13、D-69、E-14、F-5、G-3</h3><p><img src="/../images/%E7%AE%97%E6%B3%95/image-20200911160739925.png" alt="image-20200911160739925"></p><h3 id="A-60、B-45、C-13、D-69、E-14、FG-8"><a href="#A-60、B-45、C-13、D-69、E-14、FG-8" class="headerlink" title="A-60、B-45、C-13、D-69、E-14、FG-8"></a>A-60、B-45、C-13、D-69、E-14、FG-8</h3><p><img src="/../images/%E7%AE%97%E6%B3%95/image-20200911160856599.png" alt="image-20200911160856599"></p><h3 id="……省略"><a href="#……省略" class="headerlink" title="……省略"></a>……省略</h3><h3 id="AD：129、FGCEB：80"><a href="#AD：129、FGCEB：80" class="headerlink" title="AD：129、FGCEB：80"></a>AD：129、FGCEB：80</h3><p><img src="/../images/%E7%AE%97%E6%B3%95/image-20200911161304549.png" alt="image-20200911161304549"></p><h3 id="左路径为0，右路径为1"><a href="#左路径为0，右路径为1" class="headerlink" title="左路径为0，右路径为1"></a>左路径为0，右路径为1</h3><p><img src="/../images/%E7%AE%97%E6%B3%95/image-20200911161551630.png" alt="image-20200911161551630"></p><h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>496</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;典型算法总结。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://djsFFF.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://djsFFF.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://djsFFF.github.io/2020/08/30/Redis/"/>
    <id>http://djsFFF.github.io/2020/08/30/Redis/</id>
    <published>2020-08-30T12:15:00.000Z</published>
    <updated>2023-05-01T01:37:16.614Z</updated>
    
    <content type="html"><![CDATA[<p>Redis相关知识点。</p><p>Redis是一个开源的高性能键值对的内存数据库，可以用作数据库、缓存、消息中间件等，是一种NoSQL数据库（Not-only SQL，非关系型数据库）。</p><a id="more"></a><h1 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h1><ol><li>基于内存操作。</li><li>单线程模型，避免了上下文切换。</li><li>多路复用IO模型，非阻塞IO。</li></ol><h1 id="Redis优点"><a href="#Redis优点" class="headerlink" title="Redis优点"></a>Redis优点</h1><ol><li>基于内存操作，读写速度快。</li><li>数据类型丰富，string，hash，list，set，sorted set等。</li><li>支持事务，操作都是原子性的。</li><li>支持发布订阅，设置过期时间等。</li></ol><h1 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h1><h2 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h2><p>用途：键，string类型，缓冲区（AOF缓冲区，客户端状态的输入缓冲区等）。</p><p>SDS结构如图所示</p><p><img src="/images/Redis/image-20200921213725636.png" alt="image-20200921213725636"></p><ul><li>free：记录该SDS的空闲空间。</li><li>len：记录该SDS的已用空间。</li><li>buf：char数组，用于保存字符串。</li></ul><h2 id="双端链表linkedlist"><a href="#双端链表linkedlist" class="headerlink" title="双端链表linkedlist"></a>双端链表linkedlist</h2><p>用途：list类型等。</p><h2 id="字典hashtable"><a href="#字典hashtable" class="headerlink" title="字典hashtable"></a>字典hashtable</h2><p>用途：hash类型等。</p><h2 id="跳跃表skiplist"><a href="#跳跃表skiplist" class="headerlink" title="跳跃表skiplist"></a>跳跃表skiplist</h2><p>用途：zset类型，集群节点等。</p><p>每个节点会根据幂次定律（越大的数出现的概率越小）随机生成多个层，每个层中保存了下一个<strong>同级层</strong>的指针及其跨度。</p><h2 id="整数集合intset"><a href="#整数集合intset" class="headerlink" title="整数集合intset"></a>整数集合intset</h2><p>用途：set类型等。</p><p>可以保存的类型为int16_t、int32_t、int64_t的整数值，通过自动升级策略节约内存，提高灵活性。</p><p>当一个set只包含整数值元素，且元素数量不多时（512），<strong>Redis采用intset作为set的底层实现</strong>。</p><h2 id="压缩列表ziplist"><a href="#压缩列表ziplist" class="headerlink" title="压缩列表ziplist"></a>压缩列表ziplist</h2><p>用途：list类型，hash类型等。</p><p>当一个<strong>list键</strong>只包含少量元素（512），且元素长度都小于64字节时，Redis采用ziplist作为底层实现。</p><p>当一个<strong>hash键</strong>只包含少量键值对（512），且键值都小于64字节时，Redis采用ziplist作为底层实现。</p><p>当一个<strong>zset键</strong>只包含少量元素（512），且元素长度都小于64字节时，Redis采用ziplist作为底层实现。</p><p>压缩列表的节点包括三个属性：</p><ul><li>previous_entry_length：以字节为单位，记录了前一个节点的长度。</li><li>encoding：记录了content保存的数据的类型和长度。</li><li>content：保存节点的值，是一个char数组或整数。</li></ul><p>节约内存，从尾向头遍历。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>值可以是string，也可以是数字、二进制数据等。底层数据结构可以是<strong>int，raw(SDS)或embstr</strong>。</p><p><img src="/images/Redis/image-20220112153608910.png" alt="image-20220112153608910"></p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>使用ziplist时，先将key推入表尾，再将value推入表尾。</p><p>编码转换</p><p><img src="/images/Redis/image-20220112164857610.png" alt="image-20220112164857610"></p><p><img src="/images/Redis/image-20220112155327565.png" alt="image-20220112155327565"></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>编码转换</p><p><img src="/images/Redis/image-20220112164809306.png" alt="image-20220112164809306"></p><p><img src="/images/Redis/image-20220112155241467.png" alt="image-20220112155241467"></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>编码转换</p><p><img src="/images/Redis/image-20220112164950571.png" alt="image-20220112164950571"></p><p><img src="/images/Redis/image-20220112155402241.png" alt="image-20220112155402241"></p><h2 id="Zset（Sorted-Set）"><a href="#Zset（Sorted-Set）" class="headerlink" title="Zset（Sorted Set）"></a>Zset（Sorted Set）</h2><p>使用ziplist时，元素和分数存放在相邻节点。</p><p>编码转换</p><p><img src="/images/Redis/image-20220112165205470.png" alt="image-20220112165205470"></p><p>当底层结构为skiplist时，zset中有一个字典用于保存key到score的映射，且key和score是共享跳跃表中的数据，因此不需要额外的内存空间。</p><p><img src="/images/Redis/image-20220112172951475.png" alt="image-20220112172951475"></p><h1 id="内存回收与对象共享"><a href="#内存回收与对象共享" class="headerlink" title="内存回收与对象共享"></a>内存回收与对象共享</h1><p>基于引用计数实现内存回收。</p><p>Redis在初始化服务器时，会创建0-9999的字符串共享对象。</p><h1 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE &lt;key&gt; &lt;ttl&gt; 设置key的生存时间为ttl秒</span><br><span class="line">PEXPIRE &lt;key&gt; &lt;ttl&gt; 设置key的生存时间为ttl毫秒</span><br><span class="line">EXPIREAT &lt;key&gt; &lt;timestamp&gt; 设置key的过期时间为秒时间戳timestamp</span><br><span class="line">PEXPIREAT &lt;key&gt; &lt;timestamp&gt; 设置key的过期时间为毫秒时间戳timestamp</span><br></pre></td></tr></table></figure><p>过期时间保存在redisDb结构的expires字典中，key指向键对象的内存地址，value为long long过期时间</p><h1 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h1><p>定期删除+惰性删除。</p><ul><li><p>定时删除：设置过期时间的同时创建一个定时器，在键到达过期时间时立即删除。</p></li><li><p>定期删除：定时随机抽取一些（或全部）设置了过期时间的key，检查其是否过期，如果过期就删除。</p></li><li><p>惰性删除：尝试访问一个已过期但还没被删除的key时，redis会把该数据删除掉。</p></li></ul><h3 id="主从复制下的过期键"><a href="#主从复制下的过期键" class="headerlink" title="主从复制下的过期键"></a>主从复制下的过期键</h3><ul><li>主服务器在删除一个过期键之后，会向所有从服务器发送一个DEL命令。</li><li>从服务器<strong>只有在接到主服务器发来的DEL命令时才会删除过期键</strong>。在执行客户端发送的请求时，不会考虑键是否已经过期。保证主从数据一致性。</li></ul><h3 id="持久化时过期键处理"><a href="#持久化时过期键处理" class="headerlink" title="持久化时过期键处理"></a>持久化时过期键处理</h3><ul><li>生成RDB文件时不会保存已过期的键。</li><li>只有在过期键被惰性或者定期删除时，程序会向AOF文件append一条DEL命令。</li><li>AOF重写时，过期键不会保存到重写后的AOF文件中。</li></ul><h1 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h1><ul><li>volatile-lru：从已设置过期时间的数据中挑选<strong>最近最少使用</strong>的数据淘汰。</li><li>volatile-lfu：从已设置过期时间的数据中挑选<strong>使用频率最低</strong>的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据中挑选<strong>将要过期</strong>的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据中<strong>随机选择</strong>数据淘汰。</li><li>allkeys-lru：从所有数据中选择<strong>最近最少使用</strong>的数据淘汰。</li><li>allkeys-lfu：当所有数据中选择<strong>使用频率最低</strong>的数据淘汰。</li><li>allkeys-random：从所有数据中<strong>随机选择</strong>数据淘汰。</li><li>no-eviction：<strong>不淘汰数据</strong>，内存不足以容纳新写入数据时报错。</li></ul><h1 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h1><p>若服务器在启动时优先检测是否开启AOF持久化（AOF更新频率更高），若没有则检测RDB文件并自动载入RDB文件。</p><h2 id="快照持久化RDB"><a href="#快照持久化RDB" class="headerlink" title="快照持久化RDB"></a>快照持久化RDB</h2><p>适合于定时文件备份和灾难恢复，恢复大数据集时比AOF快。但由于是全量备份，因此备份需要花费较多的时间，且不会记录备份期间的数据变化。</p><h3 id="SAVE和BGSAVE"><a href="#SAVE和BGSAVE" class="headerlink" title="SAVE和BGSAVE"></a>SAVE和BGSAVE</h3><ul><li><p>SAVE：save会阻塞Redis服务器进程，直到RDB文件创建完毕，期间无法执行其他命令。</p></li><li><p>BGSAVE：bgsave会派生出一个子进程（fork()方法），然后由子进程负责创建RDB文件。在bgsave执行期间，会拒绝其他的save和bgsave命令。</p><p>Redis服务器启动时，可以通过指定配置文件或者传入启动参数的方式设置save选项。默认save选项如下：</p><ul><li>save 900 1：在900秒内，至少1个key发生变化，执行BGSAVE。</li><li>save 300 10：在300秒内，至少10个key发生变化，执行BGSAVE。</li><li>save 60 10000：在1分钟内，至少10000个key发生变化，执行BGSAVE。</li></ul><p>每100ms检查是否满足保存条件，满足时其中一个条件时执行<strong>BGSAVE</strong>命令。</p></li></ul><h3 id="RDB过期键处理"><a href="#RDB过期键处理" class="headerlink" title="RDB过期键处理"></a>RDB过期键处理</h3><ul><li>生成RDB文件时，只保存未过期键。</li><li>主服务器载入RDB文件时，只读取未过期键；从服务器则会读取所有键。</li></ul><h2 id="只追加文件AOF"><a href="#只追加文件AOF" class="headerlink" title="只追加文件AOF"></a>只追加文件AOF</h2><p>恢复速度比RDB慢，通常比快照文件大。但是备份的实时性较好。</p><h3 id="备份步骤"><a href="#备份步骤" class="headerlink" title="备份步骤"></a>备份步骤</h3><ol><li><p><strong>命令追加：</strong>服务器执行一个写命令，并将该命令追加到服务器状态的<strong>aof_buf</strong>缓冲区。</p></li><li><p><strong>文件写入和同步：</strong>在事件循环结束之前会根据以下配置决定AOF文件同步方式。</p></li></ol><ul><li><p>appendfsync always：将缓冲区所有内容写入并<strong>立即同步</strong>AOF文件。效率最慢，但是最安全。</p></li><li><p>appendfsync everysec：将缓冲区所有内容写入AOF文件，<strong>每秒钟同步</strong>一次。默认选项。</p></li><li><p>appendfsync no：将缓冲区所有内容写入AOF文件，让<strong>操作系统决定何时进行同步</strong>。效率最快，但是出现故障停机时，操作系统没有来得及写入到文件的缓冲区部分会丢失。</p></li></ul><p>说明：在操作系统中，当用户调用write()函数时，操作系统通常会将写入数据暂时<strong>保存在一个内存缓冲区aof_buf</strong>中，可以通过fsync和fdatasync两个<strong>同步函数</strong>强制让操作系统立即将缓冲区中的数据写入到硬盘，保证安全性。</p><h3 id="AOF载入"><a href="#AOF载入" class="headerlink" title="AOF载入"></a>AOF载入</h3><p>由于Redis命令只能在客户端上下文中执行，因此在载入AOF文件时，会创建一个不带网络连接的<strong>伪客户端</strong>来执行逐行读取AOF文件中的命令并执行。</p><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>AOF文件会随着时间越来越大，因此需要对AOF文件进行重写来减少一些冗余的命令。首先从数据库中读取键现在的值（不需要对AOF文件进行任何读取、分析或者写入操作），然后<strong>用一条命令去记录键值对</strong>，代替之前记录这个键值对的多条命令。实际在处理list、hash、set、zset类型时，若带有较多元素（默认64）时，会使用多条命令来记录。</p><p>AOF重写是在<strong>带有主进程数据副本的子进程</strong>中执行的（防止锁冲突），Redis服务器会将AOF重写期间执行的命令同时发送到<strong>AOF缓冲区和AOF重写缓冲</strong>区。当子进程完成重写任务后，父进程会将AOF重写缓冲区里的所有内容写入新AOF文件中，然后原子地覆盖原本的AOF文件，在此期间父进程会被阻塞。</p><h3 id="AOF过期键处理"><a href="#AOF过期键处理" class="headerlink" title="AOF过期键处理"></a>AOF过期键处理</h3><p>当过期键被惰性删除或者定期删除时，Redis会向AOF文件中追加一条DEL命令来显式地记录该键已被删除。</p><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>​服务器使用redisClient结构保存客户端属性。</p><h2 id="客户端通用属性"><a href="#客户端通用属性" class="headerlink" title="客户端通用属性"></a>客户端通用属性</h2><ul><li>套接字描述符fd：当前客户端正在使用的套接字描述符，伪客户端为-1（AOF文件或者Lua脚本）。</li><li>名字name：客户端名字，默认为空，可以设置。</li><li>标志flag：可以是多个标志组成的二进制或，包括客户端角色和状态。</li><li>输入缓冲区querybuf：保存客户端发送的命令请求。超过1GB时服务器会关闭该客户端。</li><li>命令及参数argv：是一个数组，argv[0]是要执行的命令，其它项是命令参数（key，value等）。</li><li>argc：记录argv的长度。</li><li>命令的实现函数cmd：</li><li>输出缓冲区：默认是一个固定16KB的字节数组，bufpos属性记录buf已使用的字节数。当buf数组的空间用完时，改为使用reply链表保存一个或多个返回的字符串对象。</li><li>身份验证authenticated：当该属性为0时，出了AUTH命令验证身份外，其他命令都会被拒绝执行。</li><li>时间相关属性：<ul><li>ctime：创建客户端的时间。</li><li>lastinteraction：客户端与服务端上一次互动的时间（客户端发送或者服务端回复）。</li><li>obuf_soft_limit_reached_time：输出缓冲区第一次到达soft limit的时间。</li></ul></li></ul><h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h2><h3 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h3><p>普通客户端通过网络连接到服务器时，服务器会创建相应的redisClient结构并添加到clients链表末尾。</p><h3 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h3><p>关闭的原因：</p><ul><li>客户端进程或被杀死时，网络连接关闭造成客户端关闭。</li><li>客户端发送了带有不符合协议格式的命令请求。</li><li>客户端成为了CLIENT KILL命令的目标。</li><li>若用户为服务器设置了timeout配置，客户端空转时间超时会被关闭。但如果客户端是主服务器、从服务器、正在被BLPOP等命令阻塞或者正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令时，客户端不受timeout时间限制。</li><li>客户端发送的请求超过了输入缓冲区大小（默认1GB）。</li><li>服务端发送的回复超过了输出缓冲区大小时：<ul><li>硬性限制（hard limit）：输出缓冲区超过了hard limit设置的大小时，立即关闭客户端。</li><li>软性限制（soft limit）：输出缓冲区超过了soft limit设置的大小，但没超过hard limit时，记录超出时间，持续时间超过设定阈值时，关闭客户端。</li></ul></li></ul><h3 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h3><p>服务器初始化时，会创建执行Lua脚本的伪客户端，并创建redisClient结构添加到lua_client链表末尾。</p><h3 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h3><p>服务器载入AOF文件时，会创建执行AOF文件的伪客户端，并在载入完成后关闭。</p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>Redis的主从复制分为同步和命令传播两个操作：</p><ul><li><strong>同步：</strong>更新从服务器的数据库状态与主服务器一致</li><li><strong>命令传播：</strong>主服务器的数据库状态变化时，需要将这些命令同步给从服务器。</li></ul><p>当从服务器初次对主服务器进行复制时，主服务器会将自己的<strong>运行ID</strong>传送给从服务器保存，以便从服务器断线重连后进行主服务器确认。</p><h2 id="完整重同步"><a href="#完整重同步" class="headerlink" title="完整重同步"></a>完整重同步</h2><p><img src="/images/Redis/image-20200924000325035.png" alt="image-20200924000325035"></p><p>当客户端向从服务器发送SLAVEOF命令时，从服务器需要执行同步操作。</p><ol><li>从服务器向主服务器发送<code>PSYNC ? -1</code>（2.8之前为SYNC）命令。</li><li>主服务器收到PSYNC后执行BGSAVE生成一个RDB文件，并将期间执行的所有写命令记录在一个缓冲区中。</li><li>主服务器将生成好的RDB文件发送给从服务器，从服务器接收并载入RDB文件。</li><li>主服务器将缓冲区中的写命令发送给从服务器，从服务器执行这些写命令。</li></ol><h2 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h2><p><img src="/images/Redis/image-20200924001048756.png" alt="image-20200924001048756"></p><p>部分重同步用于处理从服务器断线后重复制的情况。</p><ul><li><strong>复制偏移量</strong>：主服务器向从服务器发送N个字节的数据时，将自己的复制偏移量加N。从服务器收到主服务器发送的N个字节的数据时，将自己的复制偏移量加N。</li><li><strong>复制积压缓冲区</strong>：是主服务器维护的一个固定长度先进先出队列，默认为1MB。主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会写入到复制积压缓冲区中。</li></ul><p>当从服务器断线重连时，会向服务器发送<code>PSYNC 主服务器ID 从服务器复制偏移量</code>，若从服务器与主服务器的复制偏移量之差小于复制积压缓冲区的大小，则主服务器执行部分重同步，只发送断线期间缺失的数据。否则主服务器执行完整重同步。</p><h2 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h2><p>完成同步后，主从服务器就会进入命令传播阶段，当客户端向主服务器发送新的写命令时，主服务器会将这些写命令发送给从服务器执行。</p><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>在命令传播阶段，从服务器默认以每秒一次的频率向主服务器发送命令<code>REPLCONF ACK 复制偏移量</code>。其作用为：</p><ul><li>检测主从服务器的网络连接状态。</li><li>辅助实现min-salves选项，如可以设置在检测到从服务器数量少于3个，或者3个从服务器的延迟都大于等于10s时，可能处于不安全状态，主服务器拒绝执行写命令。</li><li>检测命令丢失。</li></ul><h1 id="哨兵-Sentinel-模式"><a href="#哨兵-Sentinel-模式" class="headerlink" title="哨兵(Sentinel)模式"></a>哨兵(Sentinel)模式</h1><p>哨兵模式是Redis集群的<strong>高可用性</strong>的解决方案：由一个或多个哨兵实例组成的哨兵系统可以监视主服务器及其所有从服务器，并在监视到主服务器进入下线状态时，自动地将某个从服务器升级为新的主服务器。</p><h2 id="启动并初始化Sentinel"><a href="#启动并初始化Sentinel" class="headerlink" title="启动并初始化Sentinel"></a>启动并初始化Sentinel</h2><p>Sentinel本质上是一个运行在特殊模式下的Redis服务器。</p><ol><li>初始化服务器。</li><li>将普通Redis服务器代码替换为Sentinel专用代码。</li><li>初始化Sentinel状态：根据配置文件初始化监听的主服务器列表。</li><li>创建与主服务器的网络连接：成为主服务器的客户端，包括<strong>一个命令连接和一个订阅连接</strong>：<ul><li>命令连接：用于向主服务器发送命令并接收回复。</li><li>订阅连接：用于订阅服务器的__sentinel__:hello频道，用于避免丢失命令，也用于多个订阅了同一服务器的sentinel信息同步。</li></ul></li></ol><h2 id="获取服务器信息"><a href="#获取服务器信息" class="headerlink" title="获取服务器信息"></a>获取服务器信息</h2><p>Sentinel默认每10秒向被监听服务器发送<strong>INFO命令</strong>来获取服务器状态，通过分析INFO命令回复，Sentinel可以获取到被监听服务器信息（服务器ID，角色，IP地址，复制偏移量等），然后Sentinel根据信息更新服务器的实例结构。</p><p>如果主服务器返回的信息中存在<strong>新的从服务器</strong>，则会创建与新从服务器的<strong>命令连接和订阅连接</strong>。</p><h2 id="向服务器发送频道信息"><a href="#向服务器发送频道信息" class="headerlink" title="向服务器发送频道信息"></a>向服务器发送频道信息</h2><p>Sentinel默认每2秒向被监听服务器发送命令<code>PUBLISH __sentinel__: hello sentinel信息 主服务器或从服务器正在复制的主服务器的信息</code>。</p><h2 id="接收来自服务器频道信息"><a href="#接收来自服务器频道信息" class="headerlink" title="接收来自服务器频道信息"></a>接收来自服务器频道信息</h2><p>当Sentinel与一个服务器建立订阅连接后，会向服务器发送命令<code>SUBSCRIBE __sentinel__:hello</code>，对于监视同一个服务器的多个Sentinel，<strong>1</strong>，并被用于更新对应主服务器的实例结构。</p><p>当一个Sentinel接收到其他Sentinel的消息时，会从中提取出源Sentinel和主服务器的相关参数并进行更新。</p><p>若源Sentinel是一个<strong>新的Sentinel</strong>，则会创建与新Sentinel的<strong>命令连接</strong>，而新Sentinel也会创建一个连向当前Sentinel的<strong>命令连接</strong>。</p><h2 id="检查主观下线状态"><a href="#检查主观下线状态" class="headerlink" title="检查主观下线状态"></a>检查主观下线状态</h2><p>Sentinel默认会每秒向其他创建了命令连接的服务器，Sentinel发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。</p><p>若实例在<strong>down-after-milliseconds</strong>（Sentinel的配置文件中）毫秒内连续返回无效回复，当前Sentinel则判定此实例已主观下线。</p><ul><li>有效回复：+PONG、-LOADING、-MASTERDOWN。</li><li>无效回复：除有效回复之外的回复或在指定时间内没有回复。</li></ul><h2 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h2><p>当Sentinel发送命令<code>SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</code>从其他Sentinel询问到足够数量（quorum）的主观下线判定后，会将该服务器判定为客观下线。</p><h2 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h2><p>当一个主服务器被判定为客观下线时，监视该主服务器的所有Sentinel会协商选举一个领头Sentinel，然后由领头Sentinel对下线主服务器进行故障转移操作。</p><p>每个发现主服务器进入客观下线的Sentinel都会向其他Sentinel发送命令要求对方将自己设置为局部领头Sentinel，在一个配置纪元中，每个Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，而每个Sentinel会设置命令最早到达的Sentinel为局部领头Sentinel。</p><p>若某个Sentinel被半数以上的Sentinel设置为局部领头Sentinel，那么这个Sentinel成为领头Sentinel。若在给定时限内没有产生Sentinel，那么会在一段时间后再次进行选举，直到选出领头Sentinel为止。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>领头Sentinel对已下线的主服务器执行故障转移操作包括三个步骤：</p><ol><li><p>在已下线主服务器的从服务器中挑选一个<strong>状态良好、数据完整</strong>的从服务器作为新的主服务器。</p><ol><li><p>排除处于下线或断线的从服务器。</p></li><li><p>排除最近5秒没有回复过领头Sentinel的INFO命令的从服务器。</p></li><li><p>排除与旧主服务器连接断开超过down-after-milliseconds * 10毫米的从服务器。</p></li><li><p>选择优先级最高的服务器。</p></li><li><p>选择复制偏移量最大的服务器。</p></li><li><p>选择运行ID最小的服务器。</p></li></ol></li><li><p>让其他从服务器复制新主服务器。</p></li><li><p>将旧主服务器设置为新主服务器的从服务器。</p></li></ol><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="CLUSTER-MEET命令"><a href="#CLUSTER-MEET命令" class="headerlink" title="CLUSTER MEET命令"></a>CLUSTER MEET命令</h2><p>刚开始时，每个节点都属于自己的集群，向一个节点发送CLUSTER MEET命令，可以让当前节点和目标节点进行握手，握手成功时，将ip和port指定的节点加入到当前节点所在的集群中，握手过程：</p><p><img src="/images/Redis/image-20200924232022113.png" alt="image-20200924232022113"></p><h2 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h2><p><strong>集群的整个数据库被分为16384（2^14）个槽（slot）</strong>，数据库中的每个键都属于其中某一个slot，每个节点负责处理若干个slot，当所有slot都有节点负责处理时，集群处于上线状态，否则处于下线状态（fail）。</p><ul><li>节点结构中的clusterNode.slots是一个16384位的二进制数组，记录了节点负责处理哪些slot。</li><li>集群状态结构中的clusterState.slots是一个clusterNode节点数组，记录了集群中16384个slot分别分配给了哪个节点。</li></ul><h2 id="集群命令执行过程"><a href="#集群命令执行过程" class="headerlink" title="集群命令执行过程"></a>集群命令执行过程</h2><p>当客户端向节点发送与某个键相关的命令时，节点得到键所属的slot，若该slot指派给了当前节点，则直接执行该命令，否则会向客户端返回一个<code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code>错误，指引客户端redirect到正确的节点，并再次发送命令。</p><p><img src="/images/Redis/image-20200924233646774.png" alt="image-20200924233646774"></p><h3 id="键所属slot的计算与存储"><a href="#键所属slot的计算与存储" class="headerlink" title="键所属slot的计算与存储"></a>键所属slot的计算与存储</h3><p>键所属的slot根据<code>CRC16(key) &amp; (16384 - 1)</code>进行计算，其中CRC16(key)用于计算键的CRC-16校验和。</p><p>除了将键值对保存在数据库之外，节点会用clusterState.slots_to_keys来保存slot和键之间的关系，<strong>跳跃表</strong>的<strong>score为slot号，member为键</strong>。</p><h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p>将任意数量已经指派的slot重新指派给另一个节点，并且slot相关的键值对数据也会移动过去。</p><p>重新分片是由Redis集群管理软件redis-trib负责执行的，对单个slot重新分片的步骤如下：</p><p><img src="/images/Redis/image-20200925000826229.png" alt="image-20200925000826229"></p><ol><li>redis-trib向目标节点发送命令<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>，让目标节点准备接受slot相关的键值对。</li><li>redis-trib向源节点发送命令<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code>，让源节点准备将slot相关的键值对迁移到目标节点。</li><li>redis-trib向源节点发送命令<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>，获得最多count个属于slot的键名。</li><li>对于步骤3获得的每个键名，redis-trib都向源节点发送命令<code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code>，原子性地迁移键的数据。</li><li>重复执行步骤3、4直到所有属于slot的键值对都迁移完毕。</li><li>redis-trib向集群中的任意一个节点发送命令<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code>，最终所有节点都会知道slot已经被指派给了目标节点。</li></ol><p>如果在重新分片期间，客户端需要访问一个属于正在迁移的slot的键，那么源节点首先在自己的数据库中进行查找，若没有找到，则返回一个<code>ASK &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code>，指引客户端redirect到目标节点执行命令。</p><h2 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h2><p>Redis集群的节点分为主节点和从节点，其中主节点用于处理slot，从节点用于复制某个主节点，并在复制的主节点下线时，代替下线主节点继续处理命令请求。</p><h3 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h3><p>命令<code>CLUSTER REPLICATE &lt;node_id&gt;</code>可以让当前节点称为node_id的从节点，并开始对主节点进行复制（相当于执行SLAVEOF命令）。</p><h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>集群中的每个节点会定期向其他节点发送<strong>PING消息</strong>，若某个节点没有在规定时间内返回PONG消息，则标记该节点为疑似下线（PFAIL），节点之间会通过相互发送消息的方式获取其他节点的状态信息，当半数以上负责处理slot的主节点都将某个主节点标记为疑似下线时，那么该节点将被标记为已下线（FAIL），并立即通知其他节点。</p><h3 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h3><p>当一个从节点发现自己复制的主节点已下线时，开始对主节点进行故障转移：</p><ol><li><p>选举一个从节点执行命令<code>SLAVEOF on one</code>，成为新的主节点。<strong>选举方式</strong>（与领头Sentinel选举基本一致）：</p><p>每个发现主节点已下线的从节点都会向集群广播一条命令，<strong>第一次</strong>收到该命令且<strong>正在负责处理slot的主节点</strong>会返回一条投票消息，若某个从节点收到的返回消息数量大于<strong>正在负责处理slot的主节点数量</strong>的一半时，该节点成为新主节点。</p><p>若在一个配置纪元里没有成功选举出一个新主节点，那么集群进入一个新的配置纪元再次进行选举。</p></li><li><p>新主节点撤销已下线主节点的所有slot指派，并将这些slot指派给自己。</p></li><li><p>新主节点向集群广播一条PONG消息，通知其他节点自己是新主节点。</p></li><li><p>新主节点开始接收和负责处理slot相关请求，故障转移完成。</p></li></ol><h1 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h1><h2 id="订阅与退订"><a href="#订阅与退订" class="headerlink" title="订阅与退订"></a>订阅与退订</h2><p>Redis将所有频道的订阅关系保存在服务器状态的<strong>pubsub_channels字典</strong>中，键是频道，值是订阅该频道的客户端链表。</p><h3 id="SUBSCRIBE"><a href="#SUBSCRIBE" class="headerlink" title="SUBSCRIBE"></a>SUBSCRIBE</h3><p>当客户端执行SUBSCRIBE命令订阅某个频道时，若该频道已存在，则将客户端加入到对应链表尾部，否则在字典中添加一个新频道，并将客户端加入到对应链表。</p><h3 id="UNSUBSCRIBE"><a href="#UNSUBSCRIBE" class="headerlink" title="UNSUBSCRIBE"></a>UNSUBSCRIBE</h3><p>当客户端执行UNSUBSCRIBE命令退订某个频道时，服务器会从对应链表中删除该客户端节点，若删除后为空链表，则将频道对应的键也从字典中删除。</p><h2 id="模式订阅与退订"><a href="#模式订阅与退订" class="headerlink" title="模式订阅与退订"></a>模式订阅与退订</h2><p>模式订阅可以通过模式匹配来定义满足该模式的所有频道，如<code>PSUBSCRIBE &quot;news.*&quot;</code>。</p><p>模式的订阅关系都被保存在服务器状态的<strong>pubsub_patterns链表</strong>里面，链表的每个节点记录了被订阅的模式和客户端。PSUBSCRIBE和PUNSUBSCRIBE命令分别添加和删除一个节点。</p><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>命令<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>将消息message发送给频道channel。</p><p>Redis服务器首先将消息发送给<strong>pubsub_channels字典</strong>中频道channel对应的所有订阅者，然后遍历<strong>pubsub_patterns链表</strong>，当遇到与channel频道相匹配的模式时，将消息发送给对应客户端。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务开始：<code>MULTI</code>命令。</p><p>命令入队：每个Redis客户端都有自己的事务状态，其中的事务队列来保存事务期间的多条命令。</p><p>事务执行：<code>EXEC</code>命令开始执行事务，服务器会遍历客户端的事务队列，执行队列中的所有命令，最后将结果返回给客户端。</p><h2 id="WATCH命令"><a href="#WATCH命令" class="headerlink" title="WATCH命令"></a>WATCH命令</h2><p><strong>WATCH命令是一个乐观锁</strong>，可以在EXEC命令执行之前调用来监视一些键的变化。</p><p>若在EXEC执行时，被WATCH监视的键发生了修改，服务器则拒绝执行事务，并向客户端返回空回复（nil）。</p><h3 id="WATCH原理"><a href="#WATCH原理" class="headerlink" title="WATCH原理"></a>WATCH原理</h3><p>Redis数据库中保存着一个<strong>watched_keys字典</strong>，该字典的键是被WATCH命令监视的键，值是监视该键的客户端链表。</p><p>对于SET、LPUSH、SADD、ZREM、DEL等会对数据库进行修改的命令，在执行之后会检查watched_keys字典是否存在刚刚操作的键，若存在，则打开将该键对应链表中的客户端的<strong>REDIS_DIRTY_CAS标识</strong>。而在EXEC执行时，服务器会根据客户端的REDIS_DIRTY_CAS状态来决定是否执行事务。</p><p>避免MULTI（开始事务）和EXEC（执行事务）执行之间，其他客户端操作当前客户端事务涉及的key。</p><h2 id="Redis中事务的性质"><a href="#Redis中事务的性质" class="headerlink" title="Redis中事务的性质"></a>Redis中事务的性质</h2><p>在Redis中，事务总是满足<strong>原子性，一致性和隔离性</strong>的，并且当Redis开启持久化模式时，也满足<strong>持久性</strong>。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>Redis事务队列中的命令要么全部执行，要么一个都不执行。但是Redis<strong>不支持事务回滚</strong>，即使事务队列中某个命令执行出现了错误，整个事务也会继续执行下去。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>Redis通过错误检测和一些设计来保证食物的一致性。</p><p><strong>入队错误：</strong>如果一个事务在命令入队时出现了命令不存在或命令格式错误的情况，Redis会拒绝执行该事务。</p><p><strong>执行错误：</strong>执行错误是一些不能在入队时被检查出来的错误。若事务在执行过程中发生了错误，服务器不会中断事务的执行。</p><p><strong>服务器停机：</strong>若Redis在执行事务的过程中停机，服务器要么无持久化机制，重启之后为空白数据库，要么根据RDB或者AOF文件恢复数据。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>Redis使用<strong>单线程模式</strong>来执行事务，因此Redis的隔离级别总是<strong>串行化</strong>的。</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>Redis只是简单的用队列包裹了一组Redis命令，没有为事务提供额外的持久化机制，因此Redis的持久性由Redis的持久化模式决定。</p><p>若Redis运行在无持久化、RDB持久化、AOF持久化（appendfsync值为everysec）下，事务不具有持久性。</p><p>若Redis运行在<strong>AOF持久化且appendfsync值为always</strong>，事务具有持久性。</p><p>或者在<strong>事务的最后，EXEC之前加上SAVE</strong>命令，可以保证事务的持久性。</p><h1 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h1><p>Redis在服务器嵌入Lua环境，客户端可以使用Lua脚本直接在服务器端原子地执行多个Redis命令。</p><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><ul><li>slowlog-log-slower-than：执行时间超过指定微秒的命令会记录在日志上。</li><li>slowlog-max-len：最多保存多少条慢查询日志，<strong>链表保存，先进先出</strong>。</li></ul><h1 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h1><p>通过执行MONITOR命令，客户端可以将自己变为一个监视器。每当一个客户端向服务器发送一条命令时，服务器除了会处理命令之外，还会将命令信息发给monitors链表中的所有监视器。</p><h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><h2 id="缓存和数据库一致性问题"><a href="#缓存和数据库一致性问题" class="headerlink" title="缓存和数据库一致性问题"></a>缓存和数据库一致性问题</h2><p>使用缓存只能通过合适的策略来降低缓存和数据库之间不一致的概率，无法保证两者间的强一致性。</p><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md" target="_blank" rel="noopener">https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md</a></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>指对于会被高并发访问的若干个热点数据，在这个数据失效的瞬间，这些高并发访问直接落到了数据库上。</p><p>解决方法：</p><ul><li>设置热点数据永不过期，需要时再进行更新。</li><li>对热点数据加互斥锁，同时只能有一个线程访问数据库的数据，一个线程访问后重建缓存。</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>指某个时间点缓存数据大规模失效，此时请求就会直接到达数据库，造成数据库短时间内承受大量请求而崩掉。</p><p>解决方法：</p><ul><li><p>设置热点数据永不过期，需要时再进行更新。</p></li><li><p>对数据的过期时间额外加上一个随机值，避免同时失效。</p></li><li><p>构建多级缓存。</p></li><li><p>对于集群Redis，可以将热点数据均匀分布在不同的Redis库中。</p></li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>指大量请求的key根本不存在于缓存中，导致请求直接到达数据库。</p><p>解决方法：</p><ul><li><p>在接口层过滤掉不合法的查询，如负数id。</p></li><li><p>布隆过滤器：把所有有效请求的值都存放在布隆过滤器中，通过布隆过滤器判断请求是否有效。</p><p><img src="/images/Redis/image-20200904164234280.png" alt="image-20200904164234280"></p><p>布隆过滤器由一个二进制数组和一系列Hash函数组成，当一个元素加入过滤器时，通过K个Hash函数将这个元素映射为K个下标，然后把二进制中对应位置置为1。</p></li><li><p>缓存无效key：查询数据库中也没用的数据时，返回一个key-null缓存到Redis中，并设置一个较短过期时间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis相关知识点。&lt;/p&gt;
&lt;p&gt;Redis是一个开源的高性能键值对的内存数据库，可以用作数据库、缓存、消息中间件等，是一种NoSQL数据库（Not-only SQL，非关系型数据库）。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://djsFFF.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://djsFFF.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://djsFFF.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java项目设计</title>
    <link href="http://djsFFF.github.io/2020/08/29/Java%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1/"/>
    <id>http://djsFFF.github.io/2020/08/29/Java项目设计/</id>
    <published>2020-08-29T12:15:00.000Z</published>
    <updated>2023-05-01T01:37:16.613Z</updated>
    
    <content type="html"><![CDATA[<p>记录常问的项目设计思路。</p><a id="more"></a><h1 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h1><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><ul><li>高并发：时间极短，瞬间用户量大。</li><li>超卖：实际下单数量超出了限购的数量。</li><li>恶意请求：</li><li>链接暴露：</li><li>数据库：</li></ul><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><p><img src="/images/Java%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1/v2-8aade443815c569af8599b0683e04b69_r.jpg" alt="preview"></p><ul><li>服务单一职责：单独建立秒杀数据库。</li><li>秒杀链接加盐：url动态化，通过MD5等加密算法加密随机的字符串做url。</li><li>Redis集群：主从同步、读写分离、哨兵。</li><li>Nginx：负载均衡。</li><li>资源静态化</li><li>限流<ul><li>前端限流：点击一次后置灰一定时间防止连续点击。</li><li>后端限流：只有秒杀成功的用户进行后续订单生成和支付等操作。</li></ul></li><li>库存预热：提前把商品的库存加载到Redis中，让整个流程都在Redis中进行，秒杀结束后再写回数据库。分布式锁。</li><li>限流、降级、熔断、隔离：</li><li>削峰填谷：消息队列。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录常问的项目设计思路。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="http://djsFFF.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Java" scheme="http://djsFFF.github.io/tags/Java/"/>
    
      <category term="后台开发" scheme="http://djsFFF.github.io/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java项目问题</title>
    <link href="http://djsFFF.github.io/2020/08/29/Java%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://djsFFF.github.io/2020/08/29/Java项目问题/</id>
    <published>2020-08-29T12:15:00.000Z</published>
    <updated>2023-05-01T01:37:16.613Z</updated>
    
    <content type="html"><![CDATA[<p>Java项目问题。</p><a id="more"></a><h1 id="论坛后台"><a href="#论坛后台" class="headerlink" title="论坛后台"></a>论坛后台</h1><h2 id="基于拦截器检查登录状态和权限"><a href="#基于拦截器检查登录状态和权限" class="headerlink" title="基于拦截器检查登录状态和权限"></a>基于拦截器检查登录状态和权限</h2><p><img src="/images/Java%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/image-20200902164036093.png" alt="image-20200902164036093"></p><p>对于一些需要登录才能访问或者需要一定权限的路径如个人信息，需要使用拦截器检查登录状态。</p><p>在用户浏览网页时，需要检查用户登陆状态，通过拦截器实现：</p><ol><li><p>实现HandlerInterceptor接口中的三个方法：</p><ul><li><p>preHandler()：在Controller之前执行。获取Cookie中的凭证id，然后在数据库中查询凭证有效状态并根据凭证获取到User对象并保存到ThreadLocal变量hostHolder中。</p></li><li><p>postHandler()：在Controller之后，模板引擎之前执行。从hostHolder获取到User并传给模板引擎。</p></li><li><p>afterCompletion()：在模板引擎之后执行。清除hostHolder。</p></li></ul></li><li><p>在实现WebMvcConfigurer接口的类中addInterceptors()配置拦截器：拦截哪些路径，不拦截哪些路径。</p></li></ol><h2 id="基于Kafka实现消息队列"><a href="#基于Kafka实现消息队列" class="headerlink" title="基于Kafka实现消息队列"></a>基于Kafka实现消息队列</h2><p>私信通知，评论点赞通知等。</p><h3 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h3><ol><li>不使用消息队列时，用户的请求会直接到达服务器并通过数据库或者缓存响应，而在高并发情况下，可能会超过数据库的承受能力，造成响应速度缓慢甚至宕机。而使用消息队列后，用户的请求数据存入消息队列后就可以立即返回，<strong>减少了响应时间</strong>，消息队列的消费者进程可以异步地处理消息队列中的消息，<strong>降低数据库在高峰期的压力</strong>。</li><li>使用消息队列还可以<strong>降低系统的耦合性</strong>，生产者和消费者之间不需要直接通信，而是通过共享消息队列进行交互。</li></ol><h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><h2 id="网站数据统计"><a href="#网站数据统计" class="headerlink" title="网站数据统计"></a>网站数据统计</h2><h3 id="UV（Unique-Visitor）"><a href="#UV（Unique-Visitor）" class="headerlink" title="UV（Unique Visitor）"></a>UV（Unique Visitor）</h3><p>统计不重复IP的访问次数。</p><h3 id="DAU（Daily-Active-User）"><a href="#DAU（Daily-Active-User）" class="headerlink" title="DAU（Daily Active User）"></a>DAU（Daily Active User）</h3><p>日活跃用户，使用Bitmap，以用户ID作为下标。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java项目问题。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="http://djsFFF.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Java" scheme="http://djsFFF.github.io/tags/Java/"/>
    
      <category term="后台开发" scheme="http://djsFFF.github.io/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习1</title>
    <link href="http://djsFFF.github.io/2020/08/29/Spring%E5%AD%A6%E4%B9%A01/"/>
    <id>http://djsFFF.github.io/2020/08/29/Spring学习1/</id>
    <published>2020-08-29T12:15:00.000Z</published>
    <updated>2023-05-01T01:37:16.614Z</updated>
    
    <content type="html"><![CDATA[<p>Spring学习。</p><a id="more"></a><h1 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h1><p>IoC（Inverse of Control，反转控制）是一种设计思想，将原本手动创建对象的控制权交给Spring框架来管理。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，减少系统的重复代码，降低模块的耦合度，有利于提高系统的可扩展性和可维护性。</p><p><img src="/images/Spring%E5%AD%A6%E4%B9%A01/image-20200830194807094.png" alt="image-20200830194807094"></p><p>AOP基于动态代理，如果代理的对象实现了某个接口，那么Spring AOP会使用JDK Proxy去创建代理对象，而对于没有实现接口的对象，使用Cglib生成一个被代理对象的子类来作为代理。</p><h2 id="Spring-AOP与Aspect-AOP"><a href="#Spring-AOP与Aspect-AOP" class="headerlink" title="Spring AOP与Aspect AOP"></a>Spring AOP与Aspect AOP</h2><ul><li>Spring AOP：运行时增强，基于动态代理，简单。</li><li>Aspect AOP：编译时增强，基于字节码操作，强大，更快。</li></ul><h1 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h1><p>@scope(“singleton”)</p><ul><li><strong>singleton</strong>：在Spring IoC容器中只存在一个Bean实例，即以单例方式存在，默认值。</li><li><strong>prototype</strong>：每次从容器中调用Bean时，都返回一个新的实例。</li><li>request：每次HTTP请求都会创建一个新的Bean，仅适用于WebApplicationContext环境。</li><li>session：同一个HTTP Session共享一个Bean，仅适用于WebApplicationContext环境。</li><li>global-session：全局session，一般用于Portlet应用环境，仅适用于WebApplicationContext环境。</li></ul><h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><p><img src="/images/Spring%E5%AD%A6%E4%B9%A01/880f402c83a0e04f2b4ccfcec3239dc8_r.jpg" alt="preview"></p><ol><li><p>实例化Bean：new操作，调用构造方法。</p></li><li><p>设置对象属性：利用依赖注入调用setter设置属性值。</p></li><li><p>BeanNameAware接口，Spring将Bean的id传给setBeanName()。</p></li><li><p>BeanFactoryAware接口，Spring调用setBeanFactory()，将BeanFactory容器实例传入。</p></li><li><p>ApplicationContextAware接口，Spring调用setApplicationContext()，将bean所在应用的上下文引用传入。</p></li><li><p>BeanPostProcessor接口，Spring调用他们的postProcess<strong>Before</strong>Initialization()。</p></li><li><p>InitializingBean接口，Spring调用他们的afterPropertiesSet()。</p></li><li><p>调用配置文件中包含init-method属性的方法</p></li><li><p>BeanPostProcessor接口，Spring调用他们的postProcess<strong>After</strong>Initialization()。</p></li><li><p>Bean已经准备就绪，可以被使用。</p></li><li><p>DisposableBean接口，Spring将调用destory()。</p></li><li><p>调用配置文件中包含destroy-method属性的方法。</p></li></ol><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p>Spring MVC是一个基于MVC设计模式的框架，通过把Model，View，Controller分离，将表现层（其他两层：业务层，数据访问层）进行解耦，简化开发，减少出错，方便组内人员之间的配合。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>用户发送请求到前端控制器DispatcherServlet。</li><li>DispatcherServlet根据请求调用HandlerMapping，获取到对应的Handler。</li><li>DispatcherServlet调用HandlerAdapter来执行Handler，并返回一个ModelAndView对象。</li><li>DispatcherServlet调用ViewResolver对视图进行解析，并将Model数据填充到视图中。</li><li>最后DispatcherServlet将View返回给用户。</li></ol><h1 id="相关设计模式"><a href="#相关设计模式" class="headerlink" title="相关设计模式"></a>相关设计模式</h1><ol><li>工厂模式：BeanFactory、ApplicationContext创建Bean对象。</li><li>代理模式：Spring AOP的实现。</li><li>单例模式：Bean的默认作用域。</li><li>装饰器模式：不同的客户在每次访问中会根据需求去访问不同的数据库。</li><li>观察者模式：Spring事件驱动模型。</li><li>适配器模式：Spring AOP的增强或通知、Spring MVC使用适配器模式适配Controller。</li></ol><h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><h2 id="管理事务的方式"><a href="#管理事务的方式" class="headerlink" title="管理事务的方式"></a>管理事务的方式</h2><ul><li>编程式事务：代码中硬编码。</li><li>声明式事务：在配置文件中配置。基于XML或基于注解。</li></ul><h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p>规定了事务方法或事务方法嵌套调用时的事务传播方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation=propagation.REQUIRED)</span><br><span class="line">methodA &#123;</span><br><span class="line">methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation=propagation.[以下七种传播机制])</span><br><span class="line">methodB &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><blockquote><p>如果当前没有事务，则新建一个事务，如果已经存在一个事务中，则加入该事务。</p></blockquote><p>如果当前没有事务，则创建一个事务；如果当前已经处于一个事务中，则加入到该事务。默认设置。</p><h3 id="supports"><a href="#supports" class="headerlink" title="supports"></a>supports</h3><blockquote><p>支持当前事务，如果当前没有事务，则以非事务方式执行。</p></blockquote><p>如果当前没有事务，则以非事务方式执行；如果当前已经处于一个事务中，则加入到该事务。</p><h3 id="mandatory"><a href="#mandatory" class="headerlink" title="mandatory"></a>mandatory</h3><blockquote><p>使用当前事务，如果当前没有事务，则抛出异常。</p></blockquote><p>如果当前没有事务，则抛出异常；如果当前已经处于一个事务中，则加入到该事务。</p><h3 id="requires-new"><a href="#requires-new" class="headerlink" title="requires_new"></a>requires_new</h3><blockquote><p>新建事务，如果当前存在事务，则把当前事务挂起。</p></blockquote><p>如果当前没有事务，则创建一个事务；如果当前已经处于一个事务中，则把已存在的事务挂起，新创建一个事务并执行。</p><h3 id="not-supported"><a href="#not-supported" class="headerlink" title="not_supported"></a>not_supported</h3><blockquote><p>以非事务方式执行，如果当前存在事务，则把当前事务挂起。</p></blockquote><p>如果当前没有事务，则以非事务方式执行；如果当前已经处于一个事务中，则把已存在的事务挂起。</p><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><blockquote><p>以非事务方式执行，如果当前存在事务，则抛出异常。</p></blockquote><p>如果当前没有事务，则以非事务方式执行；如果当前已经处于一个事务中，则抛出异常。</p><h3 id="nested"><a href="#nested" class="headerlink" title="nested"></a>nested</h3><p>如果当前没有事务，则创建一个事务；如果当前已经处于一个事务中，则创建一个嵌套事务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://djsFFF.github.io/categories/Spring/"/>
    
    
      <category term="Java" scheme="http://djsFFF.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="http://djsFFF.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程</title>
    <link href="http://djsFFF.github.io/2020/08/15/Java%E5%B9%B6%E5%8F%91/"/>
    <id>http://djsFFF.github.io/2020/08/15/Java并发/</id>
    <published>2020-08-15T12:15:00.000Z</published>
    <updated>2023-05-01T01:37:16.613Z</updated>
    
    <content type="html"><![CDATA[<p>Java并发编程。</p><a id="more"></a><h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="线程创建的方式"><a href="#线程创建的方式" class="headerlink" title="线程创建的方式"></a>线程创建的方式</h2><ul><li>Thread：继承<strong>Thread</strong>类并重写run方法，直接使用this可以获取当前线程。</li><li>Runnable：实现<strong>Runnable</strong>接口并传递给<strong>Thread</strong>。可以继承其他类，多个线程可以共用一个代码逻辑。</li><li>FutureTask：实现<strong>Callable</strong>接口传递给<strong>FutureTask</strong>，然后把FutureTask传递给<strong>Thread</strong>。可获取返回结果。</li></ul><h2 id="线程通知与等待"><a href="#线程通知与等待" class="headerlink" title="线程通知与等待"></a>线程通知与等待</h2><p><strong>Object</strong>类中的通知与等待系列函数，这些方法<strong>获得该对象的锁后才能调用</strong>：</p><ul><li>wait()：线程阻塞并释放当前对象的锁。返回情况：<ul><li>其他线程调用<strong>锁对象</strong>的notify()或notifyAll()。</li><li>其他线程调用<strong>该线程</strong>的interrupt()，该线程抛出InterruptedException异常返回。</li></ul></li><li>notify()：随机唤醒一个被挂起的线程来竞争锁。</li><li>notifyAll()：唤醒所有被挂起的线程来竞争锁。</li></ul><p><strong>Thread</strong>类中的通知与等待系列函数：</p><ul><li>join()：阻塞当前线程，等待目标线程执行完毕。</li><li>sleep()：当前线程让出CPU使用权，被阻塞挂起，但是不会释放锁。</li><li>yield()：当前线程让出CPU使用权，不会被阻塞，处于就绪状态。</li></ul><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>JVM会等待所有用户线程结束后才退出，而守护线程（Daemon Thread）是否结束不影响JVM的退出。</p><h2 id="线程本地变量"><a href="#线程本地变量" class="headerlink" title="线程本地变量"></a>线程本地变量</h2><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>访问ThreadLocal变量的线程会在线程中有一个本地副本，操作这个变量不需要与主内存同步。</p><p>实现原理：每个<strong>Thread实例</strong>中有一个ThreadLocalMap类型的threadLocals变量，threadLocals以当前ThreadLocal的实例对象引用（this）为key对数据进行存储与读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; <span class="keyword">var</span> = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="keyword">var</span>.set(<span class="string">"test"</span>);</span><br><span class="line">System.out.println(<span class="keyword">var</span>.get());</span><br></pre></td></tr></table></figure><p>内存泄漏问题：ThreadLocalMap的key是对ThreadLocal对象的弱引用，当其他地方没有对ThreadLocal对象的引用时，ThreadLocal对象会被回收，但是对应的value没有被回收，这时候就存在key为null但是value不为null的项。解决方法是使用完毕后调用remove()。</p><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>InheritableThreadLocal继承自ThreadLocal，可以让子线程访问父线程中设置的本地变量。</p><p>实现原理：每个Thread实例中保存了类似threadLocals的inheritableThreadLocals变量，在当前线程创建新线程时，把当前线程的inheritableThreadLocals变量赋给新线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread parent = currentThread(); <span class="comment">// parent为当前线程</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.inheritableThreadLocals = <span class="comment">// this为当前线程正在初始化的新线程</span></span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalRandom"><a href="#ThreadLocalRandom" class="headerlink" title="ThreadLocalRandom"></a>ThreadLocalRandom</h3><p>每个Thread实例维护一个线程级别的种子变量threadLocalRandomSeed，避免了竞争。</p><h2 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h2><p>多线程情况下，可能会出现<strong>缓存一致性</strong>问题（其他线程修改了变量的值并刷新到了主内存中，但是当前线程的工作内存没有及时刷新，与主内存的值不一致）。</p><p>锁的可见性就是通过缓存无效化解决这一问题。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul><li><p>加锁时，先清除工作内存变量值，然后从主内存读取。</p></li><li><p>释放锁时，把代码块里的共享变量修改刷新到主内存。</p></li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>内存语义</p><ul><li><p>读volatile变量时，先清除工作内存变量值，然后从主内存读取。</p></li><li><p>写volatile变量时，把共享变量刷新到主内存。</p></li></ul><p>禁止重排序</p><ul><li>读volatile变量时，确保读之后的操作不会被重排序到读之前。</li><li>写volatile变量时，确保写之前的操作不会被重排序到写之后。</li></ul><h2 id="锁的类别"><a href="#锁的类别" class="headerlink" title="锁的类别"></a>锁的类别</h2><ul><li>悲观锁：认为共享变量很容易发生竞争，因此对共享变量进行操作时会加锁。</li><li>乐观锁：任务共享变量一般情况下不会发生竞争，所以在操作前不会加锁，而是在更新时才进行冲突检测。</li><li>公平锁：线程获取锁的顺序是按照现场请求锁的时间决定的，会带来性能开销。</li><li>非公平锁：线程获取锁的顺序不确定。</li><li>独占锁：保证任何时候只能有一个线程获得锁。是一种悲观锁。</li><li>共享锁：允许多个线程同时进行读操作。是一种乐观锁。</li><li>可重入锁：线程再次获取当前已有的锁不会被阻塞。通过在锁内部维护一个线程标志和计数器实现。</li><li>自旋锁：执行忙循环检测是否可以获得锁。</li></ul><h1 id="JUC并发包（java-util-concurrent）"><a href="#JUC并发包（java-util-concurrent）" class="headerlink" title="JUC并发包（java.util.concurrent）"></a>JUC并发包（java.util.concurrent）</h1><h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><h3 id="AtomicInteger、AtomicLong、AtomicBoolean"><a href="#AtomicInteger、AtomicLong、AtomicBoolean" class="headerlink" title="AtomicInteger、AtomicLong、AtomicBoolean"></a>AtomicInteger、AtomicLong、AtomicBoolean</h3><p>属于java.util.concurrent.atomic包</p><ul><li>基于Unsafe的<strong>CAS</strong>保证数据操作的<strong>原子性</strong>。</li><li>通过对value加<strong>volatile关键字</strong>保证<strong>可见性</strong>和<strong>有序性</strong>。</li></ul><h3 id="LongAdder、DoubleAdder"><a href="#LongAdder、DoubleAdder" class="headerlink" title="LongAdder、DoubleAdder"></a>LongAdder、DoubleAdder</h3><p>AtomicLong等类在有大量线程竞争时，会不断自旋尝试CAS操作，造成了CPU资源浪费，LongAdder类在内部维护多个Cell变量（一个Cell数组），每个Cell有一个<strong>volatile修饰</strong>的long型变量。当线程在当前Cell变量CAS失败后，可以在其他Cell上进行CAS尝试，最后把<strong>所有Cell的值累加后再加上base</strong>返回。</p><p>使用<code>@sun.misc.Contended</code>注解修饰Cell类<strong>避免伪共享</strong>。</p><p>调用sum()返回当前的值，但是没有加锁，所以返回的值不一定准确。</p><h2 id="并发List"><a href="#并发List" class="headerlink" title="并发List"></a>并发List</h2><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>是一个线程安全的ArrayList，使用了写时复制策略，对其进行的修改操作都是在一个复制的数组上进行的。</p><p>内部使用一个<strong>volatile修饰</strong>的数组来存放具体元素。</p><p>get()不加锁。add()、set()、remove()时加<strong>ReentrantLock</strong>锁，对数组的一个快照进行操作，不影响其他线程读取原数组，然后更新原数组的引用。</p><p>迭代器的弱一致性：返回迭代器后，其他线程对list的增删改对迭代器是不可见的。</p><p>CopyOnWriteArraySet底层是使用CopyOnWriteArrayList实现的。</p><h2 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h2><h3 id="LockSupport工具类"><a href="#LockSupport工具类" class="headerlink" title="LockSupport工具类"></a>LockSupport工具类</h3><p>主要作用是挂起和唤醒线程，是创建锁和其他同步类的基础。基于Unsafe类的park()和unpark()实现。</p><p>LockSupport类与每个使用它的线程会关联一个许可证，默认情况下调用LockSupport类方法的线程是不持有许可证的。</p><ul><li>park()：调用线程如果已经获得许可证，则调用时会马上返回，否则会被阻塞挂起。</li><li>unpark(Thread thread)：如果线程没有持有许可证，则让线程持有，如果线程因调用park()挂起，则唤醒线程。</li></ul><h3 id="抽象同步队列AQS（AbstractQueueSynchronizer）"><a href="#抽象同步队列AQS（AbstractQueueSynchronizer）" class="headerlink" title="抽象同步队列AQS（AbstractQueueSynchronizer）"></a>抽象同步队列AQS（AbstractQueueSynchronizer）</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200903224211947.png" alt="image-20200903224211947"></p><p>是实现同步器的基础组件，JUC中锁的底层就是使用AQS实现的。</p><p>AQS是一个双向队列，head和tail记录队首和队尾结点。</p><h4 id="静态内部类Node"><a href="#静态内部类Node" class="headerlink" title="静态内部类Node"></a>静态内部类Node</h4><ul><li>Thread thread：<strong>volatile</strong>修饰，存放进入AQS的线程。</li><li>Node SHARED：标记该线程是获取<strong>共享资源</strong>时被阻塞后放入AQS的。</li><li>Node EXCLUSIVE：标记该线程是获取<strong>独占资源</strong>时被阻塞后加入AQS的。</li><li>Node pre, next：<strong>volatile</strong>修饰，记录前驱和后继结点。</li></ul><h4 id="AQS维护了一个volatile修饰的状态信息state"><a href="#AQS维护了一个volatile修饰的状态信息state" class="headerlink" title="AQS维护了一个volatile修饰的状态信息state"></a>AQS维护了一个volatile修饰的状态信息state</h4><ul><li>在ReentrantLock中：state表示当前线程获取锁的可重入次数。</li><li>在ReentrantReadWriteLock中：state高16位表示读锁的次数，低16位表示获取到写锁的线程可重入次数。</li><li>在Semaphore中：state用于表示当前可用信号的个数。</li><li>在CountDownLatch中：state表示计数器的值。</li></ul><h4 id="内部类ConditionObject"><a href="#内部类ConditionObject" class="headerlink" title="内部类ConditionObject"></a>内部类ConditionObject</h4><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200819100243950.png" alt="image-20200819100243950"></p><p>实现了Condition接口，每个条件变量对应一个条件队列，用于存放条件变量的await()后被阻塞的线程。</p><p>Node firstWaiter, lastWaiter分别记录了条件队列的头、尾结点。</p><p><strong>Condition</strong>类中的通知与等待系列函数，这些方法<strong>在调用锁的lock()方法获取锁后才能调用</strong>：</p><ul><li>await()：将当前线程封装成一个Node结点插入到条件队列的尾部，释放当前线程获取的锁，并调用LockSupport.park(this)挂起当前线程。</li><li>signal()：把队头线程结点从条件队列中移除并放入AQS的阻塞队列里面，然后激活这个线程。</li><li>signalAll()：移除条件队列中所有节点并放入AQS的阻塞队列里面。</li></ul><h4 id="其他锁在基于AQS实现时，关键是定义state的操作方法"><a href="#其他锁在基于AQS实现时，关键是定义state的操作方法" class="headerlink" title="其他锁在基于AQS实现时，关键是定义state的操作方法"></a>其他锁在基于AQS实现时，关键是定义state的操作方法</h4><ul><li><p>独占方式：acquire()，acquireInterruptibly()，release()。</p><p>获取与释放资源：</p><ul><li><p>线程调用acquire()获取资源：方法内部调用**tryAcquire()**尝试设置state的值，成功则直接返回，失败则将当前线程封装为一个Node结点插入到AQS队列的尾部，并调用LockSupport.park(this)挂起自己。</p></li><li><p>线程调用release()释放资源：方法内部调用**tryRelease()<strong>尝试设置state的值，然后调用LockSupport.unpark(thread)激活AQS队列中的一个线程，被激活的线程调用</strong>tryAcquire()**尝试获取锁。</p></li></ul><p>acquireInterruptibly()：忽略中断，不对中断进行响应。</p></li><li><p>tryAcquire()和tryRelease()需要由具体的子类根据需求来实现。</p></li><li><p>共享方式：acquireShared()，acquireSharedInterruptibly()，releaseShared()。获取、释放资源流程与独占方式类似。</p></li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200903223938171.png" alt="image-20200903223938171"></p><p>基于AQS实现，state表示该线程获取该锁的可重入次数，可以设置为公平锁或非公平锁。</p><ul><li>非公平锁：当一个线程第一次获取该锁时会尝试使用<strong>CAS</strong>设置state的值为1，如果成功则设置锁持有者为当前线程，否则检查锁的持有线程是不是当前线程，是的话更新state加一，否则将当前线程放入AQS队列。</li><li>公平锁：线程获取锁时，首先检查锁是否已被占有：如果没有被占有，再检查AQS队列中是否有其他线程在等待，如果没有则尝试获取锁，如果有则将当前线程加入到AQS队列尾部。如果已被占用，则检查持有锁的线程是不是当前线程，是的话则更新state加一，否则将当前线程加入到AQS队列尾部。</li></ul><p>释放锁时将state值减一，若state为0则表示释放锁。</p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200903224043298.png" alt="image-20200903224043298"></p><p>读写分离策略，内部维护了两个锁：ReadLock和WriteLock。</p><p>使用AQS实现，state的高16位表示获取到读锁的次数，低16位表示获取到写锁的线程可重入次数。</p><ul><li>写锁WriteLock：独占可重入锁，如果当前已有其他线程持有读锁或写锁，则当前线程会被阻塞挂起。</li><li>读锁ReadLock：如果当前没有其他线程持有写锁，则可以获取读锁，state的高16加1。如果有其他线程持有写锁，则当前线程会被阻塞。</li></ul><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>提供了三种模式的读写控制，调用获取锁的函数时，会返回一个long型stamp表示锁的状态，当调用释放锁和转换锁的方法时需要传入这个stamp值。</p><p>StampedLock提供三种读写模式的锁：</p><ul><li>写锁writeLock：独占锁，不可重入。当目前没有其他线程持有读锁或者写锁时才能获取到该锁。</li><li>悲观读锁readLock：共享锁，不可重入。其他线程可以加读锁，不能加写锁。</li><li>乐观读锁tryOptimisticRead：没有显式的加锁释放锁，在具体操作数据前根据stamp验证期间是否有其他线程持有了写锁。</li></ul><h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>继承自AbstractQueue，使用单向链表实现，无界队列，入队和出队操作使用<strong>CAS</strong>来实现线程安全。</p><ul><li><p>队列中保存了<strong>volatile</strong>关键字修饰的head和tail结点。</p></li><li><p>每个Node包括<strong>volatile</strong>修饰的元素和next结点。</p></li></ul><p>添加元素时通过CAS操作来保证只有一个线程可以成功追加元素到队列尾部，失败的线程会循环尝试添加元素。</p><p>通过无限循环的CAS尝试来代替阻塞，<strong>使用CPU资源换阻塞带来的用户态与内核态切换、线程切换等开销</strong>。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200901234217695.png" alt="image-20200901234217695"></p><p>都继承自AbstractQueue类，除LinkedTransferQueue外都实现了<strong>BlockingQueue</strong>接口。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904192818763.png" alt="image-20200904192818763"></p><p>使用单向链表实现，无界队列。</p><ul><li>两个ReentrantLock实例保证操作的原子性：<ul><li>putLock：调用put()、offer()等操作时在内部会尝试获取该锁，保证同时<strong>只有一个线程可以操作尾结点</strong>。</li><li>takeLock：调用take()、poll()等操作时在内部会尝试获取该锁，保证同时<strong>只有一个线程可以操作头结点</strong>。</li></ul></li><li>notEmpty为takeLock的条件变量，notFull为putLock的条件变量，是生产者-消费者模型。</li></ul><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904192834599.png" alt="image-20200904192834599"></p><p>使用数组实现，有界队列，构造时必须传入队列大小。与LinkedBlockingQueue不同的是，ArrayBlockingQueue采用一个全局锁，加锁粒度更大。</p><ul><li>数组items用于存放队列元素。</li><li>一个<strong>ReentrantLock</strong>实例lock用于保证同时只有一个线程可以进行出队入队操作。</li><li>两个lock的条件变量：<ul><li>notEmpty：队列空时，出队线程被阻塞挂起放入该条件队列。</li><li>notFull：队列满时，入队线程被阻塞挂起放入该条件队列。</li></ul></li></ul><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904200910774.png" alt="image-20200904200910774"></p><p>使用平衡二叉树堆（数组实现）实现，带优先级的无界队列。</p><ul><li>数组queue用于存放队列元素。</li><li>一个<strong>volatile</strong>修饰的int类型自旋锁allocationSpinLock保证同时只有一个线程可以扩容队列：<ul><li>0表示当前没有进行扩容。</li><li>1表示当前正在扩容。</li></ul></li><li>一个全局锁<strong>ReentrantLock</strong>实例lock用于保障同时只有一个线程可以进行出队入队操作。</li><li>一个lock的条件变量notEmpty用于实现出队的阻塞模式，由于是无界队列，入队时是非阻塞的。</li></ul><p>使用数组存放队列元素，一个自旋锁通过CAS操作来保证同时只有一个线程可以扩容队列，一个ReentrantLock控制只有一个线程可以进行入队、出队操作。notEmpty条件变量控制出队同步。</p><h2 id="线程池ThreadPoolExecutor"><a href="#线程池ThreadPoolExecutor" class="headerlink" title="线程池ThreadPoolExecutor"></a>线程池ThreadPoolExecutor</h2><p>在执行大量异步任务时线程池能够提供较好的性能，线程池里面的线程是可复用的，不需要每次执行异步任务时都重新创建和销毁线程。</p><ul><li>参数ctl是一个AtomicInteger变量，高3位表示线程池状态，低29位记录线程个数。</li><li>内部类Worker继承AQS和Runnable接口，一个Worker封装了一个线程，并实现了简单不可重入独占锁，state为0时表示锁未被获取，state为1时表示锁已被获取。</li><li>HashSet&lt;Worker&gt;类型的workers用于存储线程。</li></ul><p>使用完线程池需要调用shutdown()关闭线程池，否则会导致主线程已经退出，但是JVM仍然存在。</p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><ul><li><strong>RUNNING</strong>：接受新任务并处理阻塞队列里的任务。</li><li><strong>SHUTDOWN</strong>：拒绝新任务但是<strong>处理阻塞队列里的任务</strong>。</li><li><strong>STOP</strong>：拒绝新任务并<strong>抛弃阻塞队列里的任务，同时中断正在处理的任务</strong>。</li><li><strong>TIDYING</strong>：所有任务执行完毕后线程数为0，即将调用terminated方法。</li><li><strong>TERMINATED</strong>：终止状态。</li></ul><h3 id="线程池构造参数"><a href="#线程池构造参数" class="headerlink" title="线程池构造参数"></a>线程池构造参数</h3><ul><li>corePoolSize：线程池核心线程个数。</li><li>maximumPoolSize：线程池最大线程数量。</li><li>workQueue：保存等待执行的任务的阻塞队列：<ul><li>基于数组的有界阻塞队列ArrayBlockingQueue。</li><li>基于链表的无界阻塞队列LinkedBlockingQueue。</li><li>最多只有一个元素的阻塞队列SynchronousQueue。</li><li>优先级阻塞队列PriorityBlockingQueue。</li></ul></li><li>ThreadFactory：创建线程的工厂。</li><li>RejectedExecutionHandler：队列满并且线程个数达到最大后采取的策略。<ul><li>AbortPolicy：抛出异常。</li><li>CallerRunsPolicy：使用调用者所在的线程来运行任务。</li><li>DiscardOldestPolicy：调用poll()丢弃一个任务，执行当前任务。</li><li>DiscardPolicy：丢弃任务，不抛出异常。</li></ul></li><li>keepAliveTime：线程数量比核心线程数量多且闲置时，表示闲置线程的最大存活时间。</li><li>TimeUnit：存活时间的单位。</li></ul><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><ul><li><strong>newFixedThreadPool</strong>：核心和最大线程数都为参数nThread，阻塞队列长度为整型最大值，可以设置存活时间和阻塞队列类型。</li><li><strong>newSingleThreadExecutor</strong>：<strong>核心和最大线程数都为1</strong>，阻塞队列长度为整型最大值，可以设置存活时间和阻塞队列类型。</li><li><strong>newCachedThreadPool</strong>：按任务创建线程，初始线程个数为0，最多为整型最大值，阻塞队列为同步队列且加入同步队列的任务会被马上执行，<strong>同步队列中对多只有一个任务</strong>。</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>execute(Runnable command)：提交任务command到线程池执行。如果当前线程池的线程数量小于核心线程数量，则通过CAS操作向workers里面新增一个核心线程执行该任务。</p><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904225713537.png" alt="image-20200904225713537"></p></li></ul><h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p>可以在指定一定延迟时间后或者定时进行任务调度执行的线程池。</p><p>使用DelayQueue来存放任务，任务分为三种：</p><ul><li>一次性执行任务：执行完毕就结束了。</li><li>fixed-delay任务：同一任务在多次执行之间间隔固定时间。</li><li>fixed-rate任务：保证按照固定的频率执行。</li></ul><h2 id="线程同步器"><a href="#线程同步器" class="headerlink" title="线程同步器"></a>线程同步器</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904230700998.png" alt="image-20200904230700998"></p><p>使用AQS实现，把计数器的值赋给AQS的状态变量state，多个线程调用countDown()实际是原子性递减state。当线程调用await()方法后会被放入AQS的阻塞队列等待计数器为0再返回。</p><p>以线程数量为参数创建一个CountDownLatch实例，主线程调用countDownLatch.await()后会被阻塞，子线程执行完毕后调用countDownLatch.countDown()使countDownLatch内部的计数器减1，计数器为0时主线程的await()方法返回，表示所有子线程已执行完毕。</p><p>使用线程池管理线程时一般是直接添加Runnable到线程池，这时候就无法调用线程的join()，而CountDownLatch使我们对线程同步有更灵活的控制。</p><h3 id="回环屏障CyclicBarrier"><a href="#回环屏障CyclicBarrier" class="headerlink" title="回环屏障CyclicBarrier"></a>回环屏障CyclicBarrier</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904231215070.png" alt="image-20200904231215070"></p><p>CyclicBarrier可以让一组线程全部达到一个状态后再全部同时执行。</p><p>线程调用await()后会被阻塞，这个阻塞点称为屏障点，等所有线程都调用了await()后，线程们就会冲破屏障，继续向下执行。</p><p>基于ReentrantLock实现，本质底层还是基于AQS，parties记录线程数量，count记录还有多少个线程没有到达屏障点。使用ReentrantLock保证count更新的原子性。</p><h3 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904231439695.png" alt="image-20200904231439695"></p><p>也是一个同步器，计数器是递增的并且可以指定一个初始值，在需要同步的地方调用acquire()指定需要达到的计时器值，在线程内部调用release()使计数器加1。</p><p>也是使用AQS实现的，获取信号量时有公平和非公平策略。</p><h1 id="NIO模型——Tomcat的NioEndPoint"><a href="#NIO模型——Tomcat的NioEndPoint" class="headerlink" title="NIO模型——Tomcat的NioEndPoint"></a>NIO模型——Tomcat的NioEndPoint</h1><p><img src="/images/Java%E5%B9%B6%E5%8F%91/image-20200904233842705.png" alt="image-20200904233842705"></p><p>使用队列把接受请求与处理请求操作进行解耦，实现异步处理。实际Poller中维护一个ConcurrentLinkedQueue用于缓存任务，其本身也是一个多生产者-单消费者模型。</p><ul><li>Acceptor：套接字接受线程，用于接受用户的请求，并把请求封装为事件放入Poller的队列。只有一个。</li><li>Poller：套接字处理线程，每个Poller内部都有一个独有的队列，Poller线程从自己的队列中获取事件任务交给Worker进行处理。Poller线程的个数与处理器的核数有关。</li><li>Worker：实际处理请求的线程。</li></ul><h2 id="生产者——Acceptor线程"><a href="#生产者——Acceptor线程" class="headerlink" title="生产者——Acceptor线程"></a>生产者——Acceptor线程</h2><p>Acceptor线程中一直循环接收客户端连接请求，当成功获取到一个连接套接字后，将其封装为一个Channel对象并注册为事件存放到Poller对象的队列中。</p><h2 id="消费者——Poller线程"><a href="#消费者——Poller线程" class="headerlink" title="消费者——Poller线程"></a>消费者——Poller线程</h2><p>Poller线程中从事件队列中获取一个事件，遍历所有注册的Channel并对感兴趣的事件进行处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java并发编程。&lt;/p&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://djsFFF.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JAVA" scheme="http://djsFFF.github.io/tags/JAVA/"/>
    
      <category term="并发" scheme="http://djsFFF.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM学习系列三：高效并发</title>
    <link href="http://djsFFF.github.io/2020/08/14/JVM%E5%AD%A6%E4%B9%A03%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    <id>http://djsFFF.github.io/2020/08/14/JVM学习3：高效并发/</id>
    <published>2020-08-14T12:15:00.000Z</published>
    <updated>2023-05-01T01:37:16.613Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了《深入了解Java虚拟机：JVM高级特性与最佳实践》中第五部分“高效并发”的学习笔记。</p><a id="more"></a><p>前端编译器：把*.java文件转变为*.class文件的过程。如JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）。</p><p>即时编译器：Java虚拟器运行期把字节码转变为本地机器码的过程。如HotSpot的C1、C2编译器，Graal编译器。</p><p>提前编译器：直接把源代码编译成目标机器指令集相关的二进制代码的过程。JDK的Jaotc、Excelsior JET。</p><p>HotSpot内置了两个（或三个）即时编译器，分别是客户端编译器（C1）和服务端编译器（C2）（Graal是JDK 10出现的即时编译器）。</p><p>热点探测：基于采样、基于计数器。</p><h1 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h1><p>在计算机中，增加高速缓存可以解决处理器与内存读写速度之间的矛盾，此外处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果一致。</p><p>Java虚拟机的即时编译器中也有<strong>指令重排序</strong>优化。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/image-20200815225312598.png" alt="image-20200815225312598"></p><p>Java内存模型规定了所有变量都存储在<strong>主内存</strong>中，每条线程还有自己的工作内存（类比计算机中的高速缓存）。</p><p>线程的<strong>工作内存</strong>中保存了该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。</p><p>主内存主要对应Java堆中的对象实例数据部分。</p><p>工作内存主要对应于虚拟机栈中的部分区域。</p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>主内存与工作内存知己交互主要通过8种操作来完成：</p><ol><li>lock：作用于主内存变量，把一个变量标识为一条线程独占的状态。</li><li>unlock：作用于主内存变量，释放一个lock状态的变量。</li><li>read：作用于主内存变量，把一个变量的值从主内存传输到工作内存中。</li><li>load：作用于工作内存变量，把read操作得到的变量放入工作内存的变量副本中。</li><li>use：作用于工作内存变量，把工作内存中一个变量的值传递给执行引擎。</li><li>assign：作用于工作内存变量，把一个从执行引擎接收的值赋给工作内存的变量。</li><li>store：作用于工作内存变量，把工作内存中一个变量的值传送到主内存中。</li><li>write：作用于主内存变量，把store操作得到的变量放入主内存变量中。</li></ol><h3 id="volatile型变量"><a href="#volatile型变量" class="headerlink" title="volatile型变量"></a>volatile型变量</h3><p>当一个变量被volatile关键字修饰时，具有两个特性：</p><ol><li>此变量对所有线程可见，即当一个线程修改了变量的值，新值对于其他线程来说是可以立即得知的。</li><li>禁止指令重排序优化。</li></ol><p>volatile修饰的变量赋值后会多执行一个<code>lock add1 $0x0,(%esp)</code>操作，这个操作相对于一个内存屏障，不能把内存屏障后面的指令重排序到内存屏障之前的位置。</p><p>lock可以将本处理器的缓存写入内存，该写入操作也会引起别的处理器或别的内核无效化其缓存，相当于对缓存中的变量做了一次“store和write”操作。</p><h3 id="long和double的非原子性协定"><a href="#long和double的非原子性协定" class="headerlink" title="long和double的非原子性协定"></a>long和double的非原子性协定</h3><p>Java内存模型要求8中操作都具有原子性，但是允许虚拟机将没有被volatile修饰的64位的long和double数据的读写操作划分为两次32位的操作来进行。</p><h3 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h3><p>在Java内存模型中，基本数据类型的访问、读写都是具备原子性的。</p><p>volatile、synchronized、final关键字都能实现可见性。</p><p>volatile、synchronized关键字能保证线程之间操作的有序性。</p><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>使用内核线程实现（1:1），使用用户线程实现（1:N），使用用户线程加轻量级进程混合实现（N:M）。</p><p>Java线程的实现：主流Java虚拟机的线程模型普遍基于操作系统原生线程模型来实现，即采用1:1的线程模型。</p><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>协同式线程调度：线程的执行时间由线程本身控制，线程把自己的工作执行完成之后，要主动通知系统切换到另一个线程上去。</p><p>抢占式线程调度：由系统来分配执行时间。<strong>Java使用这种调度方式</strong>。</p><p>主流虚拟机的Java线程是被映射到系统的原生线程上实现的，所以线程调度最终还是由操作系统控制。</p><h3 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h3><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/image-20200814235021618.png" alt="image-20200814235021618"></p><p>Java定义了6中线程状态，一个线程在一个时间点只能处于一个状态：</p><ol><li><strong>新建（New）</strong>：线程创建后尚未启动。</li><li><strong>运行（Runnable）</strong>：包括操作系统线程状态中的Running和Ready，也就是可能正在执行，也可能在等待分配执行时间。</li><li><strong>无限期等待（Waiting）</strong>：无参数的wait()，join()等方法会进入该状态，需要等待其他线程唤醒。</li><li><strong>限期等待（Timed Waiting）</strong>：带参数的sleep()，wait()，join()等方法会进入该状态，一定时间后会被系统自动唤醒。</li><li><strong>阻塞（Blocked）</strong>：在程序进入同步区域的时候，线程将进入这个状态。</li><li><strong>结束（Terminated）</strong>：线程已经结束执行。</li></ol><h1 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>当多个线程同时访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他操作的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p><strong>同步</strong>是指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条（或是一些，当使用信号量的时候）线程使用。</p><p><strong>互斥</strong>是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。</p><p>互斥是因，同步是果；互斥是方法，同步是目的。</p><p><strong>synchronized</strong>：经过Javac编译之后，在同步块的前后分别形成monitorenter和monitorexit两个字节码指令，执行monitorenter指令时会将锁计数器的值加一，执行monitorexit指令时会将锁的计数器的值减一。</p><ul><li>可重入：被synchronized修饰的同步块对同一条线程来说是可重入的。</li><li>重量级锁：无法强制已获取所得线程释放锁，也无法强制正在等待锁的线程中断等待或超时退出。</li></ul><p><strong>ReentrantLock</strong>：与synchronized相似，也是可重入，多了一些高级功能，如等待可中断、可实现公平锁、锁可以绑定多个条件。</p><ul><li>等待可中断：持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，处理其他事情。</li><li>公平锁：多个线程等待同一个线程时，按照申请锁的时间顺序来依次获取锁，性能会下降。</li><li>锁绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象。</li></ul><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p><strong>互斥同步的主要问题是进行线程阻塞和唤醒带来的性能开销</strong>，因此互斥同步也被称为阻塞同步。</p><p>非阻塞同步：基于冲突检测的乐观并发策略（乐观锁），即在执行操作后若与其他线程产生了冲突，再进行其他补偿操作，如不断重试直到没有冲突。</p><p>非阻塞同步必须要求操作和冲突检测这两个步骤具有原子性，可以只通过一条处理指令完成，如<strong>比较并交换（Compare-and-Swap，CAS）</strong>。</p><p>在IA64、x86指令集中用cmpxchg指令完成CAS功能。</p><p><strong>CAS</strong>需要三个操作数，分别是内存地址V、旧的预期值A和准备设置的新值B。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则不执行更新。但是不管是否更新了V的值，都会返回V的旧值。原子操作。</p><p><strong>ABA问题</strong>：如果一个变量V初次读取的是A值，但是在赋值检查之前，有可能被修改为B值，然后又被改回A值，此时CAS操作会误认为它从来没有改变过。可以增加<strong>版本号</strong>来保证CAS的正确性。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>自旋锁：线程在获取锁的时候，如果锁已被其他线程获取，那么该线程执行忙循环（自旋）检查是否可以获取锁。</p><ul><li><p>如果自旋超过限定的次数仍然没有成功获得锁，就应当挂起线程。</p></li><li><p>避免了线程切换的开销，但是要占用处理器时间，需要一个以上的处理器核心。</p></li></ul><p>自适应自旋：在JDK 6引入，自旋的时间由上一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><ul><li>对于同一个锁对象，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机会认为这次自旋也很有可能再次成功。</li><li>如果对于某个锁，自旋很少成功获得锁，那么在以后要获取这个锁的时候直接跳过自旋过程。</li></ul><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对被检测到不可能存在共享数据竞争的锁进行消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>当一串零碎的操作都对同一个对象加锁时，虚拟机会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>“轻量级”锁是JDK 6加入的新型锁机制，目的是在无竞争的情况下使用CAS操作去消除同步使用的互斥量。</p><p>“轻量级”是相对于使用操作系统互斥量来实现的“重量级”锁而言的。</p><p>HotSpot虚拟机的对象头第一部分称为“Mark Word”，存储对象自身的运行时数据，如HashCode、分代年龄、偏向模式、锁标志位等信息。这部分是实现轻量级锁和偏向锁的关键。</p><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/image-20200815204815564.png" alt="image-20200815204815564"></p><p>MarkWord被设计成一个非固定的动态数据结构，可以根据对象的状态存储不同的信息。</p><p>轻量级锁工作过程：</p><ol><li>代码即将进入同步块时，如果同步对象没有被锁定（MarkWord中锁标志位为01），虚拟机首先在当前线程的栈中建立一个Lock Record空间，用于存储同步对象的MarkWord拷贝。</li><li>然后虚拟机使用CAS操作尝试把同步对象的MarkWord内容更新为指向Lock Record的指针，如果更新成功，则表示该线程拥有了这个对象的锁，并且更新锁标志位为“00”表示处于轻量级锁定模式。</li><li>如果更新同步对象的MarkWord内容失败，则检测对象的Mark Word是否指向当前线程的Lock Record区域，如果是，则说明已经拥有了这个对象的锁，否则说明此对象已经被其他线程抢占了。</li><li>如果出现两个以上的线程争用同一个锁，那么轻量级锁必须膨胀为重量级锁，锁标志位变为10，此时MarkWord中存储的就是指向重量级锁（互斥量）的指针。</li><li>解锁过程同样通过CAS操作进行，如果对象的MarkWord仍然指向线程的Lock Record，则用CAS操作把Lock Record中对象原本的MarkWord内容替换回去，如果替换失败，则说明其他线程尝试获取过该锁，在释放锁的时候，唤醒其他被挂起的线程。</li></ol><p>轻量级锁提升性能的依据是对于绝大部分的锁，整个同步周期内是不存在竞争的。但如果存在锁竞争，额外的CAS操作使得轻量级锁反而比重量级锁更慢。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁也是JDK 6引入的一项锁优化措施，目的是消除数据在无竞争情况下的同步原语，既不使用互斥量，也不使用CAS操作。</p><p>当锁对象第一次被线程获取时，虚拟机会把MarkWord中的锁标志位改为01，偏向模式改为1，MarkWord的内容进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的MarkWord中。如果CAS操作成功，持有偏向锁的线程以后每次获取这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（如加锁、解锁、对MarkWord的更新操作等）。</p><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/image-20200815205631602.png" alt="image-20200815205631602"></p><p>当另一个线程尝试获取这个锁的时候，若对象未被锁定，则撤销偏向并设定标志位为01；若对象已被锁定，则设定标志位为轻量级锁状态（00）。</p><p>当一个对象已经计算过一致性哈希码后，就再也无法进入偏向锁状态了。</p><p>当一个对象在偏向锁状态收到需要计算一致性哈希码请求时，偏向状态会被立即撤销，并且锁会膨胀为重量级。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了《深入了解Java虚拟机：JVM高级特性与最佳实践》中第五部分“高效并发”的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://djsFFF.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://djsFFF.github.io/tags/JVM/"/>
    
      <category term="JAVA" scheme="http://djsFFF.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习1：SQL语句</title>
    <link href="http://djsFFF.github.io/2020/08/14/MySQL%E5%AD%A6%E4%B9%A01%EF%BC%9ASQL%E8%AF%AD%E5%8F%A5/"/>
    <id>http://djsFFF.github.io/2020/08/14/MySQL学习1：SQL语句/</id>
    <published>2020-08-14T12:15:00.000Z</published>
    <updated>2023-05-01T01:37:16.613Z</updated>
    
    <content type="html"><![CDATA[<p><code>{}</code>表示必选项，<code>[]</code>表示可选项</p><a id="more"></a><h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p><code>CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset_name</code></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>整型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT</p><p>浮点型：FLOAT、DOUBLE</p><p>日期时间型：YEAR、TIME、DATE、DATETIME、TIMESTAMP</p><p>字符型：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM(‘value1’,’value2’,…)、SET(‘value1’,’value2’,…)</p><h1 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h1><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><p><code>CREATE TABLE [IF NOT EXIST] table_name (column_name data_type,...);</code></p><ul><li><p>NULL，字段允许为空；NOT NULL，字段禁止为空。</p></li><li><p>AUTO_INCREMENT：自动编号，必须与主键组合使用，默认情况下起始值为1，每次增量为1。</p></li><li><p>PRIMARY：主键，每张数据表只能存在一个主键字段，自动为NOT NULL。</p></li><li><p>UNIQUE KEY：唯一约束，每张数据表可以存在多个唯一约束字段，可以为NULL。</p></li><li><p>DEFAULT：默认值，插入记录时，如果没有明确赋值，则自动赋予默认值。</p></li><li><p>FOREIGN KEY：外键，子表（具有FOREIGN KEY的表）和父表必须使用InnoDB存储引擎；外键列和参照列必须具有相似的数据类型，必须创建索引。</p><p><code>FOREIGN KEY (pid) REFERENCES tb_name (id) ON DELETE CASCADE</code></p><p>外键约束的参照操作：</p><ul><li>CASCADE：从父表删除或更新行时自动删除或更新子表对应的行。</li><li>SET NULL：从父表删除或更新行时设置子表外键列为NULL，必须保证子表外键列没有指定NOT NULL。</li><li>RESTRICT：拒绝对父表的删除或更新操作。</li><li>NO ACTION：在MySQL中与RESTRICT相同。</li></ul></li></ul><h3 id="CREATE-…-SELECT-…"><a href="#CREATE-…-SELECT-…" class="headerlink" title="CREATE … SELECT …"></a>CREATE … SELECT …</h3><p><code>CREATE tb_name (col_name,...) SELECT ...;</code></p><p>将查询的数据写入到新建的数据表中。</p><h2 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h2><p>添加单列：<code>ALTER TABLE tb_name ADD (column_name data_type,...);</code></p><p>删除列：<code>ALTER TABLE tb_name DROP column_name;</code></p><p>添加外键：<code>ALTER TABLE tb_name ADD FOREIGN KEY (pid) REFERENCES tb2_name (id);</code></p><p>删除主键、添加&#x2F;删除默认约束、添加&#x2F;删除唯一约束、删除外键约束等</p><h2 id="操作数据表中的记录"><a href="#操作数据表中的记录" class="headerlink" title="操作数据表中的记录"></a>操作数据表中的记录</h2><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p><code>INSERT tb_name(col_name,...) VALUES(value1,...);</code>可以用NULL或DEFAULT占用递增字段。</p><p><code>INSERT tb_name SET col_name1=value1,...;</code>，这种方法可以使用子查询。</p><p><code>INSERT tb_name(col_name,...) SELECT ...</code>，将查询结果插入表中。</p><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p><code>UPDATE tb_name SET col_name=value,... [WHERE ...];</code></p><p>使用<strong>连接</strong>进行多表更新：</p><p><code>UPDATE tb_name INNER JOIN tb_name2 ON 连接条件 SET col_name=value,...</code></p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p><code>DELETE FROM tb_name [WHERE ...];</code></p><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p><code>SELECT expr,... [FROM tb_name [WHERE ...] [GROUP BY ... [ASC|DESC]] [HAVING ...] [ORDER BY ... [ASC|DESC]] [LIMIT row_count OFFSET row_count]]</code></p><p>字段表达式的顺序会影响结果的顺序</p><p>可以在字段前加上表名避免多表连接查询时字段名冲突</p><p>可以使用AS赋予别名，会影响结果的字段名，可用于GROUP BY，ORDER BY，HAVING子句。</p><h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><p>WHERE</p><h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><p>查询结果分组，查询某一个字段的所有取值。</p><h4 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h4><p>分组条件</p><h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><p>按一个或多个字段对查询结果进行排序</p><h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h4><p>限制查询结果返回的数量</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>嵌套在查询内部的SELECT子句，必须出现在圆括号内。</p><p>子查询的返回值可以是标量、行、列、子查询。</p><h4 id="比较子查询"><a href="#比较子查询" class="headerlink" title="比较子查询"></a>比较子查询</h4><p><code>SELECT * FROM tb_name WHERE col_name &gt; ANY (子查询);</code></p><p><img src="/images/MySQL1/image-20200826112320549.png" alt="image-20200826112320549"></p><h4 id="IN、NOT-IN子查询"><a href="#IN、NOT-IN子查询" class="headerlink" title="IN、NOT IN子查询"></a>IN、NOT IN子查询</h4><p><code>IN (子查询)</code>与<code>=ANY (子查询)</code>等效</p><p><code>NOT IN (子查询)</code>与<code>!=ALL (子查询)</code>、<code>&lt;&gt;ALL (子查询)</code>等效</p><h4 id="EXISTS、NOT-EXISTS子查询"><a href="#EXISTS、NOT-EXISTS子查询" class="headerlink" title="EXISTS、NOT EXISTS子查询"></a>EXISTS、NOT EXISTS子查询</h4><p>子查询语句查询到结果，EXISTS返回TRUE、否则返回FALSE</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>MySQL在SELECT语句、多表更新、多表删除中支持JOIN操作。</p><p>使用ON设定连接条件，也可以使用WHERE代替。</p><h4 id="内连接INNER-JOIN等价于JOIN、CROSS-JOIN"><a href="#内连接INNER-JOIN等价于JOIN、CROSS-JOIN" class="headerlink" title="内连接INNER JOIN等价于JOIN、CROSS JOIN"></a>内连接INNER JOIN等价于JOIN、CROSS JOIN</h4><p><code>SELECT col_name FROM tb_name INNER JOIN tb_name2 ON 连接条件;</code></p><p>显示左表（当前查询表）和右表（连接表）符合连接条件的记录（交集）。</p><p><img src="/images/MySQL1/image-20200826224618172.png" alt="image-20200826224618172"></p><h4 id="左外连接LEFT-JOIN"><a href="#左外连接LEFT-JOIN" class="headerlink" title="左外连接LEFT JOIN"></a>左外连接LEFT JOIN</h4><p>显示左表的全部记录及右表符合连接条件的记录。</p><p><img src="/images/MySQL1/image-20200826224854158.png" alt="image-20200826224854158"></p><h4 id="右外连接RIGHT-JOIN"><a href="#右外连接RIGHT-JOIN" class="headerlink" title="右外连接RIGHT JOIN"></a>右外连接RIGHT JOIN</h4><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h3><p><img src="/images/MySQL1/image-20200826232137034.png" alt="image-20200826232137034"></p><p><img src="/images/MySQL1/image-20200826232205853.png" alt="image-20200826232205853"></p><p>SUBSTRING()从1开始计数，可以用负值从末尾开始数。</p><h3 id="数值运算符与函数"><a href="#数值运算符与函数" class="headerlink" title="数值运算符与函数"></a>数值运算符与函数</h3><p><img src="/images/MySQL1/image-20200826232654739.png" alt="image-20200826232654739"></p><h3 id="比较运算符与函数"><a href="#比较运算符与函数" class="headerlink" title="比较运算符与函数"></a>比较运算符与函数</h3><p><img src="/images/MySQL1/image-20200826233006754.png" alt="image-20200826233006754"></p><h3 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h3><p><img src="/images/MySQL1/image-20200826233244090.png" alt="image-20200826233244090"></p><h3 id="信息函数"><a href="#信息函数" class="headerlink" title="信息函数"></a>信息函数</h3><p><img src="/images/MySQL1/image-20200826233613821.png" alt="image-20200826233613821"></p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><img src="/images/MySQL1/image-20200826233855766.png" alt="image-20200826233855766"></p><h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h3><p><img src="/images/MySQL1/image-20200826234102940.png" alt="image-20200826234102940"></p><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p><code>CREATE FUNCTION function_name(参数) RETURNS {STRING|INTEGER|REAL|DECIMAL} 函数体;</code></p><p>函数体由合法的SQL语句构成，可以使用声明、循环等流程控制。</p><p>只能有一个返回值。</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>SQL语句和控制语句的预编译集合，可以增强SQL语句的功能和灵活性，实现较快的执行速度，存储过程名字代替SQL语句减少网络流量。</p><p>可以返回多个值。</p><p><code>CREATE PROCEDURE sp_name([IN|OUT|INOUT]参数) 过程体;</code></p><ul><li><p>IN输入类型参数，表示该参数的值必须在调用存储过程时指定。</p></li><li><p>OUT输出类型参数，表示该参数的值可以被存储过程改变，并且可以返回。</p></li><li><p>INOUT输入&amp;输出类型参数，表示改参数在调用时指定，并且可以被改变和返回。</p></li></ul><p>过程体由合法的SQL语句构成，可以使用声明、循环等流程控制。</p><p>调用存储过程：<code>CALL sp_name();</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;{}&lt;/code&gt;表示必选项，&lt;code&gt;[]&lt;/code&gt;表示可选项&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://djsFFF.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://djsFFF.github.io/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://djsFFF.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习2：InnoDB存储引擎</title>
    <link href="http://djsFFF.github.io/2020/08/14/MySQL%E5%AD%A6%E4%B9%A02%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://djsFFF.github.io/2020/08/14/MySQL学习2：InnoDB存储引擎/</id>
    <published>2020-08-14T12:15:00.000Z</published>
    <updated>2023-05-01T01:37:16.614Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB存储引擎。</p><a id="more"></a><h1 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h1><ul><li>第一范式（1NF）：字段是单一属性，不可再分的。</li><li>第二范式（2NF）：在第一范式的基础上，所有非主键字段都完全依赖于任意一个主键或联合主键，即不能存在非主键字段对联合主键的部分依赖。</li><li>第三范式（3NF）：在第二范式的基础上，所有非主键字段都直接依赖于主键不能存在传递依赖。</li></ul><h1 id="MyISAM与InnoDB的区别"><a href="#MyISAM与InnoDB的区别" class="headerlink" title="MyISAM与InnoDB的区别"></a>MyISAM与InnoDB的区别</h1><ol><li>锁粒度：MyISAM只支持表级锁，InnoDB支持行级锁和表级锁。</li><li>事务：MyISAM不支持事务，InnoDB支持事务。</li><li>外键：MyISAM不支持外键，InnoDB支持外键。</li><li>索引：MyISAM为非聚簇索引，InnoDB为聚簇索引，叶结点中存储所有行数据。</li></ol><h1 id="一条SQL语句在MySQL中的执行过程"><a href="#一条SQL语句在MySQL中的执行过程" class="headerlink" title="一条SQL语句在MySQL中的执行过程"></a>一条SQL语句在MySQL中的执行过程</h1><ol><li>连接器：验证身份和权限。</li><li>分析器：对SQL语句进行词法分析和语法分析。</li><li>优化器：选择最优的执行方案，如索引选择。</li><li>执行器：验证执行权限，调用存储引擎接口，返回引擎的执行结果。</li></ol><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul><li>普通索引：加速查询。</li><li>唯一索引：加速查询，列值唯一。</li><li>主键索引：加速查询，列值唯一，每个表只有一个。</li><li>联合索引：多列值组合成一个索引。</li><li>全文索引：对文本内容进行分词，进行搜索。</li></ul><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><p>聚簇索引在叶结点存储了所有的行数据。根据辅助索引查找时，需要先查出主键值，然后根据得到的主键值在主键索引中查询出行数据（回表查询）。</p><p>非聚簇索引在叶结点存储的是行数据的地址。根据辅助索引查找时，可以直接得到数据的地址。</p><h2 id="自适应哈希索引（AHI）"><a href="#自适应哈希索引（AHI）" class="headerlink" title="自适应哈希索引（AHI）"></a>自适应哈希索引（AHI）</h2><p>InnoDB会自动根据访问频率和模式来为某些热点页建立哈希索引。</p><ul><li>以相同条件查询了100次。</li><li>页通过该条件访问了N次，其中N&#x3D;页中记录*1&#x2F;16。</li></ul><p>只能用于等值查询</p><h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>指构建索引的字段包含了SELECT的数据列。</p><h2 id="索引在什么情况下会失效"><a href="#索引在什么情况下会失效" class="headerlink" title="索引在什么情况下会失效"></a>索引在什么情况下会失效</h2><ol><li>多列查询没有按最左原则进行查询。</li><li>使用like查询时%在前面。</li><li>查询条件为字符串时没有使用引号。</li><li>使用or时，存在条件没有使用索引。</li><li>当MySQL认为全表扫描更快时。</li></ol><h2 id="哪些字段需要建立索引"><a href="#哪些字段需要建立索引" class="headerlink" title="哪些字段需要建立索引"></a>哪些字段需要建立索引</h2><ol><li><p>主键自动建立唯一索引。</p></li><li><p>频繁作为where条件查询的字段。</p></li><li><p>外键字段。</p></li><li><p>总是成对出现在where中的建立联合索引。</p></li></ol><h2 id="哪些字段不适合建立索引"><a href="#哪些字段不适合建立索引" class="headerlink" title="哪些字段不适合建立索引"></a>哪些字段不适合建立索引</h2><ol><li>频繁更新的字段。</li><li>where条件中用不到的字段。</li><li>表数据比较少时。</li></ol><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是逻辑上的一组数据库操作，要么全部执行，要么都不执行。</p><h2 id="四大特性——ACID"><a href="#四大特性——ACID" class="headerlink" title="四大特性——ACID"></a>四大特性——ACID</h2><ul><li><strong>原子性</strong>（Atomic）：事务是最小执行单位，不允许分割，要么全部执行，要么都不执行。</li><li><strong>一致性</strong>（Consistent）：事务使系统从一个一致的状态转换到另一个一致状态。事务开始和结束的中间状态不会被其他事务观察到。</li><li><strong>隔离性</strong>（Isolation）：并发访问数据库时，事务之间互不影响。适当破坏一致性来提高性能与并行度。</li><li><strong>持久性</strong>（Durability）：事务提交后对数据库中数据的改变是永久的，不会被回滚。</li></ul><h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><ul><li><p><strong>丢失修改</strong>：一个事务正在访问并修改某个数据，但是修改后还没提交，如果此时另一个事务也对该数据进行了修改，那么第一个事务的修改就被覆盖了，称为丢失修改。</p></li><li><p><strong>脏读</strong>：一个事务正在访问并修改某个数据，但是修改后还没提交，如果此时另一个事务也访问了该数据，那么另一个事务读到的是未提交的数据，称为脏读。</p></li><li><p><strong>不可重复读</strong>：在一个事务两次访问同一个数据之间，另一个事务对该数据进行了<strong>修改</strong>，导致第一个事务两次访问的结果不一致。</p></li><li><p><strong>幻读</strong>：在一个事务两次进行相同查询之间，另一个事务进行了<strong>插入</strong>操作，导致第一个事务两次查询到的数据行数不一致。</p></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li><strong>读未提交</strong>（READ UNCOMMITED）：事务中允许读取其他事务未提交的数据变更，可能导致<strong>脏读、不可重复读、幻读</strong>。</li><li><strong>读已提交</strong>（READ COMMITED）：事务中允许读取其他事务已提交的数据，可能导致<strong>幻读、不可重复读</strong>。</li><li><strong>可重复读</strong>（REPEATABLE READ）：事务中对同一字段的多次读取结果一样，就算期间被其他事务修改过，可能存在<strong>幻读</strong>。</li><li><strong>串行化</strong>（SERIALIZABLE）：所有事务依次逐个执行，事务之间互不干扰。</li></ul><p>InnoDB默认的隔离级别是可重复读，使用Next-Key Lock算法，也可以避免<strong>幻读</strong>。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="从粒度划分"><a href="#从粒度划分" class="headerlink" title="从粒度划分"></a>从粒度划分</h3><ul><li><p>表级锁：对当前操作的整张表加锁，资源消耗少，加锁快，不会出现死锁，但是并发度最低。</p></li><li><p>行级锁：对当前操作行加锁，并发度高。</p></li></ul><h3 id="从操作类型分"><a href="#从操作类型分" class="headerlink" title="从操作类型分"></a>从操作类型分</h3><ul><li>共享锁（S）：多个读锁可以共存。</li><li>排他锁（X）：不能和其他写锁和读锁共存。</li><li>意向共享锁（IS）：加S锁之前要先加IS锁，从粗粒度到细粒度依次加锁。</li><li>意向排他锁（IX）：加X锁之前要先加IX锁，从粗粒度到细粒度依次加锁。</li></ul><h3 id="InnoDB锁算法"><a href="#InnoDB锁算法" class="headerlink" title="InnoDB锁算法"></a>InnoDB锁算法</h3><ul><li><strong>Record Lock</strong>：锁定符合条件的行，其他事务不能修改和删除加锁行。</li><li><strong>Gap Lock</strong>：间隙锁，对第一条记录前的间隙或最后一条记录后的间隙加锁，不包括自身，其他事务不能加锁范围内插入数据。</li><li><strong>Next-key Lock</strong>：Record Lock + Gap Lock，可避免幻读。当查询的索引含有唯一属性时，自动降级为Record Lock。</li></ul><h2 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h2><p>当MySQL单表数据量过大时，数据库的CRUD性能会明显下降，一些常见优化措施如下：</p><ul><li><p>限定数据范围：禁止不带任何数据范围条件的查询语句。</p></li><li><p>读写分离：主库负责写，从库负责读。</p></li><li><p>垂直分区：按列拆成多张表。可以使列数据变小，简化表结构，但是会出现冗余，会让事务变得复杂。</p></li><li><p>水平分区：按行拆成多张表，逻辑上还是一个表，物理上拆分为多个文件，可以避免单个表数据量过大对性能造成影响，但会带来逻辑、部署、运维的各种复杂的。</p></li></ul><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>可以实现对数据库连接的复用，不用每次都进行创建销毁操作，减少了用户等待建立数据库连接的时间。</p><p>可以通过连接池最大值等属性动态控制数据库连接数量。</p><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><ul><li>RANGE分区：基于某个字段按多个连续区间进行分区。如按年月存放数据。</li><li>LIST分区：基于某个字段按给定的多个LIST进行分区，LIST中指定了分区的值。</li><li>HASH分区：基于某个字段利用自定义hash算法进行分区，如取余。</li><li>KEY分区：与HASH分区类似，但是使用MySQL数据库提供的函数进行分区。</li></ul><h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>MVCC通过版本控制在undolog中找回数据的历史版本，可以并发读与读，读与写操作，只有写与写之间会相互阻塞，提高了并发度。只在READ COMMITED和REPEATABLE READ两个隔离级别下工作。</p><h2 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h2><ul><li>DB_TRX_ID（6字节）：记录最近一次对本行数据进行修改（插入，更新，删除）的事务ID。</li><li>DB_ROLL_PTR（7字节）：回滚指针。</li><li>DB_ROW_ID（6字节）：InnoDB默认递增ID（与MVCC无关）。</li></ul><h2 id="快照（read-view）关键参数"><a href="#快照（read-view）关键参数" class="headerlink" title="快照（read view）关键参数"></a>快照（read view）关键参数</h2><ul><li>low_limit_id：当前最大事务ID+1，即下一个将分配的事务ID。</li><li>up_limit_id：trx_ids中最小的事务ID，若trx_ids为空，则等于low_limit_id</li><li>trx_ids：快照创建时其他未提交的活跃事务ID列表。</li><li>create_trx_id：当前创建事务的ID，是一个递增ID。</li></ul><h2 id="可见性比较算法"><a href="#可见性比较算法" class="headerlink" title="可见性比较算法"></a>可见性比较算法</h2><p>判断数据行中记录的事务ID是否存在于活跃事务ID之中：</p><ol><li>若数据行记录的事务ID<strong>小于</strong>活跃事务ID列表中的最小ID，则当前事务可以直接读取该行数据。</li><li>若数据行记录的事务ID大于活跃事务ID列表的最小ID且小于活跃事务ID列表的最大ID，则表示当前行记录的ID可能处于活跃状态，需要遍历活跃事务ID列表进行判断可见性。</li></ol><p>若数据行记录的事务ID大于生成快照时系统的最大事务ID，则数据行对当前事务不可见。</p><p>通过回滚指针回滚直到找到对当前事务可见的数据版本。</p><h2 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h2><ul><li>快照读：普通的SELECT语句，不会产生幻读。</li><li>当前读：SELECT…LOCK IN SHARE MODE、SELECT…FOR UPDATE、INSERT、UPDATE、DELETE等都是获取最新数据。通过next-key lock避免幻读。</li></ul><p>InnoDB在快照读的情况下并没有真正避免幻读，但是在当前读的情况下可以避免不可重复读和幻读。</p><h2 id="REPEATABLE-READ和READ-COMMETED时生成快照的区别"><a href="#REPEATABLE-READ和READ-COMMETED时生成快照的区别" class="headerlink" title="REPEATABLE READ和READ COMMETED时生成快照的区别"></a>REPEATABLE READ和READ COMMETED时生成快照的区别</h2><ol><li>RR级别下，事务只有执行第一条SELECT语句时会生成一个快照。</li><li>RC级别下，事务每次执行SELECT语句时都会重新生成快照。</li></ol><h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><p>在master结点中，可选择以下三种模式将数据变化写到binary-log文件中：</p><ul><li>statement：将数据库操作的<strong>sql语句</strong>写入binlog，实时性更好。</li><li>row：将<strong>每一条数据的变化</strong>写入binary-log，会消耗更大的磁盘空间和磁盘IO。</li><li>mixed：statement和row的混合。由MySQL决定什么时候写statement格式，什么时候写row格式。</li></ul><p><strong>master结点：</strong>当slave结点连接到master结点时，master结点会为slave结点开启binlog dump线程，当master结点的binlog发生变化时，binlog dump线程会通知slave，并将对应的binlog内容发送给slave。</p><p><strong>slave结点：</strong>当主从同步开启时，slave结点上会创建2个线程。</p><ul><li>IO线程：该线程负责接收master结点发送的binlog内容，并写入到本地的relay log。</li><li>SQL线程：该线程负责读取relay log并根据内容进行相应的操作。</li></ul><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p><a href="https://zhuanlan.zhihu.com/p/25933039" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25933039</a></p><p>分布式事务是指事务的操作位于不同的结点上，需要保证事务的ACID特性。</p><p>如下单时，库存和订单的数据库不在同一个结点。</p><h2 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h2><ol><li>协调者询问事务参与者是否执行成功，参与者发回事务执行结果。</li><li>若事务在每个参与者上都执行成功，协调者通知所有参与者提交事务，否则通知回滚事务。</li></ol><p><strong>存在的问题：</strong></p><ul><li>同步阻塞：已完成事务的参与者需要阻塞等待其他参与者完成事务。</li><li>单点问题：当协调者发送故障时，可能导致参与者一直处于等待状态。</li><li>数据不一致：在第二阶段，可能由于网络问题，只有部分参与者收到了commit通知。</li><li>任意一个结点的失败会导致整个事务的失败。</li></ul><h2 id="补偿事务（TCC：try-confirm-cancel）"><a href="#补偿事务（TCC：try-confirm-cancel）" class="headerlink" title="补偿事务（TCC：try-confirm-cancel）"></a>补偿事务（TCC：try-confirm-cancel）</h2><ol><li>try阶段对业务系统做检测及资源预留。</li><li>confirm阶段对业务系统做提交确认。</li><li>cancel阶段在业务执行错误时，取消业务，释放预留资源。</li></ol><h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><ol><li>消息生产方需要额外建立一个消息表，并记录消息发送状态。消息表和业务数据需要在一个事务里提交。</li><li>消息消费方需要处理这个消息，并完成自己的业务逻辑。如果本地事务执行成功，则回复给生产方一个confirm消息，否则将该消息放回消息队列。</li><li>消息生产方需要定时扫描本地消息表，把没有处理完成的消息继续重新发送。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;InnoDB存储引擎。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://djsFFF.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://djsFFF.github.io/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://djsFFF.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JVM学习系列二：虚拟机执行子系统</title>
    <link href="http://djsFFF.github.io/2020/08/13/JVM%E5%AD%A6%E4%B9%A02%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://djsFFF.github.io/2020/08/13/JVM学习2：虚拟机执行子系统/</id>
    <published>2020-08-13T12:15:00.000Z</published>
    <updated>2023-05-01T01:37:16.612Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了《深入了解Java虚拟机：JVM高级特性与最佳实践》中第三部分“虚拟机执行子系统”的学习笔记。</p><a id="more"></a><h1 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h1><p>Class文件是一组以8个字节为单位的二进制流，任何一个Class文件都对应着唯一的一个类或接口的定义信息。</p><p>数据类型：</p><ul><li>无符号数：可以用来描述数字、索引引用、数量值或按UTF-8编码构成字符串值；u1，u2，u4，u8分别代表1、2、4、8个字节的无符号数。</li><li>表：由多个无符号数或者其他表作为数据项构成的复合数据类型。命名以“_info”结尾。</li></ul><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200824215825527.png" alt="image-20200824215825527"></p><h2 id="魔数与版本号"><a href="#魔数与版本号" class="headerlink" title="魔数与版本号"></a>魔数与版本号</h2><ul><li><p>魔数（Magic Number）：Class文件的头四个字节，用于确定该文件是否为一个能被虚拟机接受的Class文件。</p></li><li><p>版本号：第5、6个字节是次版本号，第7、8个字节是主版本号（JDK12为57）。</p></li></ul><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>第9、10个字节表示常量池容量计数值，计数从1而不是0开始，后面紧跟一系列常量表。</p><p>常量池中主要存放两大类常量：</p><ul><li>字面量：如文本字符串、被声明为final的常量等。</li><li>符号引用：被模块导出或者开放的包、类和接口的全限定名、字段的名称和描述符、方法的名称和描述符、方法句柄和方法类型、动态调用点和动态常量。</li></ul><p>每一项常量都是一个表，共有17种常量表。</p><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814120634525.png" alt="image-20200814120634525"></p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>常量池结束之后，紧接着的2个字节代表访问标志。</p><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814115542959.png" alt="image-20200814115542959"></p><h2 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h2><p>三者按顺序排在访问标志之后，类索引和父类索引都是u2类型的数据，接口索引集合是一组u2类型数据的集合，它们各指向常量池中一个类描述符常量。</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814123027347.png" alt="image-20200814123027347"></p><p>字段表用于描述接口或者类中声明的变量，不会列出从父类或父接口中继承而来的字段。首先是一个字段表计数器，后接若干个字段表。</p><p>数组类型描述符：每一维用一个的”[“来描述。如<code>java.lang.String[][]</code>被描述为<code>[[Ljava.lang.String</code>。</p><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>字段表集合之后就是方法表集合，结构与字段表结构类似。首先是一个方法表计数器，后接若干个方法表。</p><p>方法描述符：先参数列表后返回值，如<code>int test(char[] a, int b)</code>被描述为<code>([CI)I</code>。</p><h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814125020707.png" alt="image-20200814125020707"></p><p>方法里面的代码经过Javac编译器处理后，变为字节码指令存储在Code属性内。</p><p><strong>变量槽</strong>：变量槽是虚拟机为局部变量分配内存使用的最小单位。对于byte、char、float、int、short、boolean等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long占用两个变量槽。</p><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><ul><li><p>Exception：列举方法描述时在throws关键字后面的异常。</p></li><li><p>LineNumberTable：用于描述Java源码行号与字节码行号（字节码的偏移量）之间对应的关系。</p></li><li><p>LocalVariable、LocalVariableTypeTable：LocalVariable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。LocalVariableTypeTable与LocalVariable类似，适用于泛型。</p></li><li><p>SourceFile、SourceDebugExtension：SourceFile用于记录生成这个Class文件的源码文件名称。SourceDebugExtension用于存储额外的代码调试信息。</p></li><li><p>ConstantValue：通知虚拟机自动变为静态变量赋值，只有被static关键字修饰的变量才可以使用这项属性。</p></li><li><p>InnerClasses：用于记录内部类与宿主类之间的关联。</p></li><li><p>Deprecated、Synthetic：Deprecated属性用于表示某个类、字段或方法已被程序作者定为不再推荐使用。Synthetic属性表示此字段或方法不是Java源码直接产生的，而是由编译器自行添加的。</p></li><li><p>StackMapTable：会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p></li><li><p>Signature：记录泛型前面信息。</p></li><li><p>BootstrapMethods：用于保存invokeddynamic指令引用的引导方法限定符。</p></li><li><p>MethodParameters：记录方法的各个形参名称和信息。</p></li><li><p>模块化相关属性：Module、ModulePackage、ModuleMainClass</p></li><li><p>运行时注解相关属性：RuntimeVisibleAnnotations、RuntimeInvisibleAnnotations、RuntimeVisibleAnnotations、RuntimeInvisibleParameterAnnotations、RuntimeVisibleParameterAnnotations、RuntimeInvisibleParameterAnnotations</p></li></ul><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程称为虚拟机的类加载机制。</p><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814140338240.png" alt="image-20200814140338240"></p><p>一个类型从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期如图所示。</p><p>解析可能在初始化之后再开始，这是为了支持Java的动态绑定。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>有且只有六种情况需要立即对类进行到“初始化”阶段：</p><ul><li>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时。</li><li>使用java.lang.reflect包的方法对类型进行反射调用时。</li><li>初始化类时发现其父类还没有初始化，则先触发其父类的初始化。</li><li>虚拟机启动时，初始化包含main()方法的主类。</li><li>使用JDK 7加入的动态语言支持时，需要初始化相应的类。</li><li>当一个接口中定义了JDK 8加入的default方法时，如果该接口的实现类发生了初始化，那么该接口要在其之前初始化。</li></ul><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>加载、验证、准备、解析、初始化。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>非数组类型的加载阶段是开发人员可控性最强的阶段，可以使用虚拟机内置的引导类加载器也可以由用户自定义的类加载器完成。</p><p>虚拟机在加载阶段需要完成以下三件事情：</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>加载阶段与连接阶段的部分动作是交叉进行的，如一部分字节码文件格式验证动作。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保Class文件的字节流包含的信息符合虚拟机要求，保证这些信息运行后不会危害虚拟机自身的安全。</p><p>包括四个阶段的验证动作：</p><ol><li>文件格式验证：验证字节流是否符合Class文件规范，能否被当前版本的虚拟机处理。</li><li>元数据验证：对字节码描述的信息进行语义分析，保证其描述的信息符合《Java语言规范》的要求。</li><li>字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：检查是否能够正常引用它依赖的某些外部类、方法、字段等，确保解析行为能正常执行。</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类中定义的静态变量分配内存并初始化为默认值，仅包括类变量，不包括实例变量。</p><p>实例变量会在对象实例化时随对象一起分配在Java堆中。</p><p>如果存在类字段被static final修饰，虚拟机会直接初始化为ConstantValue。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池内的符号引用解析为直接引用。</p><p>解析主要针对7类符号引用：类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</p><p>符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量。</p><p>直接引用：可以直接指向目标的指针、相对偏移量或者是能直接定位到目标的句柄。</p><p>类或接口的解析：根据类或接口的全限定名加载对应类或接口，然后验证访问权限。</p><p>字段解析：首先解析出字段所属的类或接口C，若C中包含匹配的字段则返回该字段的直接引用，否则依次搜索C实现的<strong>各个接口和父类</strong>，最后验证访问权限。</p><p>方法解析：首先解析出方法所属的类或接口C，若C中包含匹配的方法则返回该方法的直接引用，否则依次搜索C实现的<strong>父类和各个接口</strong>，最后验证访问权限。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行类构造器&lt;clinit&gt;()方法，&lt;clinit&gt;()方法是由编译器自动收集类中的<strong>类变量赋值语句和静态语句块</strong>合并产生的。</p><p>同一个类加载器下，一个类型只会被初始化一次。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器实现了<strong>加载</strong>过程中的“通过一个类的全限定名来获取定义此类的二进制字节流”这一动作。</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，必须由加载它的类加载器和类本身（全限定名）共同确立在虚拟机中的唯一性。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><h4 id="JDK-9之前"><a href="#JDK-9之前" class="headerlink" title="JDK 9之前"></a>JDK 9之前</h4><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814171646877.png" alt="image-20200814171646877"></p><p>JDK 9之前的Java应用都是由启动类加载器、扩展类加载器、应用程序类加载器互相配合完成加载的，用户可以加入自定义的类加载器进行拓展。</p><p>双亲委派模型要求除了启动类加载器外，其余的类加载器都应有自己的父类加载器。父子关系不是以继承的关系实现的，而是使用组合关系来复用父类加载器的代码。</p><p>工作过程：当一个类加载器收到类加载的请求时，首先查看是否已加载过该类，若没有，则把这个请求委派给父加载器去完成，直到启动类加载器，若父加载器都没有加载过该类，当前类加载器才会尝试自己完成加载。</p><p>优点：保证稳定性，避免用户自己编写的类替换掉Java的一些核心类，同时也可以避免重复加载。</p><h4 id="JDK-9及之后"><a href="#JDK-9及之后" class="headerlink" title="JDK 9及之后"></a>JDK 9及之后</h4><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814173453876.png" alt="image-20200814173453876"></p><p>JDK 9中把Extension Class Loader替换为了Platform Class Loader。父类都发生了变化。</p><p>双亲委派模型：类加载请求会优先委派给负责待加载类所属模块的类加载器。</p><h1 id="字节码执行引擎"><a href="#字节码执行引擎" class="headerlink" title="字节码执行引擎"></a>字节码执行引擎</h1><p>以方法为基本单位执行Class文件中包含的字节码指令。</p><p>执行引擎执行Java代码时可以选择解释执行（通过解释器执行）或者编译执行（通过即时编译器产生本地代码执行）。</p><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>虚拟机以方法作为最基本的执行单元，栈帧则是用于支持虚拟机进行方法调用和方法执行的数据结构。</p><p>栈帧存储了局部变量表、操作数栈、动态连接、方法返回地址等信息，一个栈帧需要分配多少内存在编译Java源码时就已经被分析计算出来了。</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表以变量槽为最小单位存储方法参数、方法内部定义的局部变量。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>栈内每一个元素可以是任意Java数据类型，32位数据类型占用栈容量为1，64位数据类型占用栈容量为2。</p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>为了支持方法调用过程中的动态连接，每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法退出之后，必须返回到最初方法被调用的位置，程序才能继续执行。</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），不涉及方法内部运行过程。</p><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>静态方法、私有方法、实例构造器、父类方法和被final修饰的方法这5种方法调用会在类加载的就把符号引用解析为该方法的直接引用，是一个静态的过程。</p><h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>静态分派：依赖静态类型来决定方法执行版本的分派动作称为静态分派，典型应用代表就是<strong>方法重载</strong>。静态分派发生在编译阶段，而不是虚拟机执行的。</p><p>动态分派：典型应用代表就是<strong>方法重写</strong>。</p><h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p><img src="/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814182707365.png" alt="image-20200814182707365"></p><p>Javac编译器完成了程序源码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。而解释器则是在虚拟机内部实现的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了《深入了解Java虚拟机：JVM高级特性与最佳实践》中第三部分“虚拟机执行子系统”的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://djsFFF.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://djsFFF.github.io/tags/JVM/"/>
    
      <category term="JAVA" scheme="http://djsFFF.github.io/tags/JAVA/"/>
    
  </entry>
  
</feed>
