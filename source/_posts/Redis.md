---
title: Redis
date: 2020-08-30 20:15:00
tags: 
	- Redis
	- 数据库
categories:
	- 数据库
typora-root-url: ..
---

Redis相关知识点。

Redis是一个开源的高性能键值对的内存数据库，可以用作数据库、缓存、消息中间件等，是一种NoSQL数据库（Not-only SQL，非关系型数据库）。

<!--more-->

# Redis为什么快

1. 基于内存操作。
2. 单线程模型，避免了上下文切换。
3. 多路复用IO模型，非阻塞IO。

# Redis优点

1. 基于内存操作，读写速度快。
2. 数据类型丰富，string，hash，list，set，sorted set等。
3. 支持事务，操作都是原子性的。
4. 支持发布订阅，设置过期时间等。

# 数据类型

- String：值可以是string，也可以是数字、二进制数据等，最大存储512m。
- Hash：存储键值对，适合存储Java对象。
- List：双向链表，按插入顺序排序。
- Set：String类型的无序去重集合，通过Hashtable实现。
- Zset（Sorted Set）：在Set的基础上增加了一个score，使得集合中的元素可以按score有序排列。

# 过期策略

定期删除+惰性删除。

- 定期删除：每100ms随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。
- 惰性删除：尝试访问一个已过期但还没被删除的key时，redis会把该数据删除掉。

# 内存淘汰策略

- volatile-lru：从已设置过期时间的数据中挑选**最近最少使用**的数据淘汰。
- volatile-lfu：从已设置过期时间的数据中挑选**使用频率最低**的数据淘汰。
- volatile-ttl：从已设置过期时间的数据中挑选**将要过期**的数据淘汰。
- volatile-random：从已设置过期时间的数据中**随机选择**数据淘汰。
- allkeys-lru：从所有数据中选择**最近最少使用**的数据淘汰。
- allkeys-lfu：当所有数据中选择**使用频率最低**的数据淘汰。
- allkeys-random：从所有数据中**随机选择**数据淘汰。
- no-eviction：**不淘汰数据**，内存不足以容纳新写入数据时报错。

# 持久化机制

## 快照持久化RDB

在某个时间点创建内存数据的快照，保存在原地或者其他服务器结点上。

每次进行快照持久化时，开启一个子进程进行全量备份，备份期间的数据变化不会被保存，可能丢失数据。

适合于定时文件备份和灾难恢复，恢复大数据集时比AOF快。

- save 900 1：在15分钟后，至少1个key发生变化，创建快照。
- save 300 10：在5分钟后，至少10个key发生变化，创建快照。
- save 60 10000：在1分钟后，至少10000个key发生变化，创建快照。

## 只追加文件AOF

每执行一条写命令时，Redis将该命令写入硬盘中的AOF文件。

恢复速度比RDB慢，通常比快照文件大。

丢失数据较少，比如设置每秒钟记录一次时，最多丢失一秒钟的数据。备份速度比较快。

- appendfsync always：每次有数据修改时都会写入AOF文件，会严重降低Redis的速度。
- appendfsync everysec：每秒钟同步一次。
- appendfsync no：让操作系统决定何时进行同步。

# 缓存问题

## 缓存和数据库一致性问题

使用缓存只能通过合适的策略来降低缓存和数据库之间不一致的概率，无法保证两者间的强一致性。

https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md

## 缓存击穿

指对于会被高并发访问的若干个热点数据，在这个数据失效的瞬间，这些高并发访问直接落到了数据库上。

解决方法：

- 设置热点数据用不过期，需要时再进行更新。
- 对热点数据加互斥锁，同时只能有一个线程访问数据库的数据，一个线程访问后重建缓存。

## 缓存雪崩

指某个时间点缓存数据大规模失效，此时请求就会直接到达数据库，造成数据库短时间内承受大量请求而崩掉。

解决方法：

- 设置热点数据用不过期，需要时再进行更新。

- 对数据的过期时间额外加上一个随机值，避免同时失效。
- 构建多级缓存。
- 对于集群Redis，可以将热点数据均匀分布在不同的Redis库中。

## 缓存穿透

指大量请求的key根本不存在于缓存中，导致请求直接到达数据库。

解决方法：

- 在接口层过滤掉不合法的查询，如负数id。

- 布隆过滤器：把所有有效请求的值都存放在布隆过滤器中，通过布隆过滤器判断请求是否有效。

  ![image-20200904164234280](/images/Redis/image-20200904164234280.png)

  布隆过滤器由一个二进制数组和一系列Hash函数组成，当一个元素加入过滤器时，通过K个Hash函数将这个元素映射为K个下标，然后把二进制中对应位置置为1。

- 缓存无效key：查询数据库中也没用的数据时，返回一个key-null缓存到Redis中，并设置一个较短过期时间。

# 主从复制

通常Redis主节点负责写操作，若干个从节点负责读操作。

全量复制：

1. 主节点发送RDB文件给从节点。RDB文件传输期间，新的写命令放入缓冲区。
2. 从节点清理自己的数据库数据，接受RDB文件并保存在数据库中。
3. 通过部分复制将缓冲区的数据发送给从节点。

部分复制：

在从节点复制主节点时，如果发生异常情况，主节点会将期间产生的新的写命令存入缓冲区等待恢复连接后进行部分复制。但如果恢复连接时缓冲区已经溢出，则进行全量复制。

# 哨兵模式

哨兵模式是Redis集群的高可用性的解决方案：由一个或多个哨兵实例组成的哨兵系统可以监视主服务器及其所有从服务器，并在监视到主服务器进入下线状态时，自动地将某个从服务器升级为新的主服务器。

哨兵会定期获取服务器的状态信息。