---
title: Redis
date: 2020-08-30 20:15:00
tags: 
	- Redis
	- 数据库
categories:
	- 数据库
typora-root-url: ..
---

Redis相关知识点。

Redis是一个开源的高性能键值对的内存数据库，可以用作数据库、缓存、消息中间件等，是一种NoSQL数据库（Not-only SQL，非关系型数据库）。

<!--more-->

# Redis为什么快

1. 基于内存操作。
2. 单线程模型，避免了上下文切换。
3. 多路复用IO模型，非阻塞IO。

# Redis优点

1. 基于内存操作，读写速度快。
2. 数据类型丰富，string，hash，list，set，sorted set等。
3. 支持事务，操作都是原子性的。
4. 支持发布订阅，设置过期时间等。

# 底层数据结构

## 简单动态字符串SDS

用途：键，string类型，缓冲区（AOF缓冲区，客户端状态的输入缓冲区等）。

SDS结构如图所示

![image-20200921213725636](/images/Redis/image-20200921213725636.png)

- free：记录该SDS的空闲空间。
- len：记录该SDS的已用空间。
- buf：char数组，用于保存字符串。

## 双端链表linkedlist

用途：list类型等。

## 字典hashtable

用途：hash类型等。

## 跳跃表skiplist

用途：zset类型，集群节点等。

每个节点会根据幂次定律（越大的数出现的概率越小）随机生成多个层，每个层中保存了下一个**同级层**的指针及其跨度。

## 整数集合intset

用途：set类型等。

可以保存的类型为int16_t、int32_t、int64_t的整数值，通过自动升级策略节约内存，提高灵活性。

当一个set只包含整数值元素，且元素数量不多时（512），**Redis采用intset作为set的底层实现**。

## 压缩列表ziplist

用途：list类型，hash类型等。

当一个**list键**只包含少量元素（512），且元素长度都小于64字节时，Redis采用ziplist作为底层实现。

当一个**hash键**只包含少量键值对（512），且键值都小于64字节时，Redis采用ziplist作为底层实现。

当一个**zset键**只包含少量元素（512），且元素长度都小于64字节时，Redis采用ziplist作为底层实现。

压缩列表的节点包括三个属性：

- previous_entry_length：以字节为单位，记录了前一个节点的长度。
- encoding：记录了content保存的数据的类型和长度。
- content：保存节点的值，是一个char数组或整数。

节约内存，从尾向头遍历。

# 数据类型

## String

值可以是string，也可以是数字、二进制数据等。底层数据结构可以是**int，raw(SDS)或embstr**。

![image-20220112153608910](/images/Redis/image-20220112153608910.png)

## Hash

使用ziplist时，先将key推入表尾，再将value推入表尾。

编码转换

![image-20220112164857610](/images/Redis/image-20220112164857610.png)

![image-20220112155327565](/images/Redis/image-20220112155327565.png)

## List

编码转换

![image-20220112164809306](/images/Redis/image-20220112164809306.png)

![image-20220112155241467](/images/Redis/image-20220112155241467.png)

## Set

编码转换

![image-20220112164950571](/images/Redis/image-20220112164950571.png)

![image-20220112155402241](/images/Redis/image-20220112155402241.png)

## Zset（Sorted Set）

使用ziplist时，元素和分数存放在相邻节点。

编码转换

![image-20220112165205470](/images/Redis/image-20220112165205470.png)

当底层结构为skiplist时，zset中有一个字典用于保存key到score的映射，且key和score是共享跳跃表中的数据，因此不需要额外的内存空间。

![image-20220112172951475](/images/Redis/image-20220112172951475.png)

# 内存回收与对象共享

基于引用计数实现内存回收。

Redis在初始化服务器时，会创建0-9999的字符串共享对象。

# 设置过期时间

```sql
EXPIRE <key> <ttl> 设置key的生存时间为ttl秒
PEXPIRE <key> <ttl> 设置key的生存时间为ttl毫秒
EXPIREAT <key> <timestamp> 设置key的过期时间为秒时间戳timestamp
PEXPIREAT <key> <timestamp> 设置key的过期时间为毫秒时间戳timestamp
```

过期时间保存在redisDb结构的expires字典中，key指向键对象的内存地址，value为long long过期时间

# 过期键删除策略

定期删除+惰性删除。

- 定时删除：设置过期时间的同时创建一个定时器，在键到达过期时间时立即删除。

- 定期删除：定时随机抽取一些（或全部）设置了过期时间的key，检查其是否过期，如果过期就删除。
- 惰性删除：尝试访问一个已过期但还没被删除的key时，redis会把该数据删除掉。

### 主从复制下的过期键

- 主服务器在删除一个过期键之后，会向所有从服务器发送一个DEL命令。
- 从服务器**只有在接到主服务器发来的DEL命令时才会删除过期键**。在执行客户端发送的请求时，不会考虑键是否已经过期。保证主从数据一致性。

### 持久化时过期键处理

- 生成RDB文件时不会保存已过期的键。
- 只有在过期键被惰性或者定期删除时，程序会向AOF文件append一条DEL命令。
- AOF重写时，过期键不会保存到重写后的AOF文件中。

# 内存淘汰策略

- volatile-lru：从已设置过期时间的数据中挑选**最近最少使用**的数据淘汰。
- volatile-lfu：从已设置过期时间的数据中挑选**使用频率最低**的数据淘汰。
- volatile-ttl：从已设置过期时间的数据中挑选**将要过期**的数据淘汰。
- volatile-random：从已设置过期时间的数据中**随机选择**数据淘汰。
- allkeys-lru：从所有数据中选择**最近最少使用**的数据淘汰。
- allkeys-lfu：当所有数据中选择**使用频率最低**的数据淘汰。
- allkeys-random：从所有数据中**随机选择**数据淘汰。
- no-eviction：**不淘汰数据**，内存不足以容纳新写入数据时报错。

# 持久化机制

若服务器在启动时优先检测是否开启AOF持久化（AOF更新频率更高），若没有则检测RDB文件并自动载入RDB文件。

## 快照持久化RDB

适合于定时文件备份和灾难恢复，恢复大数据集时比AOF快。但由于是全量备份，因此备份需要花费较多的时间，且不会记录备份期间的数据变化。

### SAVE和BGSAVE

- SAVE：save会阻塞Redis服务器进程，直到RDB文件创建完毕，期间无法执行其他命令。

- BGSAVE：bgsave会派生出一个子进程（fork()方法），然后由子进程负责创建RDB文件。在bgsave执行期间，会拒绝其他的save和bgsave命令。

  Redis服务器启动时，可以通过指定配置文件或者传入启动参数的方式设置save选项。默认save选项如下：

  - save 900 1：在900秒内，至少1个key发生变化，执行BGSAVE。
  - save 300 10：在300秒内，至少10个key发生变化，执行BGSAVE。
  - save 60 10000：在1分钟内，至少10000个key发生变化，执行BGSAVE。
  
  每100ms检查是否满足保存条件，满足时其中一个条件时执行**BGSAVE**命令。

### RDB过期键处理

- 生成RDB文件时，只保存未过期键。
- 主服务器载入RDB文件时，只读取未过期键；从服务器则会读取所有键。

## 只追加文件AOF

恢复速度比RDB慢，通常比快照文件大。但是备份的实时性较好。

### 备份步骤

1. **命令追加：**服务器执行一个写命令，并将该命令追加到服务器状态的**aof_buf**缓冲区。

2. **文件写入和同步：**在事件循环结束之前会根据以下配置决定AOF文件同步方式。
- appendfsync always：将缓冲区所有内容写入并**立即同步**AOF文件。效率最慢，但是最安全。
  
- appendfsync everysec：将缓冲区所有内容写入AOF文件，**每秒钟同步**一次。默认选项。
  
- appendfsync no：将缓冲区所有内容写入AOF文件，让**操作系统决定何时进行同步**。效率最快，但是出现故障停机时，操作系统没有来得及写入到文件的缓冲区部分会丢失。

说明：在操作系统中，当用户调用write()函数时，操作系统通常会将写入数据暂时**保存在一个内存缓冲区aof_buf**中，可以通过fsync和fdatasync两个**同步函数**强制让操作系统立即将缓冲区中的数据写入到硬盘，保证安全性。

### AOF载入

由于Redis命令只能在客户端上下文中执行，因此在载入AOF文件时，会创建一个不带网络连接的**伪客户端**来执行逐行读取AOF文件中的命令并执行。

### AOF重写

AOF文件会随着时间越来越大，因此需要对AOF文件进行重写来减少一些冗余的命令。首先从数据库中读取键现在的值（不需要对AOF文件进行任何读取、分析或者写入操作），然后**用一条命令去记录键值对**，代替之前记录这个键值对的多条命令。实际在处理list、hash、set、zset类型时，若带有较多元素（默认64）时，会使用多条命令来记录。

AOF重写是在**带有主进程数据副本的子进程**中执行的（防止锁冲突），Redis服务器会将AOF重写期间执行的命令同时发送到**AOF缓冲区和AOF重写缓冲**区。当子进程完成重写任务后，父进程会将AOF重写缓冲区里的所有内容写入新AOF文件中，然后原子地覆盖原本的AOF文件，在此期间父进程会被阻塞。

### AOF过期键处理

当过期键被惰性删除或者定期删除时，Redis会向AOF文件中追加一条DEL命令来显式地记录该键已被删除。

# 客户端

​	服务器使用redisClient结构保存客户端属性。

## 客户端通用属性

- 套接字描述符fd：当前客户端正在使用的套接字描述符，伪客户端为-1（AOF文件或者Lua脚本）。
- 名字name：客户端名字，默认为空，可以设置。
- 标志flag：可以是多个标志组成的二进制或，包括客户端角色和状态。
- 输入缓冲区querybuf：保存客户端发送的命令请求。超过1GB时服务器会关闭该客户端。
- 命令及参数argv：是一个数组，argv[0]是要执行的命令，其它项是命令参数（key，value等）。
- argc：记录argv的长度。
- 命令的实现函数cmd：
- 输出缓冲区：默认是一个固定16KB的字节数组，bufpos属性记录buf已使用的字节数。当buf数组的空间用完时，改为使用reply链表保存一个或多个返回的字符串对象。
- 身份验证authenticated：当该属性为0时，出了AUTH命令验证身份外，其他命令都会被拒绝执行。
- 时间相关属性：
  - ctime：创建客户端的时间。
  - lastinteraction：客户端与服务端上一次互动的时间（客户端发送或者服务端回复）。
  - obuf_soft_limit_reached_time：输出缓冲区第一次到达soft limit的时间。

## 客户端的创建与关闭

### 创建普通客户端

普通客户端通过网络连接到服务器时，服务器会创建相应的redisClient结构并添加到clients链表末尾。

### 关闭普通客户端

关闭的原因：

- 客户端进程或被杀死时，网络连接关闭造成客户端关闭。
- 客户端发送了带有不符合协议格式的命令请求。
- 客户端成为了CLIENT KILL命令的目标。
- 若用户为服务器设置了timeout配置，客户端空转时间超时会被关闭。但如果客户端是主服务器、从服务器、正在被BLPOP等命令阻塞或者正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令时，客户端不受timeout时间限制。
- 客户端发送的请求超过了输入缓冲区大小（默认1GB）。
- 服务端发送的回复超过了输出缓冲区大小时：
  - 硬性限制（hard limit）：输出缓冲区超过了hard limit设置的大小时，立即关闭客户端。
  - 软性限制（soft limit）：输出缓冲区超过了soft limit设置的大小，但没超过hard limit时，记录超出时间，持续时间超过设定阈值时，关闭客户端。

### Lua脚本的伪客户端

服务器初始化时，会创建执行Lua脚本的伪客户端，并创建redisClient结构添加到lua_client链表末尾。

### AOF文件的伪客户端

服务器载入AOF文件时，会创建执行AOF文件的伪客户端，并在载入完成后关闭。

# 主从复制

Redis的主从复制分为同步和命令传播两个操作：

- **同步：**更新从服务器的数据库状态与主服务器一致
- **命令传播：**主服务器的数据库状态变化时，需要将这些命令同步给从服务器。

当从服务器初次对主服务器进行复制时，主服务器会将自己的**运行ID**传送给从服务器保存，以便从服务器断线重连后进行主服务器确认。

## 完整重同步

![image-20200924000325035](/images/Redis/image-20200924000325035.png)

当客户端向从服务器发送SLAVEOF命令时，从服务器需要执行同步操作。

1. 从服务器向主服务器发送`PSYNC ? -1`（2.8之前为SYNC）命令。
2. 主服务器收到PSYNC后执行BGSAVE生成一个RDB文件，并将期间执行的所有写命令记录在一个缓冲区中。
3. 主服务器将生成好的RDB文件发送给从服务器，从服务器接收并载入RDB文件。
4. 主服务器将缓冲区中的写命令发送给从服务器，从服务器执行这些写命令。

## 部分重同步

![image-20200924001048756](/images/Redis/image-20200924001048756.png)

部分重同步用于处理从服务器断线后重复制的情况。

- **复制偏移量**：主服务器向从服务器发送N个字节的数据时，将自己的复制偏移量加N。从服务器收到主服务器发送的N个字节的数据时，将自己的复制偏移量加N。
- **复制积压缓冲区**：是主服务器维护的一个固定长度先进先出队列，默认为1MB。主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会写入到复制积压缓冲区中。

当从服务器断线重连时，会向服务器发送`PSYNC 主服务器ID 从服务器复制偏移量`，若从服务器与主服务器的复制偏移量之差小于复制积压缓冲区的大小，则主服务器执行部分重同步，只发送断线期间缺失的数据。否则主服务器执行完整重同步。

## 命令传播

完成同步后，主从服务器就会进入命令传播阶段，当客户端向主服务器发送新的写命令时，主服务器会将这些写命令发送给从服务器执行。

### 心跳检测

在命令传播阶段，从服务器默认以每秒一次的频率向主服务器发送命令`REPLCONF ACK 复制偏移量`。其作用为：

- 检测主从服务器的网络连接状态。
- 辅助实现min-salves选项，如可以设置在检测到从服务器数量少于3个，或者3个从服务器的延迟都大于等于10s时，可能处于不安全状态，主服务器拒绝执行写命令。
- 检测命令丢失。

# 哨兵(Sentinel)模式

哨兵模式是Redis集群的**高可用性**的解决方案：由一个或多个哨兵实例组成的哨兵系统可以监视主服务器及其所有从服务器，并在监视到主服务器进入下线状态时，自动地将某个从服务器升级为新的主服务器。

## 启动并初始化Sentinel

Sentinel本质上是一个运行在特殊模式下的Redis服务器。

1. 初始化服务器。
2. 将普通Redis服务器代码替换为Sentinel专用代码。
3. 初始化Sentinel状态：根据配置文件初始化监听的主服务器列表。
4. 创建与主服务器的网络连接：成为主服务器的客户端，包括**一个命令连接和一个订阅连接**：
   - 命令连接：用于向主服务器发送命令并接收回复。
   - 订阅连接：用于订阅主服务器的\_\_sentinel\_\_:hello频道，防止丢失信息。

## 获取服务器信息

Sentinel默认每10秒向被监听服务器发送**INFO命令**来获取服务器状态，通过分析INFO命令回复，Sentinel可以获取到被监听服务器信息（服务器ID，角色，IP地址，复制偏移量等），然后Sentinel根据信息服务器的实例结构。

如果主服务器返回的信息中存在**新的从服务器**，则会创建与新从服务器的**命令连接和订阅连接**。

- 命令连接：用于向服务器发送命令以及接收命令回复。
- 订阅连接：用于订阅服务器的\_\_sentinel\_\_:hello频道，用于避免丢失命令，也用于多个订阅了统一服务器的sentinel信息同步。

## 向服务器发送频道信息

Sentinel默认每2秒向被监听服务器发送命令`PUBLISH __sentinel__: hello sentinel信息 主服务器或从服务器正在复制的主服务器的信息`。

## 接收来自服务器频道信息

当Sentinel与一个服务器建立订阅连接后，会向服务器发送命令`SUBSCRIBE __sentinel__:hello`，对于监视同一个服务器的多个Sentinel，**一个Sentinel发送的信息也会被其他Sentinel接收到**，并被用于更新对应主服务器的实例结构。

当一个Sentinel接收到其他Sentinel的消息时，会从中提取出源Sentinel和主服务器的相关参数并进行更新。

若源Sentinel是一个**新的Sentinel**，则会创建与新Sentinel的**命令连接**，而新Sentinel也会创建一个连向当前Sentinel的**命令连接**。

## 检查主观下线状态

Sentinel默认会每秒向其他创建了命令连接的服务器，Sentinel发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。

若实例在**down-after-milliseconds**（Sentinel的配置文件中）毫秒内连续返回无效回复，当前Sentinel则判定此实例已主观下线。

- 有效回复：+PONG、-LOADING、-MASTERDOWN。
- 无效回复：除有效回复之外的回复或在指定时间内没有回复。

## 检查客观下线状态

当Sentinel发送命令`SENTINEL is-master-down-by-addr <ip> <port> <current_epoch> <runid>`从其他Sentinel询问到足够数量（quorum）的主观下线判定后，会将该服务器判定为客观下线。

## 选举领头Sentinel

当一个主服务器被判定为客观下线时，监视该主服务器的所有Sentinel会协商选举一个领头Sentinel，然后由领头Sentinel对下线主服务器进行故障转移操作。

每个发现主服务器进入客观下线的Sentinel都会向其他Sentinel发送命令要求对方将自己设置为局部领头Sentinel，在一个配置纪元中，每个Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，而每个Sentinel会设置命令最早到达的Sentinel为局部领头Sentinel。

若某个Sentinel被半数以上的Sentinel设置为局部领头Sentinel，那么这个Sentinel成为领头Sentinel。若在给定时限内没有产生Sentinel，那么会在一段时间后再次进行选举，直到选出领头Sentinel为止。

## 故障转移

领头Sentinel对已下线的主服务器执行故障转移操作包括三个步骤：

1. 在已下线主服务器的从服务器中挑选一个**状态良好、数据完整**的从服务器作为新的主服务器。

   1. 排除处于下线或断线的从服务器。

   2. 排除最近5秒没有回复过领头Sentinel的INFO命令的从服务器。

   3. 排除与旧主服务器连接断开超过down-after-milliseconds * 10毫米的从服务器。

   4. 选择优先级最高的服务器。

   5. 选择复制偏移量最大的服务器。
   6. 选择运行ID最小的服务器。

2. 让其他从服务器复制新主服务器。

3. 将旧主服务器设置为新主服务器的从服务器。

# 集群

## CLUSTER MEET命令

刚开始时，每个节点都是相互独立的，向一个节点发送CLUSTER MEET命令，可以让当前节点和目标节点进行握手，握手成功时，将ip和port指定的节点加入到当前节点所在的集群中，握手过程：



![image-20200924232022113](/images/Redis/image-20200924232022113.png)

## 槽指派

**集群的整个数据库被分为16384（2^14）个槽（slot）**，数据库中的每个键都属于其中某一个slot，每个节点负责处理若干个slot，当所有slot都有节点负责处理时，集群处于上线状态，否则处于下线状态（fail）。

- 节点结构中的clusterNode.slots是一个16384位的二进制数组，记录了节点负责处理哪些slot。
- 集群状态结构中的clusterState.slots是一个clusterNode节点数组，记录了集群中16384个slot分别分配给了哪个节点。

## 集群命令执行过程

当客户端向节点发送与某个键相关的命令时，节点得到键所属的slot，若该slot指派给了当前节点，则直接执行该命令，否则会向客户端返回一个`MOVED <slot> <ip>:<port>`错误，指引客户端redirect到正确的节点，并再次发送命令。

![image-20200924233646774](/images/Redis/image-20200924233646774.png)

### 键所属slot的计算与存储

键所属的slot根据`CRC16(key) & (16384 - 1)`进行计算，其中CRC16(key)用于计算键的CRC-16校验和。

除了将键值对保存在数据库之外，节点会用clusterState.slots_to_keys来保存slot和键之间的关系，**跳跃表**的**score为slot号，member为键**。

## 重新分片

将任意数量已经指派的slot重新指派给另一个节点，并且slot相关的键值对数据也会移动过去。

重新分片是由Redis集群管理软件redis-trib负责执行的，对单个slot重新分片的步骤如下：

![image-20200925000826229](/images/Redis/image-20200925000826229.png)

1. redis-trib向目标节点发送命令`CLUSTER SETSLOT <slot> IMPORTING <source_id>`，让目标节点准备接受slot相关的键值对。
2. redis-trib向源节点发送命令`CLUSTER SETSLOT <slot> MIGRATING <target_id>`，让源节点准备将slot相关的键值对迁移到目标节点。
3. redis-trib向源节点发送命令`CLUSTER GETKEYSINSLOT <slot> <count>`，获得最多count个属于slot的键名。
4. 对于步骤3获得的每个键名，redis-trib都向源节点发送命令`MIGRATE <target_ip> <target_port> <key_name> 0 <timeout>`，原子性地迁移键的数据。
5. 重复执行步骤3、4直到所有属于slot的键值对都迁移完毕。
6. redis-trib向集群中的任意一个节点发送命令`CLUSTER SETSLOT <slot> NODE <target_id>`，最终所有节点都会知道slot已经被指派给了目标节点。

如果在重新分片期间，客户端需要访问一个属于正在迁移的slot的键，那么源节点首先在自己的数据库中进行查找，若没有找到，则返回一个`ASK <slot> <ip>:<port>`，指引客户端redirect到目标节点执行命令。

## 复制与故障转移

Redis集群的节点分为主节点和从节点，其中主节点用于处理slot，从节点用于复制某个主节点，并在复制的主节点下线时，代替下线主节点继续处理命令请求。

### 设置从节点

命令`CLUSTER REPLICATE <node_id>`可以让当前节点称为node_id的从节点，并开始对主节点进行复制（相当于执行SLAVEOF命令）。

### 故障检测

集群中的每个节点会定期向其他节点发送**PING消息**，若某个节点没有在规定时间内返回PONG消息，则标记该节点为疑似下线（PFAIL），节点之间会通过相互发送消息的方式获取其他节点的状态信息，当半数以上负责处理slot的主节点都将某个主节点标记为疑似下线时，那么该节点将被标记为已下线（FAIL），并立即通知其他节点。

### 故障转移

当一个从节点发现自己复制的主节点已下线时，开始对主节点进行故障转移：

1. 选举一个从节点执行命令`SLAVEOF on one`，成为新的主节点。**选举方式**（与领头Sentinel选举基本一致）：

   每个发现主节点已下线的从节点都会向集群广播一条命令，**第一次**收到该命令且**正在负责处理slot的主节点**会返回一条投票消息，若某个从节点收到的返回消息数量大于**正在负责处理slot的主节点数量**的一半时，该节点成为新主节点。

   若在一个配置纪元里没有成功选举出一个新主节点，那么集群进入一个新的配置纪元再次进行选举。

2. 新主节点撤销已下线主节点的所有slot指派，并将这些slot指派给自己。

3. 新主节点向集群广播一条PONG消息，通知其他节点自己是新主节点。

4. 新主节点开始接收和负责处理slot相关请求，故障转移完成。

# 发布与订阅

## 订阅与退订

Redis将所有频道的订阅关系保存在服务器状态的**pubsub_channels字典**中，键是频道，值是订阅该频道的客户端链表。

### SUBSCRIBE

当客户端执行SUBSCRIBE命令订阅某个频道时，若该频道已存在，则将客户端加入到对应链表尾部，否则在字典中添加一个新频道，并将客户端加入到对应链表。

### UNSUBSCRIBE

当客户端执行UNSUBSCRIBE命令退订某个频道时，服务器会从对应链表中删除该客户端节点，若删除后为空链表，则将频道对应的键也从字典中删除。

## 模式订阅与退订

模式订阅可以通过模式匹配来定义满足该模式的所有频道，如`PSUBSCRIBE "news.*"`。

模式的订阅关系都被保存在服务器状态的**pubsub_patterns链表**里面，链表的每个节点记录了被订阅的模式和客户端。PSUBSCRIBE和PUNSUBSCRIBE命令分别添加和删除一个节点。

## 发送消息

命令`PUBLISH <channel> <message>`将消息message发送给频道channel。

Redis服务器首先将消息发送给**pubsub_channels字典**中频道channel对应的所有订阅者，然后遍历**pubsub_patterns链表**，当遇到与channel频道相匹配的模式时，将消息发送给对应客户端。

# 事务

事务开始：`MULTI`命令。

命令入队：每个Redis客户端都有自己的事务状态，其中的事务队列来保存事务期间的多条命令。

事务执行：`EXEC`命令开始执行事务，服务器会遍历客户端的事务队列，执行队列中的所有命令，最后将结果返回给客户端。

## WATCH命令

**WATCH命令是一个乐观锁**，可以在EXEC命令执行之前调用来监视一些键的变化。

若在EXEC执行时，被WATCH监视的键发生了修改，服务器则拒绝执行事务，并向客户端返回空回复（nil）。

### WATCH原理

Redis数据库中保存着一个**watched_keys字典**，该字典的键是被WATCH命令监视的键，值是监视该键的客户端链表。

对于SET、LPUSH、SADD、ZREM、DEL等会对数据库进行修改的命令，在执行之后会检查watched_keys字典是否存在刚刚操作的键，若存在，则打开将该键对应链表中的客户端的**REDIS_DIRTY_CAS标识**。而在EXEC执行时，服务器会根据客户端的REDIS_DIRTY_CAS状态来决定是否执行事务。

避免MULTI（开始事务）和EXEC（执行事务）执行之间，其他客户端操作当前客户端事务涉及的key。

## Redis中事务的性质

在Redis中，事务总是满足**原子性，一致性和隔离性**的，并且当Redis开启持久化模式时，也满足**持久性**。

### 原子性

Redis事务队列中的命令要么全部执行，要么一个都不执行。但是Redis**不支持事务回滚**，即使事务队列中某个命令执行出现了错误，整个事务也会继续执行下去。

### 一致性

Redis通过错误检测和一些设计来保证食物的一致性。

**入队错误：**如果一个事务在命令入队时出现了命令不存在或命令格式错误的情况，Redis会拒绝执行该事务。

**执行错误：**执行错误是一些不能在入队时被检查出来的错误。若事务在执行过程中发生了错误，服务器不会中断事务的执行。

**服务器停机：**若Redis在执行事务的过程中停机，服务器要么无持久化机制，重启之后为空白数据库，要么根据RDB或者AOF文件恢复数据。

### 隔离性

Redis使用**单线程模式**来执行事务，因此Redis的隔离级别总是**串行化**的。

### 持久性

Redis只是简单的用队列包裹了一组Redis命令，没有为事务提供额外的持久化机制，因此Redis的持久性由Redis的持久化模式决定。

若Redis运行在无持久化、RDB持久化、AOF持久化（appendfsync值为everysec）下，事务不具有持久性。

若Redis运行在**AOF持久化且appendfsync值为always**，事务具有持久性。

或者在**事务的最后，EXEC之前加上SAVE**命令，可以保证事务的持久性。

# Lua脚本

Redis在服务器嵌入Lua环境，客户端可以使用Lua脚本直接在服务器端原子地执行多个Redis命令。

# 慢查询日志

- slowlog-log-slower-than：执行时间超过指定微秒的命令会记录在日志上。
- slowlog-max-len：最多保存多少条慢查询日志，**链表保存，先进先出**。

# 监视器

通过执行MONITOR命令，客户端可以将自己变为一个监视器。每当一个客户端向服务器发送一条命令时，服务器除了会处理命令之外，还会将命令信息发给monitors链表中的所有监视器。

# 缓存问题

## 缓存和数据库一致性问题

使用缓存只能通过合适的策略来降低缓存和数据库之间不一致的概率，无法保证两者间的强一致性。

https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md

## 缓存击穿

指对于会被高并发访问的若干个热点数据，在这个数据失效的瞬间，这些高并发访问直接落到了数据库上。

解决方法：

- 设置热点数据永不过期，需要时再进行更新。
- 对热点数据加互斥锁，同时只能有一个线程访问数据库的数据，一个线程访问后重建缓存。

## 缓存雪崩

指某个时间点缓存数据大规模失效，此时请求就会直接到达数据库，造成数据库短时间内承受大量请求而崩掉。

解决方法：

- 设置热点数据永不过期，需要时再进行更新。

- 对数据的过期时间额外加上一个随机值，避免同时失效。
- 构建多级缓存。
- 对于集群Redis，可以将热点数据均匀分布在不同的Redis库中。

## 缓存穿透

指大量请求的key根本不存在于缓存中，导致请求直接到达数据库。

解决方法：

- 在接口层过滤掉不合法的查询，如负数id。

- 布隆过滤器：把所有有效请求的值都存放在布隆过滤器中，通过布隆过滤器判断请求是否有效。

  ![image-20200904164234280](/images/Redis/image-20200904164234280.png)

  布隆过滤器由一个二进制数组和一系列Hash函数组成，当一个元素加入过滤器时，通过K个Hash函数将这个元素映射为K个下标，然后把二进制中对应位置置为1。

- 缓存无效key：查询数据库中也没用的数据时，返回一个key-null缓存到Redis中，并设置一个较短过期时间。
