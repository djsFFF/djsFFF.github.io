---
title: JVM学习系列二：虚拟机执行子系统
date: 2020-08-13 20:15:00
tags: 
	- JVM
	- JAVA
categories:
	- JVM
typora-root-url: ../..
---

本文记录了《深入了解Java虚拟机：JVM高级特性与最佳实践》中第三部分“虚拟机执行子系统”的学习笔记。

<!--more-->

# Class类文件的结构

Class文件是一组以8个字节为单位的二进制流，任何一个Class文件都对应着唯一的一个类或接口的定义信息。

数据类型：

- 无符号数：可以用来描述数字、索引引用、数量值或按UTF-8编码构成字符串值；u1，u2，u4，u8分别代表1、2、4、8个字节的无符号数。
- 表：由多个无符号数或者其他表作为数据项构成的复合数据类型。命名以“_info”结尾。

![image-20200824215825527](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200824215825527.png)

## 魔数与版本号

- 魔数（Magic Number）：Class文件的头四个字节，用于确定该文件是否为一个能被虚拟机接受的Class文件。

- 版本号：第5、6个字节是次版本号，第7、8个字节是主版本号（JDK12为57）。

## 常量池

第9、10个字节表示常量池容量计数值，计数从1而不是0开始，后面紧跟一系列常量表。

常量池中主要存放两大类常量：

- 字面量：如文本字符串、被声明为final的常量等。
- 符号引用：被模块导出或者开放的包、类和接口的全限定名、字段的名称和描述符、方法的名称和描述符、方法句柄和方法类型、动态调用点和动态常量。

每一项常量都是一个表，共有17种常量表。

![image-20200814120634525](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814120634525.png)

## 访问标志

常量池结束之后，紧接着的2个字节代表访问标志。

![image-20200814115542959](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814115542959.png)

## 类索引、父类索引与接口索引集合

三者按顺序排在访问标志之后，类索引和父类索引都是u2类型的数据，接口索引集合是一组u2类型数据的集合，它们各指向常量池中一个类描述符常量。

## 字段表集合

![image-20200814123027347](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814123027347.png)

字段表用于描述接口或者类中声明的变量，不会列出从父类或父接口中继承而来的字段。首先是一个字段表计数器，后接若干个字段表。

数组类型描述符：每一维用一个的"["来描述。如`java.lang.String[][]`被描述为`[[Ljava.lang.String`。

## 方法表集合

字段表集合之后就是方法表集合，结构与字段表结构类似。首先是一个方法表计数器，后接若干个方法表。

方法描述符：先参数列表后返回值，如`int test(char[] a, int b)`被描述为`([CI)I`。

## 属性表集合

### Code属性

![image-20200814125020707](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814125020707.png)

方法里面的代码经过Javac编译器处理后，变为字节码指令存储在Code属性内。

**变量槽**：变量槽是虚拟机为局部变量分配内存使用的最小单位。对于byte、char、float、int、short、boolean等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long占用两个变量槽。

### 其他属性

- Exception：列举方法描述时在throws关键字后面的异常。
- LineNumberTable：用于描述Java源码行号与字节码行号（字节码的偏移量）之间对应的关系。

- LocalVariable、LocalVariableTypeTable：LocalVariable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。LocalVariableTypeTable与LocalVariable类似，适用于泛型。

- SourceFile、SourceDebugExtension：SourceFile用于记录生成这个Class文件的源码文件名称。SourceDebugExtension用于存储额外的代码调试信息。

- ConstantValue：通知虚拟机自动变为静态变量赋值，只有被static关键字修饰的变量才可以使用这项属性。

- InnerClasses：用于记录内部类与宿主类之间的关联。
- Deprecated、Synthetic：Deprecated属性用于表示某个类、字段或方法已被程序作者定为不再推荐使用。Synthetic属性表示此字段或方法不是Java源码直接产生的，而是由编译器自行添加的。
- StackMapTable：会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。
- Signature：记录泛型前面信息。
- BootstrapMethods：用于保存invokeddynamic指令引用的引导方法限定符。
- MethodParameters：记录方法的各个形参名称和信息。
- 模块化相关属性：Module、ModulePackage、ModuleMainClass
- 运行时注解相关属性：RuntimeVisibleAnnotations、RuntimeInvisibleAnnotations、RuntimeVisibleAnnotations、RuntimeInvisibleParameterAnnotations、RuntimeVisibleParameterAnnotations、RuntimeInvisibleParameterAnnotations

# 类加载机制

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程称为虚拟机的类加载机制。

![image-20200814140338240](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814140338240.png)

一个类型从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期如图所示。

解析可能在初始化之后再开始，这是为了支持Java的动态绑定。

## 类加载的时机

有且只有六种情况需要立即对类进行到“初始化”阶段：

- 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时。
- 使用java.lang.reflect包的方法对类型进行反射调用时。
- 初始化类时发现其父类还没有初始化，则先触发其父类的初始化。
- 虚拟机启动时，初始化包含main()方法的主类。
- 使用JDK 7加入的动态语言支持时，需要初始化相应的类。
- 当一个接口中定义了JDK 8加入的default方法时，如果该接口的实现类发生了初始化，那么该接口要在其之前初始化。

## 类加载的过程

加载、验证、准备、解析、初始化。

### 加载

非数组类型的加载阶段是开发人员可控性最强的阶段，可以使用虚拟机内置的引导类加载器也可以由用户自定义的类加载器完成。

虚拟机在加载阶段需要完成以下三件事情：

1. 通过一个类的全限定名获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

加载阶段与连接阶段的部分动作是交叉进行的，如一部分字节码文件格式验证动作。

### 验证

确保Class文件的字节流包含的信息符合虚拟机要求，保证这些信息运行后不会危害虚拟机自身的安全。

包括四个阶段的验证动作：

1. 文件格式验证：验证字节流是否符合Class文件规范，能否被当前版本的虚拟机处理。
2. 元数据验证：对字节码描述的信息进行语义分析，保证其描述的信息符合《Java语言规范》的要求。
3. 字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。
4. 符号引用验证：检查是否能够正常引用它依赖的某些外部类、方法、字段等，确保解析行为能正常执行。

### 准备

为类中定义的静态变量分配内存并初始化为默认值，仅包括类变量，不包括实例变量。

实例变量会在对象实例化时随对象一起分配在Java堆中。

如果存在类字段被static final修饰，虚拟机会直接初始化为ConstantValue。

### 解析

将常量池内的符号引用解析为直接引用。

解析主要针对7类符号引用：类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符

符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量。

直接引用：可以直接指向目标的指针、相对偏移量或者是能直接定位到目标的句柄。

类或接口的解析：根据类或接口的全限定名加载对应类或接口，然后验证访问权限。

字段解析：首先解析出字段所属的类或接口C，若C中包含匹配的字段则返回该字段的直接引用，否则依次搜索C实现的**各个接口和父类**，最后验证访问权限。

方法解析：首先解析出方法所属的类或接口C，若C中包含匹配的方法则返回该方法的直接引用，否则依次搜索C实现的**父类和各个接口**，最后验证访问权限。

### 初始化

执行类构造器\<clinit\>()方法，\<clinit\>()方法是由编译器自动收集类中的**类变量赋值语句和静态语句块**合并产生的。

同一个类加载器下，一个类型只会被初始化一次。

## 类加载器

类加载器实现了**加载**过程中的“通过一个类的全限定名来获取定义此类的二进制字节流”这一动作。

### 类与类加载器

对于任意一个类，必须由加载它的类加载器和类本身（全限定名）共同确立在虚拟机中的唯一性。

### 双亲委派模型

#### JDK 9之前

![image-20200814171646877](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814171646877.png)

JDK 9之前的Java应用都是由启动类加载器、扩展类加载器、应用程序类加载器互相配合完成加载的，用户可以加入自定义的类加载器进行拓展。

双亲委派模型要求除了启动类加载器外，其余的类加载器都应有自己的父类加载器。父子关系不是以继承的关系实现的，而是使用组合关系来复用父类加载器的代码。

工作过程：当一个类加载器收到类加载的请求时，首先查看是否已加载过该类，若没有，则把这个请求委派给父加载器去完成，直到启动类加载器，若父加载器都没有加载过该类，当前类加载器才会尝试自己完成加载。

优点：保证稳定性，避免用户自己编写的类替换掉Java的一些核心类，同时也可以避免重复加载。

#### JDK 9及之后

![image-20200814173453876](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814173453876.png)

JDK 9中把Extension Class Loader替换为了Platform Class Loader。父类都发生了变化。

双亲委派模型：类加载请求会优先委派给负责待加载类所属模块的类加载器。

# 字节码执行引擎

以方法为基本单位执行Class文件中包含的字节码指令。

执行引擎执行Java代码时可以选择解释执行（通过解释器执行）或者编译执行（通过即时编译器产生本地代码执行）。

## 运行时栈帧结构

虚拟机以方法作为最基本的执行单元，栈帧则是用于支持虚拟机进行方法调用和方法执行的数据结构。

栈帧存储了局部变量表、操作数栈、动态连接、方法返回地址等信息，一个栈帧需要分配多少内存在编译Java源码时就已经被分析计算出来了。

### 局部变量表

局部变量表以变量槽为最小单位存储方法参数、方法内部定义的局部变量。

### 操作数栈

栈内每一个元素可以是任意Java数据类型，32位数据类型占用栈容量为1，64位数据类型占用栈容量为2。

### 动态连接

为了支持方法调用过程中的动态连接，每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。

### 方法返回地址

方法退出之后，必须返回到最初方法被调用的位置，程序才能继续执行。

## 方法调用

方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），不涉及方法内部运行过程。

### 解析

静态方法、私有方法、实例构造器、父类方法和被final修饰的方法这5种方法调用会在类加载的就把符号引用解析为该方法的直接引用，是一个静态的过程。

### 分派

静态分派：依赖静态类型来决定方法执行版本的分派动作称为静态分派，典型应用代表就是**方法重载**。静态分派发生在编译阶段，而不是虚拟机执行的。

动态分派：典型应用代表就是**方法重写**。

## 基于栈的字节码解释执行引擎

### 解释执行

![image-20200814182707365](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20200814182707365.png)

Javac编译器完成了程序源码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。而解释器则是在虚拟机内部实现的。

