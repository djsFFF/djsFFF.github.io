---
title: Java并发编程
date: 2020-08-15 20:15:00
tags: 
	- 并发
	- JAVA
categories:
	- Java并发编程
typora-root-url: ..
---

# 线程基础

## 线程创建的方式

- 实现Runnable接口的run方法：可以继承其他类，多个线程可以共用一个代码逻辑。

- 继承Thread类并重写run方法：直接使用this可以获取当前线程，。

- 使用FutureTask：可以获取返回结果。

## 线程通知与等待

Object类中的通知与等待系列函数：

- wait()：获得锁后才能调用。线程阻塞并释放当前对象的锁。

- notify()：获得锁后才能调用。随机唤醒一个被挂起的线程来竞争锁。
- notifyAll()：获得锁后才能调用。唤醒所有被挂起的线程来竞争锁。

Thread类中的通知与等待系列函数：

- join()：阻塞当前线程，等待目标线程执行完毕。
- sleep()：当前线程让出CPU使用权，被阻塞挂起，但是不会释放锁。
- yield()：当前线程让出CPU使用权，处于就绪状态。

## 守护线程

JVM会等待所有用户线程结束后才退出，而守护线程是否结束不影响JVM的退出。

## 线程本地变量

### ThreadLocal

访问ThreadLocal变量的线程会在线程中有一个本地副本，操作这个变量不需要与主内存同步。

实现原理：每个Thread实例中有一个类似HashMap类型的threadLocals变量，ThreadLocal以当前ThreadLocal的实例对象引用（this）为key对threadLocals变量进行操作。

```java
ThreadLocal<String> var = new ThreadLocal<>();
var.set("test");
System.out.println(var.get());
```

内存泄漏问题：ThreadLocalMap的Entry中的key是对ThreadLocal对象的弱引用，当其他地方没有对ThreadLocal对象的引用时，ThreadLocal对象会被回收，但是对应的value没有被回收，这时候就存在key为null但是value不为null的项。解决方法是使用完毕后调用remove()。

### InheritableThreadLocal

InheritableThreadLocal继承自ThreadLocal，可以让子线程访问父线程中设置的本地变量。

实现原理：每个Thread实例中保存了类似threadLocals的inheritableThreadLocals变量，在当前线程创建新线程时，把当前线程的inheritableThreadLocals变量赋给新线程。

```java
Thread parent = currentThread(); // parent为当前线程
...
if (parent.inheritableThreadLocals != null) {
	this.inheritableThreadLocals = // this为当前线程正在初始化的新线程
        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
}
```

### ThreadLocalRandom

每个Thread实例维护一个线程级别的种子变量threadLocalRandomSeed，避免了竞争。

## 锁的内存语义

加锁时把代码块内使用到的共享变量从线程的工作内存中清除，然后从主内存获取。

释放锁时把代码块里的共享变量修改刷新到主内存。

## 锁的类别

- 悲观锁：认为共享变量很容易发生竞争，因此对共享变量进行操作时会加锁。
- 乐观锁：任务共享变量一般情况下不会发生竞争，所以在操作前不会加锁，而是在更新时才进行冲突检测。

- 公平锁：线程获取锁的顺序是按照现场请求锁的时间决定的。
- 非公平锁：线程获取锁的顺序不确定。
- 独占锁：保证任何时候只能有一个线程获得锁。是一种悲观锁。
- 共享锁：允许多个线程同时进行读操作。是一种乐观锁。
- 可重入锁：线程再次获取当前已有的锁不会被阻塞。
- 自旋锁：执行忙循环检测是否可以获得锁。

# JUC并发包（java.util.concurrent）

## 原子操作类

### AtomicInteger、AtomicLong、AtomicBoolean

都属于java.util.concurrent.atomic包，基于Unsafe类（实现了CAS机制）实现了递增递减等操作。

### LongAdder、DoubleAdder

AtomicLong等类在有大量线程竞争时，会不断自旋尝试CAS操作，造成了CPU资源浪费，LongAdder类在内部维护多个Cell变量，每个Cell有一个初始值为0的long型变量。当线程在当前Cell变量CAS失败后，可以在其他Cell上进行CAS尝试，最后把所有Cell的值累加后返回。

## 并发List

### CopyOnWriteArrayList

读取时不加锁，写入和删除时加锁，对数组的一个快照进行操作，不影响其他线程读取原数组，然后更新原数组的引用。

在使用方法add(E e)添加元素时，首先获取ReentrantLock独占锁保证添加元素时不会被其他线程修改，然后将原来的数组复制到原数组+1大小的新数组里面并把新元素添加到末尾，再用新数组替换掉原数组，在返回前释放锁。

迭代器的弱一致性：返回迭代器后，其他线程对list的增删改对迭代器是不可见的。

## 锁原理

### LockSupport工具类

主要作用是挂起和唤醒线程，是创建锁和其他同步类的基础。使用Unsafe类实现。

LockSupport类与每个使用它的线程会关联一个许可证，默认情况下调用LockSupport类方法的线程是不持有许可证的。

- park()：调用线程如果已经获得许可证，则调用时会马上返回，否则会被阻塞挂起。
- unpark(Thread thread)：如果线程没有持有许可证，则让线程持有，如果线程因调用park()挂起，则唤醒线程。

### 抽象同步队列AQS（AbstractQueueSynchronizer）

是实现同步器的基础组件，JUC中锁的底层就是使用AQS实现的。

AQS是一个双向队列，head和tail记录队首和队尾结点。

Node中的thread存放进入AQS的线程，SHARED标记该线程是获取共享资源时被阻塞挂机后放入AQS的，EXCLUSIVE标记该线程是获取独占资源时被阻塞挂起后加入AQS的；pre、next记录前驱和后继结点。

AQS维护了一个状态信息state：

- 在ReentrantLock中，state可以表示当前线程获取锁的可重入次数。
- 在读写锁ReentrantReadWriteLock中，state的高16位表示读状态，低16位表示获取到写锁的线程的可重入次数。
- 在Semaphore中，state用于表示当前可用信号的个数。
- 在CountDownLatch中，state表示计数器当前的值。

其他锁在基于AQS实现时，关键是定义对state的操作。

#### 条件变量

ConditionObject是AQS的内部类，每个条件变量对应一个条件队列（单向链表），用于存放调用条件变量的await()后被阻塞的线程。

![image-20200819100243950](/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200819100243950.png)

一个锁对应一个AQS阻塞队列，对应多个条件变量，每个条件变量有自己的一个条件队列

### 独占锁ReentrantLock

使用AQS实现，state表示该线程获取该锁的可重入次数，可以设置为公平锁或非公平锁。

当一个线程第一次获取该锁时会尝试使用CAS设置state的值为1，如果成功则获取到该锁。再次获得锁更新state加一。

释放锁时将state值减一，若state为0则释放锁。

### 读写锁ReentrantReadWriteLock

读写分离策略，允许多个线程同时获取读锁。

使用AQS实现，state的高16位表示获取到读锁的次数，低16位表示获取到写锁的线程可重入次数。

- 写锁WriteLock：独占锁，如果当前已有其他线程持有读锁或写锁，则当前请求写锁的线程会被阻塞挂起。
- 读锁ReadLock：如果当前没有其他线程持有写锁，则可以获取读锁，state的高16加1。如果有其他线程持有写锁，则当前线程会被阻塞。

### StampedLock

调用获取锁的函数时，会返回一个long型stamp表示锁的状态，当调用释放锁和转换锁的方法时需要传入这个stamp值。

StampedLock提供三种读写模式的锁：

- 写锁writeLock：排他锁、独占锁，不可重入。当目前没有其他线程持有读锁或者写锁时才能获取到该锁。
- 悲观读锁readLock：共享锁，不可重入。其他线程可以加读锁，不能加写锁。
- 乐观读锁tryOptimisticRead：没有显式的加锁释放锁，在具体操作数据前根据stamp验证期间是否有其他线程持有了写锁。

## 并发队列

### ConcurrentLinkedQueue

非阻塞队列，使用单向链表和CAS实现。

每个结点包括volatile修饰的元素和next结点。队列中保存了volatile关键字修饰的head和tail结点。

offer()中调用tail.casNext()在tail后添加元素，这个方法使用的是CAS操作，只有一个线程会成功，失败的线程会循环重新获取tail。poll()类似。

### LinkedBlockingQueue

阻塞队列，使用单向链表和两个独占锁实现，size不一定准确。

两个ReentrantLock实例takeLock和putLock分别控制元素入队和出队的原子性，此外两个独占锁都配置了一个条件队列，用来存放被阻塞的线程，结合入队出队操作实现了一个生产者-消费者模型。

### ArrayBlockingQueue

阻塞队列，使用数组和一个全局独占锁实现，size准确。

通过全局独占锁实现了同时只能有一个线程进行入队或出队操作，队列包括一个数组items，入队和出队下标，以及队列元素个数。offer()和poll()通过加锁实现，而put()和take()使用条件变量实现。notEmpty、notFull条件变量进行出队和入队的同步。

### PriorityBlockingQueue

排序的阻塞队列，使用平衡二叉树堆（数组实现）和独占锁实现。

使用数组存放队列元素，一个自旋锁通过CAS操作来保证同时只有一个线程可以扩容队列，一个ReentrantLock控制只有一个线程可以进行入队、出队操作。notEmpty条件变量控制出队同步。

### DelayQueue

阻塞延迟队列，队列中每个元素都有个过期时间，从队列获取元素时，只有过期元素才会出对了，头元素时快要过期的元素。

使用PriorityQueue存放数据，使用ReentrantLock实现线程同步。

## 线程池ThreadPoolExecutor

1. 在执行大量异步任务时线程池能够提供较好的性能，线程池里面的线程是可复用的，不需要每次执行异步任务时都重新创建和销毁线程。
2. 线程池提供了一种线程限制和管理的手段，可以限制线程的个数，动态新增线程等，每个ThreadPoolExecutor保留了一些基本的统计数据。

ctl是一个AtomicInteger变量，高3位表示线程池状态，低29位记录线程个数。

使用完线程池需要调用shutdown()关闭线程池，否则会导致主线程已经退出，但是JVM仍然存在。

### 线程池状态

- **RUNNING**：接受新任务并处理阻塞队列里的任务。
- **SHUTDOWN**：拒绝新任务但是处理阻塞队列里的任务。
- **STOP**：拒绝新任务并抛弃阻塞队列里的任务，同时中断正在处理的任务。
- **TIDYING**：所有任务执行完毕后线程数为0，即将调用terminated方法。
- **TERMINATED**：终止状态。

### 线程池状态切换

- RUNNING 到 SHUTDOWN：调用shutdown()。
- RUNNING或SHUTDOWN 到 STOP：调用shutdownNow()。
- SHUTDOWN 到 TIDYING：线程池和任务队列都为空时。
- STOP 到 TIDYING：线程池为空时。
- TIDYING 到 TERMINATED：terminated()hook方法执行完成时。

### 线程池构造参数

- corePoolSize：线程池核心线程个数。
- workQueue：保存等待执行的任务的阻塞队列，ArrayBlockingQueue等。
- maximumPoolSize：线程池最大线程数量。
- ThreadFactory：创建线程的工厂。
- RejectedExecutionHandler：队列满并且线程个数达到最大后采取的策略。
- keepAliveTime：线程数量比核心线程数量多且闲置时，表示闲置线程的最大存活时间。
- TimeUnit：存活时间的单位。

### 创建线程池

- **newFixedThreadPool**：核心和最大线程数都为参数nThread，阻塞队列长度为整型最大值，可以设置存活时间和阻塞队列类型。
- **newSingleThreadExecutor**：核心和最大线程数都为1，阻塞队列长度为整型最大值，可以设置存活时间和阻塞队列类型。
- **newCachedThreadPool**：按任务创建线程，初始线程个数为0，最多为整型最大值，阻塞队列为同步队列且加入同步队列的任务会被马上执行，同步队列中对多只有一个任务。

### 方法

- execute(Runnable command)：提交任务command到线程池执行。如果当前线程池的线程数量小于核心线程数量，则通过CAS操作向workers里面新增一个核心线程执行该任务。

## ScheduledThreadPoolExecutor

可以在指定一定延迟时间后或者定时进行任务调度执行的线程池。

使用DelayQueue来存放任务，任务分为三种：

- 一次性执行任务：执行完毕就结束了。
- fixed-delay任务：同一任务在多次执行之间间隔固定时间。
- fixed-rate任务：保证按照固定的频率执行。

## 线程同步器

### CountDownLatch

使用AQS实现，把计数器的值赋给AQS的状态变量state，多个线程调用countDown()实际是原子性递减state。当线程调用await()方法后会被放入AQS的阻塞队列等待计数器为0再返回。

以线程数量为参数创建一个CountDownLatch实例，主线程调用countDownLatch.await()后会被阻塞，子线程执行完毕后调用countDownLatch.countDown()使countDownLatch内部的计数器减1，计数器为0时主线程的await()方法返回，表示所有子线程已执行完毕。

使用线程池管理线程时一般是直接添加Runnable到线程池，这时候就无法调用线程的join()，而CountDownLatch使我们对线程同步有更灵活的控制。

### 回环屏障CyclicBarrier

CyclicBarrier可以让一组线程全部达到一个状态后再全部同时执行。

线程调用awati()后会被阻塞，这个阻塞点称为屏障点，等所有线程都调用了await()后，线程们就会冲破屏障，继续向下执行。

基于ReentrantLock实现，本质底层还是基于AQS，parties记录线程数量，count记录还有多少个线程没有到达屏障点。使用ReentrantLock保证count更新的原子性。

### 信号量Semaphore

也是一个同步器，计数器是递增的并且可以指定一个初始值，在需要同步的地方调用acquire()指定需要达到的计时器值，在线程内部调用release()使计数器加1。

也是使用AQS实现的，获取信号量时有公平和非公平策略。

