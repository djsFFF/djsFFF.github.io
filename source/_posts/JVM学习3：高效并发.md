---
title: JVM学习系列三：高效并发
date: 2020-08-14 20:15:00
tags: 
	- JVM
	- JAVA
categories:
	- JVM
typora-root-url: ..
---

本文记录了《深入了解Java虚拟机：JVM高级特性与最佳实践》中第五部分“高效并发”的学习笔记。

<!--more-->

前端编译器：把\*.java文件转变为\*.class文件的过程。如JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）。

即时编译器：Java虚拟器运行期把字节码转变为本地机器码的过程。如HotSpot的C1、C2编译器，Graal编译器。

提前编译器：直接把源代码编译成目标机器指令集相关的二进制代码的过程。JDK的Jaotc、Excelsior JET。

HotSpot内置了两个（或三个）即时编译器，分别是客户端编译器（C1）和服务端编译器（C2）（Graal是JDK 10出现的即时编译器）。

热点探测：基于采样、基于计数器。

# Java内存模型与线程

在计算机中，增加高速缓存可以解决处理器与内存读写速度之间的矛盾，此外处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果一致。

Java虚拟机的即时编译器中也有**指令重排序**优化。

## Java内存模型

Java内存模型的主要目的是定义程序中各种变量的访问规则，关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。

### 主内存与工作内存

![image-20200815225312598](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/image-20200815225312598.png)

Java内存模型规定了所有变量都存储在**主内存**中，每条线程还有自己的工作内存（类比计算机中的高速缓存）。

线程的**工作内存**中保存了该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。

主内存主要对应Java堆中的对象实例数据部分。

工作内存主要对应于虚拟机栈中的部分区域。

### 内存间交互操作

主内存与工作内存知己交互主要通过8种操作来完成：

1. lock：作用于主内存变量，把一个变量标识为一条线程独占的状态。
2. unlock：作用于主内存变量，释放一个lock状态的变量。
3. read：作用于主内存变量，把一个变量的值从主内存传输到工作内存中。
4. load：作用于工作内存变量，把read操作得到的变量放入工作内存的变量副本中。
5. use：作用于工作内存变量，把工作内存中一个变量的值传递给执行引擎。
6. assign：作用于工作内存变量，把一个从执行引擎接收的值赋给工作内存的变量。
7. store：作用于工作内存变量，把工作内存中一个变量的值传送到主内存中。
8. write：作用于主内存变量，把store操作得到的变量放入主内存变量中。

### volatile型变量

当一个变量被volatile关键字修饰时，具有两个特性：

1. 此变量对所有线程可见，即当一个线程修改了变量的值，新值对于其他线程来说是可以立即得知的。
2. 禁止指令重排序优化。

volatile修饰的变量赋值后会多执行一个`lock add1 $0x0,(%esp)`操作，这个操作相对于一个内存屏障，不能把内存屏障后面的指令重排序到内存屏障之前的位置。

lock可以将本处理器的缓存写入内存，该写入操作也会引起别的处理器或别的内核无效化其缓存，相当于对缓存中的变量做了一次“store和write”操作。

### long和double的非原子性协定

Java内存模型要求8中操作都具有原子性，但是允许虚拟机将没有被volatile修饰的64位的long和double数据的读写操作划分为两次32位的操作来进行。

### 原子性、可见性和有序性

在Java内存模型中，基本数据类型的访问、读写都是具备原子性的。

volatile、synchronized、final关键字都能实现可见性。

volatile、synchronized关键字能保证线程之间操作的有序性。

### 先行发生原则

## Java与线程

### 线程的实现

使用内核线程实现（1:1），使用用户线程实现（1:N），使用用户线程加轻量级进程混合实现（N:M）。

Java线程的实现：主流Java虚拟机的线程模型普遍基于操作系统原生线程模型来实现，即采用1:1的线程模型。

### Java线程调度

协同式线程调度：线程的执行时间由线程本身控制，线程把自己的工作执行完成之后，要主动通知系统切换到另一个线程上去。

抢占式线程调度：由系统来分配执行时间。**Java使用这种调度方式**。

主流虚拟机的Java线程是被映射到系统的原生线程上实现的，所以线程调度最终还是由操作系统控制。

### 状态切换

![image-20200814235021618](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/image-20200814235021618.png)

Java定义了6中线程状态，一个线程在一个时间点只能处于一个状态：

1. **新建（New）**：线程创建后尚未启动。
2. **运行（Runnable）**：包括操作系统线程状态中的Running和Ready，也就是可能正在执行，也可能在等待分配执行时间。
3. **无限期等待（Waiting）**：无参数的wait()，join()等方法会进入该状态，需要等待其他线程唤醒。
4. **限期等待（Timed Waiting）**：带参数的sleep()，wait()，join()等方法会进入该状态，一定时间后会被系统自动唤醒。
5. **阻塞（Blocked）**：在程序进入同步区域的时候，线程将进入这个状态。
6. **结束（Terminated）**：线程已经结束执行。

# 线程安全与锁优化

## 线程安全

当多个线程同时访问一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他操作的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。

### 互斥同步

**同步**是指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条（或是一些，当使用信号量的时候）线程使用。

**互斥**是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。

互斥是因，同步是果；互斥是方法，同步是目的。

**synchronized**：经过Javac编译之后，在同步块的前后分别形成monitorenter和monitorexit两个字节码指令，执行monitorenter指令时会将锁计数器的值加一，执行monitorexit指令时会将锁的计数器的值减一。

- 可重入：被synchronized修饰的同步块对同一条线程来说是可重入的。
- 重量级锁：无法强制已获取所得线程释放锁，也无法强制正在等待锁的线程中断等待或超时退出。

**ReentrantLock**：与synchronized相似，也是可重入，多了一些高级功能，如等待可中断、可实现公平锁、锁可以绑定多个条件。

- 等待可中断：持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，处理其他事情。
- 公平锁：多个线程等待同一个线程时，按照申请锁的时间顺序来依次获取锁，性能会下降。
- 锁绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象。

### 非阻塞同步

**互斥同步的主要问题是进行线程阻塞和唤醒带来的性能开销**，因此互斥同步也被称为阻塞同步。

非阻塞同步：基于冲突检测的乐观并发策略（乐观锁），即在执行操作后若与其他线程产生了冲突，再进行其他补偿操作，如不断重试直到没有冲突。

非阻塞同步必须要求操作和冲突检测这两个步骤具有原子性，可以只通过一条处理指令完成，如**比较并交换（Compare-and-Swap，CAS）**。

在IA64、x86指令集中用cmpxchg指令完成CAS功能。

**CAS**需要三个操作数，分别是内存地址V、旧的预期值A和准备设置的新值B。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则不执行更新。但是不管是否更新了V的值，都会返回V的旧值。原子操作。

**ABA问题**：如果一个变量V初次读取的是A值，但是在赋值检查之前，有可能被修改为B值，然后又被改回A值，此时CAS操作会误认为它从来没有改变过。可以增加**版本号**来保证CAS的正确性。

## 锁优化

### 自旋锁与自适应自旋

自旋锁：线程在获取锁的时候，如果锁已被其他线程获取，那么该线程执行忙循环（自旋）检查是否可以获取锁。

- 如果自旋超过限定的次数仍然没有成功获得锁，就应当挂起线程。

- 避免了线程切换的开销，但是要占用处理器时间，需要一个以上的处理器核心。

自适应自旋：在JDK 6引入，自旋的时间由上一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

- 对于同一个锁对象，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机会认为这次自旋也很有可能再次成功。
- 如果对于某个锁，自旋很少成功获得锁，那么在以后要获取这个锁的时候直接跳过自旋过程。

### 锁消除

锁消除是指虚拟机即时编译器在运行时，对被检测到不可能存在共享数据竞争的锁进行消除。

### 锁粗化

当一串零碎的操作都对同一个对象加锁时，虚拟机会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

### 轻量级锁

“轻量级”锁是JDK 6加入的新型锁机制，目的是在无竞争的情况下使用CAS操作去消除同步使用的互斥量。

“轻量级”是相对于使用操作系统互斥量来实现的“重量级”锁而言的。

HotSpot虚拟机的对象头第一部分称为“Mark Word”，存储对象自身的运行时数据，如HashCode、分代年龄、偏向模式、锁标志位等信息。这部分是实现轻量级锁和偏向锁的关键。

![image-20200815204815564](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/image-20200815204815564.png)

MarkWord被设计成一个非固定的动态数据结构，可以根据对象的状态存储不同的信息。

轻量级锁工作过程：

1. 代码即将进入同步块时，如果同步对象没有被锁定（MarkWord中锁标志位为01），虚拟机首先在当前线程的栈中建立一个Lock Record空间，用于存储同步对象的MarkWord拷贝。
2. 然后虚拟机使用CAS操作尝试把同步对象的MarkWord内容更新为指向Lock Record的指针，如果更新成功，则表示该线程拥有了这个对象的锁，并且更新锁标志位为“00"表示处于轻量级锁定模式。
3. 如果更新同步对象的MarkWord内容失败，则检测对象的Mark Word是否指向当前线程的Lock Record区域，如果是，则说明已经拥有了这个对象的锁，否则说明此对象已经被其他线程抢占了。
4. 如果出现两个以上的线程争用同一个锁，那么轻量级锁必须膨胀为重量级锁，锁标志位变为10，此时MarkWord中存储的就是指向重量级锁（互斥量）的指针。
5. 解锁过程同样通过CAS操作进行，如果对象的MarkWord仍然指向线程的Lock Record，则用CAS操作把Lock Record中对象原本的MarkWord内容替换回去，如果替换失败，则说明其他线程尝试获取过该锁，在释放锁的时候，唤醒其他被挂起的线程。

轻量级锁提升性能的依据是对于绝大部分的锁，整个同步周期内是不存在竞争的。但如果存在锁竞争，额外的CAS操作使得轻量级锁反而比重量级锁更慢。

### 偏向锁

偏向锁也是JDK 6引入的一项锁优化措施，目的是消除数据在无竞争情况下的同步原语，既不使用互斥量，也不使用CAS操作。

当锁对象第一次被线程获取时，虚拟机会把MarkWord中的锁标志位改为01，偏向模式改为1，MarkWord的内容进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的MarkWord中。如果CAS操作成功，持有偏向锁的线程以后每次获取这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（如加锁、解锁、对MarkWord的更新操作等）。

![image-20200815205631602](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/image-20200815205631602.png)

当另一个线程尝试获取这个锁的时候，若对象未被锁定，则撤销偏向并设定标志位为01；若对象已被锁定，则设定标志位为轻量级锁状态（00）。

当一个对象已经计算过一致性哈希码后，就再也无法进入偏向锁状态了。

当一个对象在偏向锁状态收到需要计算一致性哈希码请求时，偏向状态会被立即撤销，并且锁会膨胀为重量级。