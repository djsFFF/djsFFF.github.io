---
title: 剑指Offer
date: 2020-09-11 22:15:27
tags: 
	- 算法
categories:
	- 算法
---

《剑指Offer》关键算法题思路总结。

<!--more-->

# 03 数组中重复的数字

![image-20200911201834565](../images/%E5%89%91%E6%8C%87Offer/image-20200911201834565.png)

**思路：**将数字归位到对应位置，出现重复数字时返回。

# 04 二维数组中的查找

![image-20200911202033610](../images/%E5%89%91%E6%8C%87Offer/image-20200911202033610.png)

**思路：**从右上角开始查找，大于目标值则左移，小于目标值则右移。

# 06 从尾到头打印链表

![image-20200911202545515](../images/%E5%89%91%E6%8C%87Offer/image-20200911202545515.png)

**思路：**

- 使用栈保存元素。
- 递归打印。

# 09 两个栈实现队列

![image-20200911202826857](../images/%E5%89%91%E6%8C%87Offer/image-20200911202826857.png)

**思路：**添加元素时直接添加到第一个栈；弹出元素时，若第二个栈为空，则将第一个栈中的元素全部加入到第二个元素，然后弹出第二个栈的元素。

# 11 旋转数组的最小数字

![image-20200911213115815](../images/%E5%89%91%E6%8C%87Offer/image-20200911213115815.png)

**思路：**二分查找。mid > r时，l = mid + 1；mid <= r时，r--。

# 14 剪绳子Ⅰ 

![image-20200911223248798](../images/%E5%89%91%E6%8C%87Offer/image-20200911223248798.png)

**思路：**找规律。当n <= 6时，结果分别为0,0,1,2,4,6,9；当n > 6时，结果为dp[n - 3] * 3。 

# 15 二进制中1的个数

![image-20200912001326318](../images/%E5%89%91%E6%8C%87Offer/image-20200912001326318.png)

**思路：**

- 使用n & 1 == 1判断末尾是否为1，然后无符号右移n >>= 1。

- ```java
  while(n != 0) {
  	res++;
      n = n & (n - 1);
  }
  ```

# 16 数值的整数次方

![image-20200912001638939](../images/%E5%89%91%E6%8C%87Offer/image-20200912001638939.png)

**思路：**首先处理exponent为负数时，然后递归计算，注意exponent为奇数时，需要多乘一个base。

# 21 调整数组顺序使奇数位于偶数前面

![image-20200912002749192](../images/%E5%89%91%E6%8C%87Offer/image-20200912002749192.png)

**思路：**双指针。左指针遍历到第一个偶数，右指针遍历到第一个奇数，然后交换两个元素。

# 22 链表中倒数第k个节点

![image-20200912003248992](../images/%E5%89%91%E6%8C%87Offer/image-20200912003248992.png)

**思路：**双指针。第一个指针先走k步，然后两个指针一起走，直到第一个指针到达尾部。

# 23 反转链表

![image-20200912003545917](../images/%E5%89%91%E6%8C%87Offer/image-20200912003545917.png)

**思路：**

![image-20200912003529299](../images/%E5%89%91%E6%8C%87Offer/image-20200912003529299.png)

# 30 包含min函数的栈

![image-20200912004226484](../images/%E5%89%91%E6%8C%87Offer/image-20200912004226484.png)

**思路：**辅助单调栈。使用一个辅助单调栈维护最小值。

# 33 二叉搜索树的后续遍历序列

![image-20200912005040034](../images/%E5%89%91%E6%8C%87Offer/image-20200912005040034.png)

**思路：**单调栈。倒序遍历数组（左右根 -> 根右左）。

# 38 字符串的排列

![image-20200912010408938](../images/%E5%89%91%E6%8C%87Offer/image-20200912010408938.png)

**思路：**回溯+剪枝。每轮递归中固定没有遍历过的元素中的一位。

# 39 数组中出现次数超过一半的数字

![image-20200912010739651](../images/%E5%89%91%E6%8C%87Offer/image-20200912010739651.png)

**思路：**摩尔投票法。遍历数组，当保存的数与当前遍历到的数相同时，计数器+1，否则计数器-1，并修改保存的数为当前数。

# 42 连续子数组的最大和

![image-20200912011131473](../images/%E5%89%91%E6%8C%87Offer/image-20200912011131473.png)

**思路：**维护一个sum变量，遍历数组，保存最大的sum为结果，当sum小于0时，将sum置0。

# 45 把数组排成最小的数

![image-20200912011422867](../images/%E5%89%91%E6%8C%87Offer/image-20200912011422867.png)

**思路：**将数字看做字符串，按照字符串大小进行排序。

# 48 最长不含重复字符的子字符串

![image-20200912011759855](../images/%E5%89%91%E6%8C%87Offer/image-20200912011759855.png)

**思路：**双指针+Hash表。Hash表存储每个字符最后一次出现的位置，当右指针遇到已出现过的字符时，更新左指针到该字符上一次出现的位置，保证左右指针之间没有重复字符。

# 50 第一个只出现一次的字符

![image-20200912012642907](../images/%E5%89%91%E6%8C%87Offer/image-20200912012642907.png)

**思路：**

- 无序Hash。两次遍历字符串，第一次遍历保存重复状态，第二次遍历获得第一个不重复字符。
- 有序Hash。LinkedHashMap。

# 51 数组中的逆序对

![image-20200912012904699](../images/%E5%89%91%E6%8C%87Offer/image-20200912012904699.png)

**思路：**在归并排序的合并过程中，每当遇到右边数组当前元素大于坐标数组当前元素时，右边数组当前元素之前的值都比左边数组当前元素小。

# 52 两个链表的第一个公共结点

![image-20200912082933950](../images/%E5%89%91%E6%8C%87Offer/image-20200912082933950.png)

**思路：**双指针。ptr1和ptr2分别遍历A、B链表，当ptr1遍历到A链表结尾时，重新指向B的开头，当ptr2遍历到B链表结尾时，重新指向A的开头，直到ptr1 == ptr2。

# 53-Ⅰ  在排序数组中查找数字

![image-20200912083335403](../images/%E5%89%91%E6%8C%87Offer/image-20200912083335403.png)

**思路：**二分查找。分别查找target和target - 1的右边界，将两结果相减即可。

# 53-Ⅱ 0~n-1中缺失的数字

![image-20200912083614626](../images/%E5%89%91%E6%8C%87Offer/image-20200912083614626.png)

**思路：**二分查找。判断数组下标与值是否相等。

# 54 二叉搜索树的第k大结点

![image-20200912084211003](../images/%E5%89%91%E6%8C%87Offer/image-20200912084211003.png)

**思路：**递归中序遍历。

# 57-Ⅱ 和为s的连续正数序列

![image-20200912085639305](../images/%E5%89%91%E6%8C%87Offer/image-20200912085639305.png)

**思路：**双指针滑动窗口。窗口和小于target时，右指针移动，窗口和大于target时，左指针移动。

# 59-Ⅰ 滑动窗口的最大值

![image-20200912090249801](../images/%E5%89%91%E6%8C%87Offer/image-20200912090249801.png)

**思路：**双向单调队列。队列头为最大值，每次滑动时，将若滑动窗口的最左值等于队列头，说明该队列头需要被移除了，然后将滑动窗口新加入的最右值加入到队列中保证单调。

# 59-Ⅱ 队列的最大值

![image-20200912092941507](../images/%E5%89%91%E6%8C%87Offer/image-20200912092941507.png)

**思路：**辅助单调双向队列。添加元素时，分别向队列和单调队列中添加元素。弹出元素时，若弹出的元素恰好与单调队列头元素相等，则单调队列也弹出头元素。

# 61 扑克牌中的顺子

![image-20200912093753366](../images/%E5%89%91%E6%8C%87Offer/image-20200912093753366.png)

**思路：**遍历数组set记录数组中元素是否重复，同时记录数组中的最大值和最小值，若遍历过程中没有出现重复，则判断最大值与最小值的差值。

# 62 圆圈中最后剩下的数字

![image-20200912102707865](../images/%E5%89%91%E6%8C%87Offer/image-20200912102707865.png)

**思路：**

- 通过list保存序列，依次求出需要删除的下标进行删除。

- 数学推导

  ```java
  class Solution {
      public int lastRemaining(int n, int m) {
          int ans = 0;
          // 最后一轮剩下2个人，所以从2开始反推
          for (int i = 2; i <= n; i++) {
              ans = (ans + m) % i;
          }
          return ans;
      }
  }
  ```

# 68-Ⅰ 二叉搜索树的最近公共祖先

![image-20200912112355980](../images/%E5%89%91%E6%8C%87Offer/image-20200912112355980.png)

**思路：**若pq的值都小于当前结点，则遍历至左结点，若pq的值都大于当前结点，则遍历至右结点，否则返回当前结点。

