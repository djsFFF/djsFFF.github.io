---
title: MySQL学习2：InnoDB存储引擎
date: 2020-08-14 20:15:00
tags: 
	- MySQL
	- 数据库
categories:
	- 数据库
typora-root-url: ..
---

<!--more-->

# 三范式

- 第一范式（1NF）：字段是单一属性，不可再分的。
- 第二范式（2NF）：在第一范式的基础上，所有非主键字段都完全依赖于任意一个主键或联合主键，即不能存在非主键字段对联合主键的部分依赖。
- 第三范式（3NF）：在第二范式的基础上，所有非主键字段都直接依赖于主键不能存在传递依赖。

# MyISAM与InnoDB的区别

1. 锁粒度：MyISAM只支持表级锁，InnoDB支持行级锁和表级锁。
2. 事务：MyISAM不支持事务，InnoDB支持事务。
3. 外键：MyISAM不支持外键，InnoDB支持外键。
4. 索引：MyISAM为非聚簇索引，InnoDB为聚簇索引，叶结点中存储所有行数据。

# 一条SQL语句在MySQL中的执行过程

1. 连接器：验证身份和权限。
2. 分析器：对SQL语句进行词法分析和语法分析。
3. 优化器：选择最优的执行方案，如索引选择。
4. 执行器：验证执行权限，调用存储引擎接口，返回引擎的执行结果。

# 索引

## 聚簇索引与非聚簇索引

聚簇索引在叶结点存储了所有的行数据。根据辅助索引查找时，需要先查出主键值，然后根据得到的主键值在主键索引中查询出行数据（回表查询）。

非聚簇索引在叶结点存储的是行数据的地址。根据辅助索引查找时，可以直接得到数据的地址。

## 索引覆盖

指构建索引的字段包含了SELECT的数据列。

# 事务

## 什么是事务

事务是逻辑上的一组数据库操作，要么全部执行，要么都不执行。

## 四大特性——ACID

- **原子性**（Atomic）：事务是最小执行单位，不允许分割，要么全部执行，要么都不执行。
- **一致性**（Consistent）：事务执行前后，数据库的完整性约束没有被破坏。
- **隔离性**（Isolation）：并发访问数据库时，事务之间互不影响。
- **持久性**（Durability）：事务提交后对数据库中数据的改变是永久的，不会被回滚。

## 并发问题

- **脏读**：一个事务正在访问并修改某个数据，但是修改后还没提交，如果此时另一个事务也访问了该数据，那么另一个事务读到的是未提交的数据，称为脏读。
- **丢失修改**：一个事务正在访问并修改某个数据，但是修改后还没提交，如果此时另一个事务也对该数据进行了修改，那么第一个事务的修改就被覆盖了，称为丢失修改。
- **不可重复读**：在一个事务两次访问同一个数据之间，另一个事务对该数据进行了**修改**，导致第一个事务两次访问的结果不一致。
- **幻读**：在一个事务两次进行相同查询之间，另一个事务进行了**插入**操作，导致第一个事务两次查询到的数据行数不一致。

## 隔离级别

- **读未提交**（READ UNCOMMITED）：事务中允许读取其他事务未提交的数据变更，可能导致**脏读、不可重复读、幻读**。
- **读已提交**（READ COMMITED）：事务中允许读取其他事务已提交的数据，可能导致**幻读、不可重复读**。
- **可重复读**（REPEATABLE READ）：事务中对同一字段的多次读取结果一样，就算期间被其他事务修改过，可能存在**幻读**。
- **串行化**（SERIALIZABLE）：所有事务依次逐个执行，事务之间互不干扰。

InnoDB默认的隔离级别是可重复读，使用Next-Key Lock算法，也可以避免**幻读**。

## 锁

### 从粒度划分

- 表级锁：对当前操作的整张表加锁，资源消耗少，加锁快，不会出现死锁，但是并发度最低。

- 行级锁：对当前操作行加锁，并发度高。

### 从操作类型分

- 共享锁（S）：多个读锁可以共存。
- 排他锁（X）：不能和其他写锁和读锁共存。
- 意向共享锁（IS）：加S锁之前要先加IS锁，从粗粒度到细粒度依次加锁。
- 意向排他锁（IX）：加X锁之前要先加IX锁，从粗粒度到细粒度依次加锁。

### InnoDB锁算法

- **Record Lock**：锁定符合条件的行，其他事务不能修改和删除加锁行。
- **Gap Lock**：间隙锁，对第一条记录前的间隙或最后一条记录后的间隙加锁，不包括自身，其他事务不能加锁范围内插入数据。
- **Next-key Lock**：Record Lock + Gap Lock，可避免幻读。当查询的索引含有唯一属性时，自动降级为Record Lock。

## 大表优化

当MySQL单表数据量过大时，数据库的CRUD性能会明显下降，一些常见优化措施如下：

- 限定数据范围：禁止不带任何数据范围条件的查询语句。

- 读写分离：主库负责写，从库负责读。
- 垂直分区：按列拆成多张表。可以使列数据变小，简化表结构，但是会出现冗余，会让事务变得复杂。

- 水平分区：按行拆成多张表，逻辑上还是一个表，物理上拆分为多个文件，可以避免单个表数据量过大对性能造成影响，但会带来逻辑、部署、运维的各种复杂的。

## 数据库连接池

可以实现对数据库连接的复用，不用每次都进行创建销毁操作，减少了用户等待建立数据库连接的时间。

可以通过连接池最大值等属性动态控制数据库连接数量。

# 分区

- RANGE分区：基于某个字段按多个连续区间进行分区。如按年月存放数据。
- LIST分区：基于某个字段按给定的多个LIST进行分区，LIST中指定了分区的值。
- HASH分区：基于某个字段利用自定义hash算法进行分区，如取余。
- KEY分区：与HASH分区类似，但是使用MySQL数据库提供的函数进行分区。

# MVCC

MVCC通过版本控制在undolog中找回数据的历史版本，可以并发读与读，读与写操作，只有写与写之间会相互阻塞，提高了并发度。只在READ COMMITED和REPEATABLE READ两个隔离级别下工作。

## 隐藏字段

- DB_TRX_ID（6字节）：记录最近一次对本行数据进行修改（插入，更新，删除）的事务ID。
- DB_ROLL_PTR（7字节）：回滚指针。
- DB_ROW_ID（6字节）：InnoDB默认递增ID（与MVCC无关）。

## 快照（read view）关键参数

- low_limit_id：当前最大事务ID+1，即下一个将分配的事务ID。
- up_limit_id：trx_ids中最小的事务ID，若trx_ids为空，则等于low_limit_id
- trx_ids：快照创建时其他未提交的活跃事务ID列表。
- create_trx_id：当前创建事务的ID，是一个递增ID。

## 可见性比较算法

判断数据行中记录的事务ID是否存在于活跃事务ID之中：

1. 若数据行记录的事务ID**小于**活跃事务ID列表中的最小ID，则当前事务可以直接读取该行数据。
2. 若数据行记录的事务ID大于活跃事务ID列表的最小ID且小于活跃事务ID列表的最大ID，则表示当前行记录的ID可能处于活跃状态，需要遍历活跃事务ID列表进行判断可见性。

若数据行记录的事务ID大于生成快照时系统的最大事务ID，则数据行对当前事务不可见。

通过回滚指针回滚直到找到对当前事务可见的数据版本。

## 快照读和当前读

- 快照读：普通的SELECT语句，不会产生幻读。
- 当前读：SELECT...LOCK IN SHARE MODE、SELECT...FOR UPDATE、INSERT、UPDATE、DELETE等都是获取最新数据。通过next-key lock避免幻读。

InnoDB在快照读的情况下并没有真正避免幻读，但是在当前读的情况下可以避免不可重复读和幻读。

## REPEATABLE READ和READ COMMETED时生成快照的区别

1. RR级别下，事务只有执行第一条SELECT语句时会生成一个快照。
2. RC级别下，事务每次执行SELECT语句时都会重新生成快照。
