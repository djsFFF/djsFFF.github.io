---
title: JVM学习系列一：内存管理
date: 2020-08-11 20:15:00
tags: 
	- JVM
	- JAVA
categories:
	- JVM
typora-root-url: ..
---

本文记录了《深入了解Java虚拟机：JVM高级特性与最佳实践》中第二部分“自动内存管理”的学习笔记。

<!--more-->

# JVM运行时数据区

![image-20200811234856572](/images/JVM%E5%AD%A6%E4%B9%A0/image-20200811234856572.png)

1. **程序计数器：** **线程私有**，如果执行的是Java方法，可以看作是当前线程所执行的字节码的行号指示器；如果执行的是native方法，那么记录的值为空。是一块较小的内存空间，唯一一个没有规定任何OutOfMemoryError的区域。

2. **虚拟机栈：** **线程私有**。每个Java方法被执行时，JVM会创建一个栈帧入栈，方法执行完毕时栈帧出栈。栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。

3. **本地方法栈：** **线程私有**。与虚拟机栈的作用相似，区别在于虚拟机栈是为虚拟机执行Java方法服务的，而本地方法栈是为虚拟机使用到的本地（Native）方法服务。

4. **堆：** **线程共享**。堆是虚拟机管理的内存中最大的一块，在虚拟机启动时创建，用于存放对象实例。是垃圾收集器管理的内存区域。逻辑上连续。

5. **方法区：** **线程共享**。用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。又称为非堆。
   - **运行时常量池：**属于方法区的一部分。用于存放编译期生成的各种字面量与符号引用。

## 对象的内存分配

**指针碰撞：**使用**Serial、ParNew等带整理过程的收集器**时，堆中内存是规整的，所有被使用过的内存被放在一边，空闲的内存放在另一半，中间有一个指针作为分界点的指示器，为对象分配内存时只需要把指针向空闲方向移动一段与对象大小相等的区域。

**空闲列表：**使用**CMS这种基于清除算法的收集器**时，堆中内存是不规整的，已被使用的和空闲的内存相互交错在一起，分配内存的时候从一个维护的列表中找到一块足够大的空间划分给对象实例。

并发情况下堆内存分配不是线程安全的，解决方法：

- 对分配内存空间的动作进行同步——实际上虚拟机是采用CAS+失败重试的方式保证更新操作的原子性。
- 每个线程在堆中预先分配一小块内存（**本地线程分配缓冲**），只有本地缓冲区用完了，需要分配新的缓存区时才需要同步锁定。

## 对象的访问定位

Java程序通过栈上的reference数据来操作堆上的具体对象：

![image-20200812084404106](/images/JVM%E5%AD%A6%E4%B9%A0/image-20200812084404106.png)

**使用句柄：**堆中划分出一块内存作为句柄池，reference数据中存储对象的句柄地址，句柄中存储对象实例与类型数据各自具体的地址信息。

- 优点：reference数据中存储稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而不影响reference本身。

![image-20200812084415956](/images/JVM%E5%AD%A6%E4%B9%A0/image-20200812084415956.png)

**直接指针：**reference数据中直接存储对象地址。

- 优点：速度快，节省了一次指针定位的时间开销，HotSpot采用这种方法。

## 判断对象是否死去

### 引用计数

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器加一，当引用失效时，计数器减一。计数器值为零的对象需要被回收。

缺点：很难解决对象之间相互循环引用的问题。

### 可达性分析

通过一系列称为“GC Roots”的根对象作为起始节点集，向下搜索过程所走过的路径称为“引用链”。如果某个对象到GC Roots间没有任何引用链相连，则此对象不可达。

固定可作为GC Roots的对象包括：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态变量引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI引用的对象。
- JVM内部的引用。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映JVM内部情况的的JMXBean、JVMTI中注册的回调、本地代码缓存等。

### 引用类型

**强引用：**指程序中普遍存在的引用赋值，只要强引用关系存在，被引用的对象就不会被回收。

**软引用：**通过SoftReference类来实现，在系统将要发生内存溢出异常前，会把回收这些对象，如果回收之后内存还是不够，才会抛出内存溢出异常。

**弱引用：**通过WeakReference类实现，只能生存到下一次垃圾收集发生为止。

**虚引用：**通过PhantomReference类实现，虚引用不会影响对象的生存时间，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被回收时收到一个系统通知。

### 两次标记

在可达性分析算法中，宣告一个对象死亡至少要经历两次标记过程。

1. 如果对象没有与GC Roots相连的引用链，会被第一次标记。

2. 如果对象没有覆盖finalize()方法或fianlize()方法已被调用过一次，那么该对象可以被回收。

   否则，该对象会被放置在低优先级的F-Queue队列中等待执行finalize()方法，稍后收集器会对F-Queue中的对象进行第二次小规模标记：

   - 如果对象在finalize()方法中成功自救，那么该对象会被移出“即将回收”集合。
   - 否则该对象可以被回收。

### 方法区回收

回收内容主要包括：废弃的常量和不再使用的类。

回收废弃常量与回收堆中的对象类似。

不再使用的类需要同时满足三个条件：

- 该类的所有实例都已被回收。
- 加载该类的类加载器已被回收。
- 该类对应的java.lang.Class对象没有在任何地方被引用。

# 垃圾收集器

程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭，内存分配和回收具有确定性。

堆和方法区则有明显的不确定性，内存分配和回收是动态的。

## 垃圾收集算法

从如何判定对象消亡的角度可将垃圾收集算法划分为“引用计数式垃圾收集”和“追踪式垃圾收集”两大类，也被称为“直接垃圾收集”和“间接垃圾收集器”。而主流JVM使用的算法都属于**追踪式垃圾收集**。

### 分代收集理论

弱分代假说：绝大多数对象都是朝生夕灭的。

强分代假说：熬过越多次垃圾回收过程的对象越难以消亡。

跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

**部分收集（Partial GC）**，指目标不是完整收集整个Java堆的垃圾收集，又分为：

- 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
- 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。
- 混合收集（Mixed GC）：指目标是整个新生代和部分老年代的垃圾收集。

**整堆收集（Full GC）**，收集整个Java堆和方法区的垃圾收集。

### 标记-清除算法

分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，然后统一回收掉所有被标记的对象。

会产生大量不连续的内存碎片。

### 标记-复制算法

将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当前使用区域内存用完时，标记出存活的对象并复制到另一个区域，然后把当前使用区域全部清理掉。

简单高效，不会产生内存碎片，但是会浪费空间，对象存活率高时，复制代价高。

**Appel式回收**：将新生代分为一块较大的Eden区和两块较小的Survivor区，HotSpot默认比例大小为8:1:1。每次分配只使用Eden和其中一块Survivor，发生垃圾收集时，标记出Eden和Survivor中存活的对象并复制到另一块Survivor空间上，然后把已用空间全部清理掉。

### 标记-整理算法

针对老年代的存亡特征，该算法在标记后将存活的对象移动在一起，然后将其他对象清理掉。

标记-整理算法通过移动对象来整理内存，对象移动操作需要暂停整个应用程序（Stop The World）。

标记-清楚算法不需要移动对象来整理内存，影响应用程序的吞吐量。

## 根节点枚举

目前，所有的收集器在根节点枚举时必须暂停用户线程。

HotSpot在类加载时就会把对象的引用信息记录在**OopMap**中，OopMap记录了方法执行时用到的本地变量到堆上变量的引用关系，这样就不需要一个不漏地从方法区等GC Roots开始查找。

### 安全点与安全区域

#### 安全点

导致引用关系变化的指令非常多，不可能为每一条指令都生成对应的OopMap，于是HotSpot**只是在安全点记录这些信息**。

安全点位置：循环末尾、方法临返回前、方法调用之后、抛异常的位置。

使所有用户线程中断：

- 抢占式中断：在GC发生时，首先中断所有用户线程，若某个线程未执行到安全点，则恢复线程使其执行到安全点。基本不用此方法。

- 主动式中断：设置一个中断标志，各线程不断地主动轮询这个标志，中断标志为真时就在最近的安全点上主动中断挂起。

#### 安全区域

用户线程处于Sleep或者Blocked状态时，无法响应虚拟机的中断请求，不能走到安全点去中断挂起自己。

**安全区域**是指在代码片段中，引用关系不会发生变化，相当于是拉伸了的安全点。

在GC发生时，虚拟机不用去管处于安全区域的线程。线程要离开安全区域时，需要检查虚拟机是否已完成根节点枚举，如果完成了，就可以继续执行，否则需要等待收到可以离开安全区域的信号。

### 记忆集与卡表

#### 记忆集

在进行Minor GC时，新生代中的对象有可能被老年代引用，需要在固定的GC Roots之外，再额外遍历整个老年代来寻找跨代引用，保证可达性分析的准确性。但这会给内存回收带来很大的性能负担。

**记忆集**把老年代划分为若干个小块，标识出哪些块存在跨代引用，发生GC时只需要将存在跨代引用的块中的对象加入GC Roots进行扫描。

#### 卡表

记忆集分块的精度可以选择：

- 字长精度：记录一个机器字长是否包含跨代指针。
- 对象精度：记录一个对象是否有字段包含跨代指针。
- 卡精度：记录一个内存区域是否有对象包含跨代指针。

**卡表**：采用卡精度实现的记忆集。卡表可以是一个字节数组，数组中每一个元素（1字节）对应着一个特定大小（512字节）的内存区域的起始地址，这个内存区域称为**卡页**。只要卡页内的一个或多个对象的字段存在跨代指针，此卡页**变脏**，该卡页对应卡表的数组元素的值为1。

### 卡表维护——写屏障

对于解释执行的字节码，虚拟机有充分的介入空间来维护卡表，但是对于即时编译后的机器指令流，虚拟机无法处理。

HotSpot虚拟机通过**写屏障维护卡表**，引用对象赋值时会产生一个环形通知供程序执行额外操作，即赋值的前后都在写屏障的范围内，可以在赋值后更新卡表状态。

卡表在高并发下的“**伪共享**”问题：CPU读取数据以缓存行为单位（64字节），而每个卡表元素只占1字节，当多个线程修改的卡表元素属于同一个缓存行时，就会彼此影响（写回、无效化或者同步）而导致性能降低。

- 解决方法：更新卡表时，增加一个判断条件，只有当前卡表元素未变脏时才将其标记为变脏。

## 并发的可达性分析

可达性分析理论上要求全过程都基于一个能保障一致性的快照中才能进行分析，这意味着必须全程冻结用户线程。

为什么可达性分析必须在一个能保障一致性的快照上才能保证正确性？

可达性分析遍历过程中根据“是否访问过”这个条件将对象标记为三种颜色（**三色标记**）：

- 白色：该对象未被访问过。可达性分析开始时全部都是白色，结束时仍是白色的对象不可达。
- 黑色：该对象已被访问过且该对象的所有引用已被扫描过。
- 灰色：该对象已被访问过但至少还有一个引用没有被扫描过。

若用户线程没有冻结，与收集器并发，有可能造成**对象消失**：将原本存活的对象标记为已消亡

对象消失需要以下两个条件同时满足：

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用。
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

解决对象消失的方法：

- **增量更新**：破坏第一个条件。当黑色对象插入新的指向白色对象的引用时，记录该引用，在扫描结束后，再以这些黑色对象为根重新扫描一次。
- **原始快照**：破坏第二个条件。当灰色对象要删除指向白色对象的引用关系时，记录被删除的引用，在扫描结束后，再以这些灰色对象为根重新扫描一次。

对引用关系的记录都是通过**写屏障**实现的。

## 经典垃圾收集器

![image-20200813162127059](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20200813162127059.png)

连线表示可以搭配使用，分为新生代和老年代收集器。

### Serial收集器

**新生代**收集器。进行垃圾收集时，必须暂停其他工作线程。采用**标记-复制**算法。

### ParNew收集器

**新生代**收集器。Serial收集器的多线程并行版本。采用**标记-复制**算法。

### Parallel Scavenge收集器

**新生代**收集器。类似ParNew收集器。特点可以控制`吞吐量=代码运行时间 / (代码运行时间+垃圾收集时间)`

参数：

- MaxGCPauseMillis：控制最大GC停顿时间（通过降低新生代空间来降低停顿时间，吞吐量也会下降）。
- GCTimeRatio：直接设置吞吐量大小。
- UseAdaptiveSizePolicy：虚拟机会根据当前运行情况动态调整新生代大小、Eden与Survivor比例等参数，以提供最合适的停顿时间或最大的吞吐量。

采用标记-复制算法。

### Serial Old收集器

**老年代**收集器。Serial收集器的老年代版本。单线程。采用标记-整理算法。

### Parallel Old收集器

**老年代**收集器。Parallel Scavenge收集器的老年代版本，支持多线程并发收集。采用标记-整理算法。

### CMS（Concurrent Mark Sweep）收集器

**老年代**收集器。采用标记-清除算法实现。

收集过程：

1. 初始标记：标记GC Roots能直接关联到的对象，速度很快，需要停顿。
2. 并发标记：从GC Roots的直接关联对象开始遍历，耗时长，并发执行。
3. 重新标记：修正并发标记期间的增量更新，比初始标记耗时长，需要停顿。
4. 并发清除：清理死亡对象，并发执行。

优点：并发收集、低停顿。

缺点：

- 并发执行也会占用CPU资源，导致用户线程吞吐量降低（变慢）。
- 无法处理**浮动垃圾**。CMS并发标记和清除时，用户线程还会产生新的垃圾对象，只能等下一次GC再清理。
- 需要预留足够的内存空间给用户线程使用，要是垃圾收集期间预留的内存无法满足程序分配新对象的需求，就会出现“**并发失败**”。这时JVM只能冻结用户线程，临时启用Serial Old收集器来对老年代进行垃圾收集。可以设置触发CMS的百分比，
- 标记-清除算法会产生内存碎片。可以设置为标记-整理算法，但是内存整理时无法并发。可以设置在若干次不整理空间的Full GC后，下一次Full GC前先进行碎片整理。

### G1（Garbage First）收集器

整堆收集器，基于区域收集。采用标记-整理算法实现。

**基于区域收集**：G1将堆内存划分为若干个大小相等的独立区域（Region），Humongous是一种特殊的区域，专门用来存储大对象，通常被看着老年代的一部分。新生代和老年代是一系列区域（不一定连续）的动态集合。

**可预测的停顿时间**：将区域最为单次回收的最小单元，G1会跟踪各个区域里面垃圾的“价值”，即回收获得的空间与耗时的经验值，然后每次根据用户设定允许的停顿时间优先处理价值最大的那些区域。

收集过程：

1. 初始标记：标记与GC Roots直接相连的对象，并在区域中划分一部分用于并发回收过程的新对象分配，需要停顿。
2. 并发标记：从GC Roots开始对堆中对象进行可达性分析，并发执行。
3. 最终标记：处理并发标记期间原始快照记录，需要停顿。
4. 筛选回收：更新各个区域的统计数据，根据用户期望的停顿时间制定回收计划。把决定回收的区域的存活对象复制到空的区域中，然后清理掉这些区域，需要停顿。

细节问题：

- 跨Region引用对象：记忆集，更复杂的**卡表**，占用内存较大（20%）。
- 并发标记时保证收集线程与用户现场互不干扰：**原始快照**，需要学前屏障来跟着并发时的指针变化情况，写屏障消耗较大。此外G1把区域中一部分划分出来用于并发回收过程的新对象分配，默认为存活的。也会出现CMS的“**并发失败**”情况。
- 以**衰减均值**为理论基础实现停顿预测。

## 低延迟垃圾收集器

衡量垃圾收集器的重要指标：内存占用（Footprint）、吞吐量（Throughout）、延迟（Latency）。

### Shenandoah收集器

Oracle拒绝在Oracle JDK12中支持Shenandoah收集器，只能在OpenJDK中使用。

基于区域收集，不设分代，采用区域间的**连接矩阵代替记忆集**记录区域之间的引用关系。使用了**读屏障**、**指针转发**等技术实现可并发的标记整理算法。

收集过程：

1. 初始标记：标记与GC Roots直接相连的对象，并在区域中划分一部分用于并发回收过程的新对象分配，需要停顿。
2. 并发标记：标记出可达对象，并发执行。
3. 最终标记：处理并发标记期间的原始快照记录，需要停顿。
4. 并发清理：清理没有存活对象的区域，并发执行。
5. 并发回收：把回收区域里的存活对象复制到空的区域。通过**读屏障**和**转发指针**解决并发回收期间用户线程继续读写被移动对象的问题，并发执行。
6. 初始引用更新：建林一个线程集合点，确保所有并发回收阶段进行的收集器线程已经完成对象移动任务，需要停顿。
7. 并发引用更新：按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值，并发执行。
8. 最终引用更新：修正存在于GC Roots中的引用，需要停顿。
9. 并发清理：再次清理掉回收集中所有的区域。

细节问题：

- **转发指针**：在每一个对象头的最前面增加一个新的引用字段，初始指向对象自己。当对象有了一个新的副本时，只需要修改旧对象上转发指针的引用位置指向新对象即可。

- 如果发生并发写入，必须保证写操作发生在新复制的对象上而不是旧对象。收集器线程或者用户现场只有其中一个可以对对象进行修改，使用比较并转换（Compare And Swap，**CAS**）来保证并发时对象访问的准确性。

- 使用**读屏障**来通知虚拟机有读操作，需要进行指针转发。

### ZGC收集器

基于区域收集，不设分代。使用了**读屏障**、**染色指针**和**内存多重映射**等技术实现可并发的标记-整理算法。

ZGC的区域分为三种：

- 小型区域：容量为2MB，用于存放小于256KB的小对象。
- 中型区域：容量为32MB，用于存放256到4MB的对象。
- 大型区域：容量不固定，但必须为2MB的整数倍，用于存放4MB及以上的大对象，不会被重分配。

![image-20200813194055382](/images/JVM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20200813194055382.png)

**染色指针**：Linux下64位指针的高18位不能用了寻址，但剩余的46位指针能够充分满足大型服务器的需求，ZGC将其高4位用于存储4个标志信息——三色标记状态、是否被移动过、是否只能通过finalize()方法才能访问。ZGC能够管理的内存不可以超过4TB（2的42次方）。

染色指针优势：

- 某个区域的存活对象被移走后，这个区域可以立即被释放和重用，不必等待所有指向该区域的引用都被修正。
- 可以大幅减少GC过程中内存屏障的使用数量。
- 染色指针可以作为一种可扩展的存储结构用于记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。

收集过程：

- 初始标记：需要停顿。

- 并发标记：遍历对象图进行可达性分析，更新染色指针中Marked 0、Marked 1标志位。
- 并发预备重分配：统计出需要清理的区域组成重分配集。
- 并发重分配：把重分配集中的存活对象复制到新的区域中，并为重分配集中的每个区域维护一个转发表，记录旧对象到新对象的转发关系。ZGC进从引用上就能确定一个对象是否处于重分配集之中，如果用户线程此时访问了位于重分配集中的对象，这次访问会被内存屏障截获然后根据转发表将访问转发到新复制的对象上面，并修正更新该引用的值。
- 并发重映射：修正整个堆中指向重分配集中旧对象的所有引用。

# 内存分配与回收策略

## 优先在Eden分配

当Eden区没有足够空间进行分配时，将发起一次Minor GC。

## 大对象直接进入老年代

大对象指需要大量连续内存空间的Java对象，内存还有不少空间但是缺乏连续空间时，会提前触发GC，而对大对象的复制（新生代主要采用标记-复制算法）也会产生极大开销。

## 长期存活对象进入老年代

对于通常在Eden中诞生，如果经过一次Minor GC仍然存活且能被Survivor容纳，则该对象被移动到Survivor空间中，并且该对象年龄设为1岁。对象在Survivor中没熬过一次Minor GC，年龄就增加1，当年龄达到一定程度（15）时就会被晋升到老年代中。

## 动态对象年龄判定

如果在Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，大于或等于该年龄的对象可以直接进入老年代。

## 空间分配担保

当出现大量对象在Minor GC后仍然存活的情况时，需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代。

在Minor GC前，虚拟机必须先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果满足，则进行Minor GC，否则继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则尝试一次Minor GC，如果小于则进行一次Full GC。
