---
title: 牛客算法课程笔记
tags:
  - 笔记
categories:
  - 算法
date: 2022-01-01 08:16:30
typora-root-url: ../..
---

牛客算法课程笔记

<!--more-->

### 异或运算可以理解为无进位加法

- `a ^ a = 0`, `a ^ 0 = 0`
- 交换两个数

```java
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

### 排序

#### 1. 快排改进步骤

- 改进一：每次递归的时候，将与划分值相等的值放在一起（荷兰国旗问题），不需要再参与递归。
  - 左右两端分别保存小于和大于划分值的元素

- 改进二：每次随机选取划分值，使得平均复杂度为O(nlogn)。

#### 2. 桶排序

- 计数排序：统计数组中每种数字的频率，适用于最小值和最大值相差不大的情况。
- 基数排序：从个位到最高位（权重从低到高），每次按元素的对应位排序。

#### 3. 排序算法总结

- 不稳定：选择排序、快速排序、堆排序。
- 稳定：冒泡排序（相邻相等时不交换）、插入排序（插入到相等值的后面）、归并排序（合并遇到相等时先合入左边数组）。

| 排序算法 | 时间复杂度 | 空间复杂度 | 稳定性 |        备注        |
| :------: | :--------: | :--------: | :----: | :----------------: |
| 选择排序 |   O(n^2)   |    O(1)    |   x    |                    |
| 冒泡排序 |   O(n^2)   |    O(1)    |   ✓    |                    |
| 插入排序 |   O(n^2)   |    O(1)    |   ✓    |                    |
| 归并排序 |  O(nlogn)  |    O(n)    |   ✓    |        稳定        |
|  堆排序  |  O(nlogn)  |    O(1)    |   x    |       空间小       |
| 快速排序 |  O(nlogn)  |  O(logn)   |   x    | 最快（常数时间小） |
|  桶排序  |    O(n)    |    O(n)    |   ✓    |                    |

​	综合排序：快排的时候，当传入的子数组元素小于60时，采用插入排序。

![image-20220106080043599](./images/牛客算法课程笔记/image-20220106080043599.png) 

### 比较器

- 返回负数：第一个参数排在前面。
- 返回正数：第二个参数排在前面。
- 返回0：默认第一个排在前面。

### 链表

#### 1. 判断单链表是否有环

(1) 快慢指针从表头出发，快指针每次移动两个节点，慢指针每次移动一个节点。

(2) 若快指针为空，链表无环。

(3) 若快慢指针相交，链表有环。

#### 2. 求单链表入环节点

(1) 判断单链表是否有环。

(2) 若单链表有环，快慢指针相交点为环内某个节点。

(3) 快指针重新从表头出发，快慢指针每次移动一个节点。

(4) 返回快慢指针再次相交的节点。

#### 3. 求两个链表的第一个交点（是否有环→是否有交点→求第一个交点）

(1) 分别判断两个链表是否有环。

(2) 若一个存在环，一个不存在环，则两个链表**无交点**。

(3) 若两个链表**都不存在环**：

​	① 分别遍历两个链表并记录链表长度。

​	② 若表尾不相交，则两个链表**无交点**，否则有交点。

​	③ 长链表指针从表头先移动$长度差$个节点，然后两个指针同时移动。

​	④ 返回两个指针第一次相交的节点。

(4) 若两个链表都存在环：

​	① 分别求两个链表入环节点。

​	② 若入环节点相同：

​		Ⅰ 分别遍历两个链表到入环节点并记录长度。

​		Ⅱ 长链表指针从表头先移动$长度差$个节点，然后两个指针同时移动。

​		Ⅲ 返回两个指针第一次相交的节点。

​	③ 若入环节点不同：

​		Ⅰ 链表1从入环节点出发遍历，若再次遇到链表1的入环节点，则两个链表**无交点**。

​		Ⅱ 若遇到链表2的入环节点，则两个链表有交点，且两个入环节点均可以看做第一个相交节点。

### 二叉树

#### 1. 非递归遍历

(1) 先序遍历（中左右）

​	① 根节点入栈。

​	② while 栈不为空：

​		Ⅰ 弹出栈顶元素并打印。

​		Ⅱ 压入弹出元素的右子树。

​		Ⅲ 压入弹出元素的左子树。

(2) 后序遍历（左右中）

​	① 根节点入栈。

​	② while 栈不为空：

​		Ⅰ 弹出栈顶元素并记录。

​		Ⅱ 压入弹出元素的左子树。

​		Ⅲ 压入弹出元素的右子树。

​	③ 记录到的节点顺序为中右左，将记录反转输出（用栈记录）即为左右中。

(3) 中序遍历（左中右）

​	① 以根节点为cur节点。

​	② while 栈不为空 || cur不为空：

​		Ⅰ 从cur节点开始向左遍历到叶子节点，并依次入栈。

​		Ⅱ 弹出栈顶节点并打印。

​		Ⅲ 以弹出节点的右节点为cur节点。

#### 2. 后继节点（对应还有前驱节点）

​	定义：**中序遍历序列**中，每个节点的下一个节点为该节点的后继节点。

​	(1) 若节点有右子树，其后继节点为右子树的最左节点。

​	(2) 若节点无右子树，则向上遍历直到找到一个父节点，满足节点属于该父节点的子树。该父节点为节点的后继节点。

#### 3. 判断二叉树是否为另一个二叉树的子树

递归方法复杂度较高。

可以将两个二叉树序列化为两个字符串，判断一个字符串是否为另一个字符串的子串。

# 前缀树

节点结构：

- pass：节点通过次数。
- end：以结点为结尾的次数。
- map：key为字符（根节点为空字符''），value为下一个节点。

# 图

#### 1. 拓扑排序（有向无环图，有至少一个入度为0的点）

(1) 使用一个map记录节点的入度，queue记录入度为0的节点。

(2) while queue不为空：

​	① 弹出queue尾节点，并添加到result列表。

​	② 遍历弹出节点的下一个节点，所有节点入度-1，若入度为0，则入queue。

#### 2. 最小生成树—Prim算法

(1) 从任意节点node开始遍历所有节点：

​	① 若set中不包含node：

​		Ⅰ 将与node相连的边放入优先队列priorityQueue。

​		Ⅱ while priorityQueue不为空：

​			弹出一条边（最小边），若边的另一个节点不在set中，将边放入result，将节点加入set，并将节点的所有边加入priorityQueue。

#### 3. 最小生成树—Kruskal算法（集合查询合并可以使用并查集）

(1) 将每个节点各自单独存放在一个set中。

(2) 将所有边放在一个优先队列priorityQueue中。

(3) while priorityQueue不为空：

​	① 弹出一条边，若边的两个节点不属于同一个set：

​		Ⅰ 将边存入result。

​		Ⅱ 将两个节点所在的集合合并在一起。

#### 4. Dijkstra算法—单源最短路径算法

# 贪心算法

#### 1. 拼接最小字典序字符串

若str1 + str2 <= str2 + str1，则认为str1 < str2。按照这种排序方式对字符串数组进行排序后，拼接而成的即为最小字典序字符串。

# 暴力递归

#### 汉诺塔问题

​	存在左中右三个杆，需要将左杆上的n个圆盘移动到右杆上，并保持圆盘顺序不变，每次可以将任意杆上的第一个圆盘移动到其他杆上。

​	循环以下步骤：

(1) 将n - 1个圆盘从左移动到中。

(2) 将第n个圆盘从左移动到右。

(3) 将n - 1个圆盘从中移动到右。

